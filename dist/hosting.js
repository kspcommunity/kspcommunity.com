;new EventSource(new URL("/esbuild",location.href).toString()).addEventListener('message', () => location?.reload?.());
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// polyfill.ts
var init_polyfill = __esm({
  "polyfill.ts"() {
    ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            return;
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    };
  }
});

// esbuild_serve:http-import:https://unpkg.com/urlpattern-polyfill
var init_urlpattern_polyfill = __esm({
  "esbuild_serve:http-import:https://unpkg.com/urlpattern-polyfill"() {
  }
});

// esbuild_serve:http-import:https://raw.githubusercontent.com/ungap/with-resolvers/main/index.js
var init_main = __esm({
  "esbuild_serve:http-import:https://raw.githubusercontent.com/ungap/with-resolvers/main/index.js"() {
    Promise.withResolvers || (Promise.withResolvers = function withResolvers() {
      var a2, b5, c3 = new this(function(resolve, reject2) {
        a2 = resolve;
        b5 = reject2;
      });
      return { resolve: a2, reject: b5, promise: c3 };
    });
  }
});

// esbuild_serve:http-import:https://unpkg.com/@oddbird/popover-polyfill
function P(e, t, o3) {
  N.set(e, setTimeout(() => {
    N.has(e) && e.dispatchEvent(new c("toggle", { cancelable: false, oldState: t, newState: o3 }));
  }, 0));
}
function y(e) {
  return h.get(e) || "hidden";
}
function O(e) {
  let t = e.popoverTargetElement;
  if (!(t instanceof HTMLElement))
    return;
  let o3 = y(t);
  e.popoverTargetAction === "show" && o3 === "showing" || e.popoverTargetAction === "hide" && o3 === "hidden" || (o3 === "showing" ? v(t, true, true) : d(t, false) && (L.set(t, e), H(t)));
}
function d(e, t) {
  return !(e.popover !== "auto" && e.popover !== "manual" || !e.isConnected || t && y(e) !== "showing" || !t && y(e) !== "hidden" || e instanceof V && e.hasAttribute("open") || document.fullscreenElement === e);
}
function F(e) {
  return e ? Array.from(p.get(e.ownerDocument) || []).indexOf(e) + 1 : 0;
}
function $(e) {
  let t = W(e), o3 = U(e);
  return F(t) > F(o3) ? t : o3;
}
function M(e) {
  let t = p.get(e);
  for (let o3 of t || [])
    if (!o3.isConnected)
      t.delete(o3);
    else
      return o3;
  return null;
}
function g(e) {
  return typeof e.getRootNode == "function" ? e.getRootNode() : e.parentNode ? g(e.parentNode) : e;
}
function W(e) {
  for (; e; ) {
    if (e instanceof HTMLElement && e.popover === "auto" && h.get(e) === "showing")
      return e;
    if (e = e.parentElement || g(e), e instanceof x && (e = e.host), e instanceof Document)
      return;
  }
}
function U(e) {
  for (; e; ) {
    let t = e.popoverTargetElement;
    if (t instanceof HTMLElement)
      return t;
    if (e = e.parentElement || g(e), e instanceof x && (e = e.host), e instanceof Document)
      return;
  }
}
function G(e) {
  let t = /* @__PURE__ */ new Map(), o3 = 0;
  for (let l4 of p.get(e.ownerDocument) || [])
    t.set(l4, o3), o3 += 1;
  t.set(e, o3), o3 += 1;
  let r = null;
  function i4(l4) {
    let a2 = W(l4);
    if (a2 === null)
      return null;
    let w4 = t.get(a2);
    (r === null || t.get(r) < w4) && (r = a2);
  }
  return i4(e.parentElement || g(e)), r;
}
function Q(e) {
  return e.hidden || e instanceof x || (e instanceof HTMLButtonElement || e instanceof HTMLInputElement || e instanceof HTMLSelectElement || e instanceof HTMLTextAreaElement || e instanceof HTMLOptGroupElement || e instanceof HTMLOptionElement || e instanceof HTMLFieldSetElement) && e.disabled || e instanceof HTMLInputElement && e.type === "hidden" || e instanceof HTMLAnchorElement && e.href === "" ? false : typeof e.tabIndex == "number" && e.tabIndex !== -1;
}
function _(e) {
  if (e.shadowRoot && e.shadowRoot.delegatesFocus !== true)
    return null;
  let t = e;
  t.shadowRoot && (t = t.shadowRoot);
  let o3 = t.querySelector("[autofocus]");
  if (o3)
    return o3;
  {
    let l4 = t.querySelectorAll("slot");
    for (let a2 of l4) {
      let w4 = a2.assignedElements({ flatten: true });
      for (let n3 of w4) {
        if (n3.hasAttribute("autofocus"))
          return n3;
        if (o3 = n3.querySelector("[autofocus]"), o3)
          return o3;
      }
    }
  }
  let r = e.ownerDocument.createTreeWalker(t, NodeFilter.SHOW_ELEMENT), i4 = r.currentNode;
  for (; i4; ) {
    if (Q(i4))
      return i4;
    i4 = r.nextNode();
  }
}
function J(e) {
  _(e)?.focus();
}
function H(e) {
  if (!d(e, false))
    return;
  let t = e.ownerDocument;
  if (!e.dispatchEvent(new c("beforetoggle", { cancelable: true, oldState: "closed", newState: "open" })) || !d(e, false))
    return;
  let o3 = false;
  if (e.popover === "auto") {
    let i4 = e.getAttribute("popover"), l4 = G(e) || t;
    if (T(l4, false, true), i4 !== e.getAttribute("popover") || !d(e, false))
      return;
  }
  M(t) || (o3 = true), S.delete(e);
  let r = t.activeElement;
  e.classList.add(":popover-open"), h.set(e, "showing"), b.has(t) || b.set(t, /* @__PURE__ */ new Set()), b.get(t).add(e), J(e), e.popover === "auto" && (p.has(t) || p.set(t, /* @__PURE__ */ new Set()), p.get(t).add(e), q(L.get(e), true)), o3 && r && e.popover === "auto" && S.set(e, r), P(e, "closed", "open");
}
function v(e, t = false, o3 = false) {
  if (!d(e, true))
    return;
  let r = e.ownerDocument;
  if (e.popover === "auto" && (T(e, t, o3), !d(e, true)) || (q(L.get(e), false), L.delete(e), o3 && (e.dispatchEvent(new c("beforetoggle", { oldState: "open", newState: "closed" })), !d(e, true))))
    return;
  b.get(r)?.delete(e), p.get(r)?.delete(e), e.classList.remove(":popover-open"), h.set(e, "hidden"), o3 && P(e, "open", "closed");
  let i4 = S.get(e);
  i4 && (S.delete(e), t && i4.focus());
}
function B(e, t = false, o3 = false) {
  let r = M(e);
  for (; r; )
    v(r, t, o3), r = M(e);
}
function T(e, t, o3) {
  let r = e.ownerDocument || e;
  if (e instanceof Document)
    return B(r, t, o3);
  let i4 = null, l4 = false;
  for (let a2 of p.get(r) || [])
    if (a2 === e)
      l4 = true;
    else if (l4) {
      i4 = a2;
      break;
    }
  if (!l4)
    return B(r, t, o3);
  for (; i4 && y(i4) === "showing" && p.get(r)?.size; )
    v(i4, t, o3);
}
function D(e) {
  if (!e.isTrusted)
    return;
  let t = e.composedPath()[0];
  if (!t)
    return;
  let o3 = t.ownerDocument;
  if (!M(o3))
    return;
  let i4 = $(t);
  if (i4 && e.type === "pointerdown")
    A.set(o3, i4);
  else if (e.type === "pointerup") {
    let l4 = A.get(o3) === i4;
    A.delete(o3), l4 && T(i4 || o3, false, true);
  }
}
function q(e, t = false) {
  if (!e)
    return;
  k.has(e) || k.set(e, e.getAttribute("aria-expanded"));
  let o3 = e.popoverTargetElement;
  if (o3 instanceof HTMLElement && o3.popover === "auto")
    e.setAttribute("aria-expanded", String(t));
  else {
    let r = k.get(e);
    r ? e.setAttribute("aria-expanded", r) : e.removeAttribute("aria-expanded");
  }
}
function j() {
  return typeof HTMLElement < "u" && typeof HTMLElement.prototype == "object" && "popover" in HTMLElement.prototype;
}
function f(e, t, o3) {
  let r = e[t];
  Object.defineProperty(e, t, { value(i4) {
    return r.call(this, o3(i4));
  } });
}
function Y() {
  return typeof globalThis.CSSLayerBlockRule == "function";
}
function Z() {
  let e = Y();
  return `
${e ? "@layer popover-polyfill {" : ""}
  :where([popover]) {
    position: fixed;
    z-index: 2147483647;
    inset: 0;
    padding: 0.25em;
    width: fit-content;
    height: fit-content;
    border-width: initial;
    border-color: initial;
    border-image: initial;
    border-style: solid;
    background-color: canvas;
    color: canvastext;
    overflow: auto;
    margin: auto;
  }

  :where(dialog[popover][open]) {
    display: revert;
  }

  :where([anchor].\\:popover-open) {
    inset: auto;
  }

  :where([anchor]:popover-open) {
    inset: auto;
  }

  @supports not (background-color: canvas) {
    :where([popover]) {
      background-color: white;
      color: black;
    }
  }

  @supports (width: -moz-fit-content) {
    :where([popover]) {
      width: -moz-fit-content;
      height: -moz-fit-content;
    }
  }

  @supports not (inset: 0) {
    :where([popover]) {
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  }

  :where([popover]:not(.\\:popover-open)) {
    display: none;
  }
${e ? "}" : ""}
`;
}
function I(e) {
  let t = Z();
  if (m === null)
    try {
      m = new CSSStyleSheet(), m.replaceSync(t);
    } catch {
      m = false;
    }
  if (m === false) {
    let o3 = document.createElement("style");
    o3.textContent = t, e instanceof Document ? e.head.prepend(o3) : e.prepend(o3);
  } else
    e.adoptedStyleSheets = [m, ...e.adoptedStyleSheets];
}
function K() {
  globalThis.ToggleEvent = globalThis.ToggleEvent || c;
  function e(n3) {
    return n3?.includes(":popover-open") && (n3 = n3.replace(X, "$1.\\:popover-open")), n3;
  }
  f(Document.prototype, "querySelector", e), f(Document.prototype, "querySelectorAll", e), f(Element.prototype, "querySelector", e), f(Element.prototype, "querySelectorAll", e), f(Element.prototype, "matches", e), f(Element.prototype, "closest", e), f(DocumentFragment.prototype, "querySelectorAll", e), f(DocumentFragment.prototype, "querySelectorAll", e), Object.defineProperties(HTMLElement.prototype, { popover: { enumerable: true, configurable: true, get() {
    if (!this.hasAttribute("popover"))
      return null;
    let n3 = (this.getAttribute("popover") || "").toLowerCase();
    return n3 === "" || n3 == "auto" ? "auto" : "manual";
  }, set(n3) {
    this.setAttribute("popover", n3);
  } }, showPopover: { enumerable: true, configurable: true, value() {
    H(this);
  } }, hidePopover: { enumerable: true, configurable: true, value() {
    v(this, true, true);
  } }, togglePopover: { enumerable: true, configurable: true, value(n3) {
    h.get(this) === "showing" && n3 === void 0 || n3 === false ? v(this, true, true) : (n3 === void 0 || n3 === true) && H(this);
  } } });
  let t = Element.prototype.attachShadow;
  t && Object.defineProperties(Element.prototype, { attachShadow: { enumerable: true, configurable: true, writable: true, value(n3) {
    let s2 = t.call(this, n3);
    return I(s2), s2;
  } } });
  let o3 = HTMLElement.prototype.attachInternals;
  o3 && Object.defineProperties(HTMLElement.prototype, { attachInternals: { enumerable: true, configurable: true, writable: true, value() {
    let n3 = o3.call(this);
    return n3.shadowRoot && I(n3.shadowRoot), n3;
  } } });
  let r = /* @__PURE__ */ new WeakMap();
  function i4(n3) {
    Object.defineProperties(n3.prototype, { popoverTargetElement: { enumerable: true, configurable: true, set(s2) {
      if (s2 === null)
        this.removeAttribute("popovertarget"), r.delete(this);
      else if (s2 instanceof Element)
        this.setAttribute("popovertarget", ""), r.set(this, s2);
      else
        throw new TypeError("popoverTargetElement must be an element or null");
    }, get() {
      if (this.localName !== "button" && this.localName !== "input" || this.localName === "input" && this.type !== "reset" && this.type !== "image" && this.type !== "button" || this.disabled || this.form && this.type === "submit")
        return null;
      let s2 = r.get(this);
      if (s2 && s2.isConnected)
        return s2;
      if (s2 && !s2.isConnected)
        return r.delete(this), null;
      let u3 = g(this), E5 = this.getAttribute("popovertarget");
      return (u3 instanceof Document || u3 instanceof C) && E5 && u3.getElementById(E5) || null;
    } }, popoverTargetAction: { enumerable: true, configurable: true, get() {
      let s2 = (this.getAttribute("popovertargetaction") || "").toLowerCase();
      return s2 === "show" || s2 === "hide" ? s2 : "toggle";
    }, set(s2) {
      this.setAttribute("popovertargetaction", s2);
    } } });
  }
  i4(HTMLButtonElement), i4(HTMLInputElement);
  let l4 = (n3) => {
    let s2 = n3.composedPath(), u3 = s2[0];
    if (!(u3 instanceof Element) || u3?.shadowRoot)
      return;
    let E5 = g(u3);
    if (!(E5 instanceof C || E5 instanceof Document))
      return;
    let R4 = s2.find((z4) => z4.matches?.("[popovertargetaction],[popovertarget]"));
    if (R4) {
      O(R4), n3.preventDefault();
      return;
    }
  }, a2 = (n3) => {
    let s2 = n3.key, u3 = n3.target;
    !n3.defaultPrevented && u3 && (s2 === "Escape" || s2 === "Esc") && T(u3.ownerDocument, true, true);
  };
  ((n3) => {
    n3.addEventListener("click", l4), n3.addEventListener("keydown", a2), n3.addEventListener("pointerdown", D), n3.addEventListener("pointerup", D);
  })(document), I(document);
}
var c, N, x, V, b, p, h, L, S, A, k, C, X, m;
var init_popover_polyfill = __esm({
  "esbuild_serve:http-import:https://unpkg.com/@oddbird/popover-polyfill"() {
    c = class extends Event {
      oldState;
      newState;
      constructor(t, { oldState: o3 = "", newState: r = "", ...i4 } = {}) {
        super(t, i4), this.oldState = String(o3 || ""), this.newState = String(r || "");
      }
    };
    N = /* @__PURE__ */ new WeakMap();
    x = globalThis.ShadowRoot || function() {
    };
    V = globalThis.HTMLDialogElement || function() {
    };
    b = /* @__PURE__ */ new WeakMap();
    p = /* @__PURE__ */ new WeakMap();
    h = /* @__PURE__ */ new WeakMap();
    L = /* @__PURE__ */ new WeakMap();
    S = /* @__PURE__ */ new WeakMap();
    A = /* @__PURE__ */ new WeakMap();
    k = /* @__PURE__ */ new WeakMap();
    C = globalThis.ShadowRoot || function() {
    };
    X = /(^|[^\\]):popover-open\b/g;
    m = null;
    j() || K();
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter@3.0.1/src/es6.js
var init_es6 = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter@3.0.1/src/es6.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter@3.0.1/mod.js
var init_mod = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter@3.0.1/mod.js"() {
    init_es6();
  }
});

// pages/shared/restSpec.ts
async function asExternal(promise) {
  try {
    return {
      status: "fulfilled",
      value: await promise
    };
  } catch (e) {
    return {
      status: "rejected",
      reason: e
    };
  }
}
function json() {
  return async (rsp) => {
    if (!rsp.ok) {
      return await asExternal(Promise.reject(await rsp.text()));
    }
    return await asExternal(rsp.json());
  };
}
function none() {
  return async (rsp) => {
    if (!rsp.ok) {
      return await asExternal(Promise.reject(await rsp.text()));
    }
    return await asExternal(Promise.resolve(true));
  };
}
function blob() {
  return async (rsp) => {
    if (!rsp.ok) {
      return await asExternal(Promise.reject(await rsp.text()));
    }
    return await asExternal(rsp.blob());
  };
}
function stupidErrorAlert(data) {
  if (data.status === "fulfilled") {
    return data.value;
  }
  alert(displayError(data.reason));
  throw data.reason;
}
function reject(rsp) {
  return asExternal(Promise.reject(rsp));
}
function displayError(data) {
  console.error("displayError", data);
  if (data instanceof Error) {
    if (data.message === "Failed to fetch") {
      return "Error: Can't load. Please try again later.";
    }
    if (data.message) {
      return `Error: ${data.message}`;
    }
  }
  if (typeof data === "string") {
    try {
      const jdata = JSON.parse(data);
      if (jdata && typeof jdata === "object" && "type" in jdata && "message" in jdata && jdata.type === "assert" && jdata.message)
        return `Error: ${jdata.message}`;
    } catch (_e2) {
    }
  }
  return `Error: ${defaultError}`;
}
function headers(token) {
  return {
    "Authorization": `JWT ${token}`
  };
}
var defaultError, API;
var init_restSpec = __esm({
  "pages/shared/restSpec.ts"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    defaultError = "Something happend unexpectedly. Please try again later.";
    API = {
      getToken: () => localStorage["access-token"],
      BASE_URL: localStorage.OVERRIDE_BASE_URL || (location.hostname == "bbn.one" ? "https://bbn.one/api/@bbn/" : "http://localhost:8443/api/@bbn/"),
      WS_URL: localStorage.OVERRIDE_WS_URL || (location.hostname == "bbn.one" ? "wss://bbn.one/ws" : "ws://localhost:8443/ws"),
      bugReport: (bugReport2) => fetch(`${API.BASE_URL}bug-track/`, {
        method: "POST",
        body: JSON.stringify(bugReport2)
      }),
      isPermited: (requiredPermissions, userPermission) => requiredPermissions.every((required) => userPermission.find((user) => required.startsWith(user))),
      user: {
        mail: {
          validate: {
            post: (token) => fetch(`${API.BASE_URL}user/mail/validate/${token}`, {
              method: "POST",
              headers: headers(API.getToken())
            }).then(none())
          },
          resendVerifyEmail: {
            post: () => fetch(`${API.BASE_URL}user/mail/resend-verify-email`, {
              method: "POST",
              headers: headers(API.getToken())
            }).then(none())
          }
        },
        setMe: {
          post: (para) => fetch(`${API.BASE_URL}user/set-me`, {
            method: "POST",
            headers: headers(API.getToken()),
            body: JSON.stringify(para)
          }).then(none()).catch(reject)
        },
        picture: (id) => fetch(`${API.BASE_URL}user/${id}/picture`, {
          headers: headers(API.getToken())
        }).then(blob()).catch(reject)
      },
      auth: {
        oauthRedirect: (type) => `${API.BASE_URL}auth/redirect/${type}?goal=${localStorage.getItem("goal") ?? "/music"}`,
        refreshAccessToken: {
          post: (refreshToken) => fetch(`${API.BASE_URL}auth/refresh-access-token`, {
            method: "POST",
            headers: headers(refreshToken)
          }).then(json()).catch(reject)
        },
        oauth: {
          post: (provider, code) => {
            const param = new URLSearchParams({ code });
            return fetch(`${API.BASE_URL}auth/oauth/${provider}?${param.toString()}`, {
              method: "POST"
            }).then(json()).catch(reject);
          }
        },
        fromUserInteraction: {
          get: (id) => fetch(`${API.BASE_URL}auth/from-user-interaction/${id}`).then(json()).catch(reject)
        },
        forgotPassword: {
          post: (email) => fetch(`${API.BASE_URL}auth/reset-password`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              email
            })
          }).then(none())
        },
        register: {
          post: (data) => fetch(`${API.BASE_URL}auth/register`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
          }).then(json()).catch(reject)
        },
        email: {
          post: (data) => fetch(`${API.BASE_URL}auth/email`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
          }).then(json()).catch(reject)
        }
      },
      wallet: {
        get: () => fetch(`${API.BASE_URL}wallet/`, {
          headers: headers(API.getToken())
        }).then(json()).catch(reject),
        requestPayout: (amount) => fetch(`${API.BASE_URL}wallet/`, {
          method: "PUT",
          headers: headers(API.getToken()),
          body: JSON.stringify({ amount })
        }).then(json()).catch(reject)
      },
      oauth: {
        validate: (id, scope, redirect_uri) => fetch(`${API.BASE_URL}oauth/validate`, {
          method: "POST",
          headers: headers(API.getToken()),
          body: JSON.stringify({ id, scope, redirect_uri })
        }).then(json()).catch(reject),
        authorize: (id, scope, redirect_uri) => fetch(`${API.BASE_URL}oauth/authorize`, {
          method: "POST",
          headers: headers(API.getToken()),
          body: JSON.stringify({ id, scope, redirect_uri })
        }).then(json()).catch(reject),
        list: () => fetch(`${API.BASE_URL}oauth/applications`, {
          headers: headers(API.getToken())
        }).then(json()).catch(reject),
        post: (name, redirect, icon) => fetch(`${API.BASE_URL}oauth/applications`, {
          method: "POST",
          headers: headers(API.getToken()),
          body: JSON.stringify({ name, redirect, icon })
        }).then(json()).catch(reject),
        icon: (clientid) => fetch(`${API.BASE_URL}oauth/applications/${clientid}/download`, {
          headers: headers(API.getToken())
        }).then(blob()),
        delete: (clientid) => fetch(`${API.BASE_URL}oauth/applications/${clientid}`, {
          method: "DELETE",
          headers: headers(API.getToken())
        }).then(none())
      },
      admin: {
        search: (query) => fetch(`${API.BASE_URL}admin/search?query=${query}`, {
          headers: headers(API.getToken())
        }).then(json()).catch(reject),
        files: {
          list: (offset = void 0) => {
            const paging = new URLSearchParams();
            if (offset) {
              paging.append("_offset", offset.toString());
            }
            paging.append("_limit", "31");
            return fetch(`${API.BASE_URL}admin/files?${paging}`, {
              headers: headers(API.getToken())
            }).then(json()).catch(reject);
          },
          download: (id) => fetch(`${API.BASE_URL}admin/files/${id}/download`, {
            headers: headers(API.getToken())
          }).then(blob()).catch(reject),
          delete: (id) => fetch(`${API.BASE_URL}admin/files/${id}`, {
            method: "DELETE",
            headers: headers(API.getToken())
          }).then(none()).catch(reject)
        },
        drops: {
          list: (type, offset = 0, limit = 31) => {
            const paging = new URLSearchParams();
            if (type) {
              paging.append("type", type);
            }
            paging.append("_offset", offset.toString());
            paging.append("_limit", limit.toString());
            return fetch(`${API.BASE_URL}admin/drops?${paging}`, {
              headers: headers(API.getToken())
            }).then(json()).catch(reject);
          },
          user: (id) => fetch(`${API.BASE_URL}admin/drops?user=${id}`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          id: (id) => fetch(`${API.BASE_URL}admin/drops/${id}`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          sync: () => fetch(`${API.BASE_URL}admin/sync_mapping`, {
            method: "POST",
            headers: headers(API.getToken())
          }).then(none()).catch(reject)
        },
        payouts: {
          list: () => fetch(`${API.BASE_URL}admin/payouts`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject)
        },
        groups: {
          list: (offset = 0, limit = 31) => {
            const paging = new URLSearchParams();
            paging.append("_offset", offset.toString());
            paging.append("_limit", limit.toString());
            return fetch(`${API.BASE_URL}admin/groups?${paging}`, {
              headers: headers(API.getToken())
            }).then(json()).catch(reject);
          }
        },
        wallets: {
          list: (offset = 0, limit = 31) => {
            const paging = new URLSearchParams();
            paging.append("_offset", offset.toString());
            paging.append("_limit", limit.toString());
            return fetch(`${API.BASE_URL}admin/wallets?${paging}`, {
              headers: headers(API.getToken())
            }).then(json()).catch(reject);
          }
        }
      },
      payment: {
        payouts: {
          get: () => fetch(`${API.BASE_URL}payment/payouts`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          id: (id) => ({
            get: () => fetch(`${API.BASE_URL}payment/payouts/${id}`, {
              headers: headers(API.getToken())
            }).then(json()).catch(reject)
          })
        }
      },
      hosting: {
        versions: (type) => fetch(`${API.BASE_URL}hosting/versions`, {
          method: "PUT",
          body: JSON.stringify({ type }),
          headers: headers(API.getToken())
        }).then(json()).catch(reject),
        servers: () => fetch(`${API.BASE_URL}hosting/servers`, {
          headers: headers(API.getToken())
        }).then((x5) => x5.json()),
        create: (data) => fetch(`${API.BASE_URL}hosting/servers`, {
          method: "POST",
          body: JSON.stringify(data),
          headers: headers(API.getToken())
        }).then(none()).catch(reject),
        meta: () => fetch(`${API.BASE_URL}hosting/meta`, {
          headers: headers(API.getToken())
        }).then((x5) => x5.json()),
        serverId: (id) => ({
          get: () => fetch(`${API.BASE_URL}hosting/servers/${id}`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          edit: (data) => fetch(`${API.BASE_URL}hosting/servers/${id}`, {
            method: "PATCH",
            body: JSON.stringify(data),
            headers: headers(API.getToken())
          }).then(none()).catch(reject),
          delete: () => fetch(`${API.BASE_URL}hosting/servers/${id}`, {
            method: "DELETE",
            headers: headers(API.getToken())
          }).then(none()).catch(reject),
          audit: () => fetch(`${API.BASE_URL}hosting/servers/${id}/audit`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          forcerestart: () => fetch(`${API.BASE_URL}hosting/servers`, {
            method: "PUT",
            body: JSON.stringify({ id }),
            headers: headers(API.getToken())
          }).then(none()).catch(reject),
          start: () => fetch(`${API.BASE_URL}hosting/servers/${id}/start`, {
            headers: headers(API.getToken())
          }).then(none()).catch(reject)
        }),
        store: {
          create: (type) => fetch(`${API.BASE_URL}hosting/store`, {
            method: "POST",
            body: JSON.stringify(type),
            headers: headers(API.getToken())
          }).then(none()).catch(reject)
        }
      },
      music: {
        drops: {
          list: () => fetch(`${API.BASE_URL}music/drops`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          create: () => fetch(`${API.BASE_URL}music/`, {
            method: "POST",
            headers: headers(API.getToken())
          }).then(json()).catch(reject)
        },
        id: (id) => ({
          get: () => fetch(`${API.BASE_URL}music/drops/${id}`, {
            headers: headers(API.getToken())
          }).then(json()).catch(reject),
          update: (data) => fetch(`${API.BASE_URL}music/drops/${id}`, {
            method: "PATCH",
            body: JSON.stringify(data),
            headers: headers(API.getToken())
          }).then(none()).catch(reject),
          review: {
            post: (data) => fetch(`${API.BASE_URL}music/${id}/review`, {
              method: "POST",
              headers: headers(API.getToken()),
              body: JSON.stringify(data)
            }).then(none()).catch(reject)
          },
          type: {
            post: (type) => fetch(`${API.BASE_URL}music/${id}/type/${type}`, {
              method: "POST",
              headers: headers(API.getToken())
            }).then(none()).catch(reject)
          },
          download: () => fetch(`${API.BASE_URL}music/drops/${id}/download`, {
            headers: headers(API.getToken())
          }).then(blob()).catch(reject),
          artwork: () => fetch(`${API.BASE_URL}music/${id}/artwork`, {
            headers: headers(API.getToken())
          }).then(blob()).catch(reject)
        })
      }
    };
  }
});

// esbuild_serve:http-import:https://unpkg.com/platform@1.3.6/platform.js
var require_platform = __commonJS({
  "esbuild_serve:http-import:https://unpkg.com/platform@1.3.6/platform.js"(exports, module) {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    (function() {
      "use strict";
      var objectTypes = {
        "function": true,
        "object": true
      };
      var root = objectTypes[typeof window] && window || this;
      var oldRoot = root;
      var freeExports = objectTypes[typeof exports] && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      var reOpera = /\bOpera/;
      var thisBinding = this;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var toString = objectProto.toString;
      function capitalize(string) {
        string = String(string);
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      function cleanupOS(os2, pattern, label) {
        var data = {
          "10.0": "10",
          "6.4": "10 Technical Preview",
          "6.3": "8.1",
          "6.2": "8",
          "6.1": "Server 2008 R2 / 7",
          "6.0": "Server 2008 / Vista",
          "5.2": "Server 2003 / XP 64-bit",
          "5.1": "XP",
          "5.01": "2000 SP1",
          "5.0": "2000",
          "4.0": "NT",
          "4.90": "ME"
        };
        if (pattern && label && /^Win/i.test(os2) && !/^Windows Phone /i.test(os2) && (data = data[/[\d.]+$/.exec(os2)])) {
          os2 = "Windows " + data;
        }
        os2 = String(os2);
        if (pattern && label) {
          os2 = os2.replace(RegExp(pattern, "i"), label);
        }
        os2 = format2(
          os2.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
        );
        return os2;
      }
      function each(object, callback) {
        var index = -1, length = object ? object.length : 0;
        if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
          while (++index < length) {
            callback(object[index], index, object);
          }
        } else {
          forOwn(object, callback);
        }
      }
      function format2(string) {
        string = trim(string);
        return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
      }
      function forOwn(object, callback) {
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            callback(object[key], key, object);
          }
        }
      }
      function getClassOf(value) {
        return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
      }
      function isHostType(object, property) {
        var type = object != null ? typeof object[property] : "number";
        return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
      }
      function qualify(string) {
        return String(string).replace(/([ -])(?!$)/g, "$1?");
      }
      function reduce(array, callback) {
        var accumulator = null;
        each(array, function(value, index) {
          accumulator = callback(accumulator, value, index, array);
        });
        return accumulator;
      }
      function trim(string) {
        return String(string).replace(/^ +| +$/g, "");
      }
      function parse(ua2) {
        var context = root;
        var isCustomContext = ua2 && typeof ua2 == "object" && getClassOf(ua2) != "String";
        if (isCustomContext) {
          context = ua2;
          ua2 = null;
        }
        var nav = context.navigator || {};
        var userAgent = nav.userAgent || "";
        ua2 || (ua2 = userAgent);
        var isModuleScope = isCustomContext || thisBinding == oldRoot;
        var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua2) && !/internal|\n/i.test(toString.toString());
        var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
        var java = /\bJava/.test(javaClass) && context.java;
        var rhino = java && getClassOf(context.environment) == enviroClass;
        var alpha = java ? "a" : "\u03B1";
        var beta = java ? "b" : "\u03B2";
        var doc = context.document || {};
        var opera = context.operamini || context.opera;
        var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
        var data;
        var arch = ua2;
        var description = [];
        var prerelease = null;
        var useFeatures = ua2 == userAgent;
        var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
        var isSpecialCasedOS;
        var layout = getLayout([
          { "label": "EdgeHTML", "pattern": "Edge" },
          "Trident",
          { "label": "WebKit", "pattern": "AppleWebKit" },
          "iCab",
          "Presto",
          "NetFront",
          "Tasman",
          "KHTML",
          "Gecko"
        ]);
        var name = getName([
          "Adobe AIR",
          "Arora",
          "Avant Browser",
          "Breach",
          "Camino",
          "Electron",
          "Epiphany",
          "Fennec",
          "Flock",
          "Galeon",
          "GreenBrowser",
          "iCab",
          "Iceweasel",
          "K-Meleon",
          "Konqueror",
          "Lunascape",
          "Maxthon",
          { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
          "Midori",
          "Nook Browser",
          "PaleMoon",
          "PhantomJS",
          "Raven",
          "Rekonq",
          "RockMelt",
          { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
          "SeaMonkey",
          { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Sleipnir",
          "SlimBrowser",
          { "label": "SRWare Iron", "pattern": "Iron" },
          "Sunrise",
          "Swiftfox",
          "Vivaldi",
          "Waterfox",
          "WebPositive",
          { "label": "Yandex Browser", "pattern": "YaBrowser" },
          { "label": "UC Browser", "pattern": "UCBrowser" },
          "Opera Mini",
          { "label": "Opera Mini", "pattern": "OPiOS" },
          "Opera",
          { "label": "Opera", "pattern": "OPR" },
          "Chromium",
          "Chrome",
          { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
          { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
          { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
          { "label": "Firefox for iOS", "pattern": "FxiOS" },
          { "label": "IE", "pattern": "IEMobile" },
          { "label": "IE", "pattern": "MSIE" },
          "Safari"
        ]);
        var product = getProduct([
          { "label": "BlackBerry", "pattern": "BB10" },
          "BlackBerry",
          { "label": "Galaxy S", "pattern": "GT-I9000" },
          { "label": "Galaxy S2", "pattern": "GT-I9100" },
          { "label": "Galaxy S3", "pattern": "GT-I9300" },
          { "label": "Galaxy S4", "pattern": "GT-I9500" },
          { "label": "Galaxy S5", "pattern": "SM-G900" },
          { "label": "Galaxy S6", "pattern": "SM-G920" },
          { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
          { "label": "Galaxy S7", "pattern": "SM-G930" },
          { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
          "Google TV",
          "Lumia",
          "iPad",
          "iPod",
          "iPhone",
          "Kindle",
          { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
          "Nexus",
          "Nook",
          "PlayBook",
          "PlayStation Vita",
          "PlayStation",
          "TouchPad",
          "Transformer",
          { "label": "Wii U", "pattern": "WiiU" },
          "Wii",
          "Xbox One",
          { "label": "Xbox 360", "pattern": "Xbox" },
          "Xoom"
        ]);
        var manufacturer = getManufacturer({
          "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
          "Alcatel": {},
          "Archos": {},
          "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
          "Asus": { "Transformer": 1 },
          "Barnes & Noble": { "Nook": 1 },
          "BlackBerry": { "PlayBook": 1 },
          "Google": { "Google TV": 1, "Nexus": 1 },
          "HP": { "TouchPad": 1 },
          "HTC": {},
          "Huawei": {},
          "Lenovo": {},
          "LG": {},
          "Microsoft": { "Xbox": 1, "Xbox One": 1 },
          "Motorola": { "Xoom": 1 },
          "Nintendo": { "Wii U": 1, "Wii": 1 },
          "Nokia": { "Lumia": 1 },
          "Oppo": {},
          "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
          "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
          "Xiaomi": { "Mi": 1, "Redmi": 1 }
        });
        var os2 = getOS([
          "Windows Phone",
          "KaiOS",
          "Android",
          "CentOS",
          { "label": "Chrome OS", "pattern": "CrOS" },
          "Debian",
          { "label": "DragonFly BSD", "pattern": "DragonFly" },
          "Fedora",
          "FreeBSD",
          "Gentoo",
          "Haiku",
          "Kubuntu",
          "Linux Mint",
          "OpenBSD",
          "Red Hat",
          "SuSE",
          "Ubuntu",
          "Xubuntu",
          "Cygwin",
          "Symbian OS",
          "hpwOS",
          "webOS ",
          "webOS",
          "Tablet OS",
          "Tizen",
          "Linux",
          "Mac OS X",
          "Macintosh",
          "Mac",
          "Windows 98;",
          "Windows "
        ]);
        function getLayout(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua2) && (guess.label || guess);
          });
        }
        function getManufacturer(guesses) {
          return reduce(guesses, function(result, value, key) {
            return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua2)) && key;
          });
        }
        function getName(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua2) && (guess.label || guess);
          });
        }
        function getOS(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua2))) {
              result = cleanupOS(result, pattern, guess.label || guess);
            }
            return result;
          });
        }
        function getProduct(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua2) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua2) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua2))) {
              if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                result[0] += " " + result[1];
              }
              guess = guess.label || guess;
              result = format2(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
            }
            return result;
          });
        }
        function getVersion(patterns) {
          return reduce(patterns, function(result, pattern) {
            return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua2) || 0)[1] || null;
          });
        }
        function toStringPlatform() {
          return this.description || "";
        }
        layout && (layout = [layout]);
        if (/\bAndroid\b/.test(os2) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua2))) {
          product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
        }
        if (manufacturer && !product) {
          product = getProduct([manufacturer]);
        } else if (manufacturer && product) {
          product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
        }
        if (data = /\bGoogle TV\b/.exec(product)) {
          product = data[0];
        }
        if (/\bSimulator\b/i.test(ua2)) {
          product = (product ? product + " " : "") + "Simulator";
        }
        if (name == "Opera Mini" && /\bOPiOS\b/.test(ua2)) {
          description.push("running in Turbo/Uncompressed mode");
        }
        if (name == "IE" && /\blike iPhone OS\b/.test(ua2)) {
          data = parse(ua2.replace(/like iPhone OS/, ""));
          manufacturer = data.manufacturer;
          product = data.product;
        } else if (/^iP/.test(product)) {
          name || (name = "Safari");
          os2 = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua2)) ? " " + data[1].replace(/_/g, ".") : "");
        } else if (name == "Konqueror" && /^Linux\b/i.test(os2)) {
          os2 = "Kubuntu";
        } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua2) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os2) && /^Chrome/.test(name) && /\bVersion\//i.test(ua2)) {
          name = "Android Browser";
          os2 = /\bAndroid\b/.test(os2) ? os2 : "Android";
        } else if (name == "Silk") {
          if (!/\bMobi/i.test(ua2)) {
            os2 = "Android";
            description.unshift("desktop mode");
          }
          if (/Accelerated *= *true/i.test(ua2)) {
            description.unshift("accelerated");
          }
        } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua2)) {
          description.push("speed mode");
        } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua2))) {
          description.push("identifying as Firefox " + data[1]);
        } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua2))) {
          os2 || (os2 = "Firefox OS");
          product || (product = data[1]);
        } else if (!name || (data = !/\bMinefield\b/i.test(ua2) && /\b(?:Firefox|Safari)\b/.exec(name))) {
          if (name && !product && /[\/,]|^[^(]+?\)/.test(ua2.slice(ua2.indexOf(data + "/") + 8))) {
            name = null;
          }
          if ((data = product || manufacturer || os2) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os2))) {
            name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os2) ? os2 : data) + " Browser";
          }
        } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua2) || 0)[1])) {
          description.push("Chromium " + data);
        }
        if (!version) {
          version = getVersion([
            "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
            "Version",
            qualify(name),
            "(?:Firefox|Minefield|NetFront)"
          ]);
        }
        if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua2) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua2) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua2) && (os2 == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
          layout = [data];
        }
        if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua2) || 0)[1])) {
          name += " Mobile";
          os2 = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
          description.unshift("desktop mode");
        } else if (/\bWPDesktop\b/i.test(ua2)) {
          name = "IE Mobile";
          os2 = "Windows Phone 8.x";
          description.unshift("desktop mode");
          version || (version = (/\brv:([\d.]+)/.exec(ua2) || 0)[1]);
        } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua2))) {
          if (name) {
            description.push("identifying as " + name + (version ? " " + version : ""));
          }
          name = "IE";
          version = data[1];
        }
        if (useFeatures) {
          if (isHostType(context, "global")) {
            if (java) {
              data = java.lang.System;
              arch = data.getProperty("os.arch");
              os2 = os2 || data.getProperty("os.name") + " " + data.getProperty("os.version");
            }
            if (rhino) {
              try {
                version = context.require("ringo/engine").version.join(".");
                name = "RingoJS";
              } catch (e) {
                if ((data = context.system) && data.global.system == context.system) {
                  name = "Narwhal";
                  os2 || (os2 = data[0].os || null);
                }
              }
              if (!name) {
                name = "Rhino";
              }
            } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
              if (typeof data.versions == "object") {
                if (typeof data.versions.electron == "string") {
                  description.push("Node " + data.versions.node);
                  name = "Electron";
                  version = data.versions.electron;
                } else if (typeof data.versions.nw == "string") {
                  description.push("Chromium " + version, "Node " + data.versions.node);
                  name = "NW.js";
                  version = data.versions.nw;
                }
              }
              if (!name) {
                name = "Node.js";
                arch = data.arch;
                os2 = data.platform;
                version = /[\d.]+/.exec(data.version);
                version = version ? version[0] : null;
              }
            }
          } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
            name = "Adobe AIR";
            os2 = data.flash.system.Capabilities.os;
          } else if (getClassOf(data = context.phantom) == phantomClass) {
            name = "PhantomJS";
            version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
          } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua2))) {
            version = [version, doc.documentMode];
            if ((data = +data[1] + 4) != version[1]) {
              description.push("IE " + version[1] + " mode");
              layout && (layout[1] = "");
              version[1] = data;
            }
            version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
          } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
            description.push("masking as " + name + " " + version);
            name = "IE";
            version = "11.0";
            layout = ["Trident"];
            os2 = "Windows";
          }
          os2 = os2 && format2(os2);
        }
        if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua2 + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua2) && "a")) {
          prerelease = /b/i.test(data) ? "beta" : "alpha";
          version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
        }
        if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os2)) {
          name = "Firefox Mobile";
        } else if (name == "Maxthon" && version) {
          version = version.replace(/\.[\d.]+/, ".x");
        } else if (/\bXbox\b/i.test(product)) {
          if (product == "Xbox 360") {
            os2 = null;
          }
          if (product == "Xbox 360" && /\bIEMobile\b/.test(ua2)) {
            description.unshift("mobile mode");
          }
        } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os2 == "Windows CE" || /Mobi/i.test(ua2))) {
          name += " Mobile";
        } else if (name == "IE" && useFeatures) {
          try {
            if (context.external === null) {
              description.unshift("platform preview");
            }
          } catch (e) {
            description.unshift("embedded");
          }
        } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua2)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua2) || 0)[1] || version)) {
          data = [data, /BB10/.test(ua2)];
          os2 = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
          version = null;
        } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua2) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os2) || name == "IE" && (os2 && !/^Win/.test(os2) && version > 5.5 || /\bWindows XP\b/.test(os2) && version > 8 || version == 8 && !/\bTrident\b/.test(ua2))) && !reOpera.test(data = parse.call(forOwn, ua2.replace(reOpera, "") + ";")) && data.name) {
          data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
          if (reOpera.test(name)) {
            if (/\bIE\b/.test(data) && os2 == "Mac OS") {
              os2 = null;
            }
            data = "identify" + data;
          } else {
            data = "mask" + data;
            if (operaClass) {
              name = format2(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
            } else {
              name = "Opera";
            }
            if (/\bIE\b/.test(data)) {
              os2 = null;
            }
            if (!useFeatures) {
              version = null;
            }
          }
          layout = ["Presto"];
          description.push(data);
        }
        if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua2) || 0)[1]) {
          data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
          if (name == "Safari" && data[1].slice(-1) == "+") {
            name = "WebKit Nightly";
            prerelease = "alpha";
            version = data[1].slice(0, -1);
          } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua2) || 0)[1])) {
            version = null;
          }
          data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua2) || 0)[1];
          if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
            layout = ["Blink"];
          }
          if (!useFeatures || !likeChrome && !data[1]) {
            layout && (layout[1] = "like Safari");
            data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
          } else {
            layout && (layout[1] = "like Chrome");
            data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
          }
          layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
          if (name == "Safari" && (!version || parseInt(version) > 45)) {
            version = data;
          } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua2)) {
            description.unshift("headless");
          }
        }
        if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os2))) {
          name += " ";
          description.unshift("desktop mode");
          if (data == "zvav") {
            name += "Mini";
            version = null;
          } else {
            name += "Mobile";
          }
          os2 = os2.replace(RegExp(" *" + data + "$"), "");
        } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
          description.unshift("desktop mode");
          name = "Chrome Mobile";
          version = null;
          if (/\bOS X\b/.test(os2)) {
            manufacturer = "Apple";
            os2 = "iOS 4.3+";
          } else {
            os2 = null;
          }
        } else if (/\bSRWare Iron\b/.test(name) && !version) {
          version = getVersion("Chrome");
        }
        if (version && version.indexOf(data = /[\d.]+$/.exec(os2)) == 0 && ua2.indexOf("/" + data + "-") > -1) {
          os2 = trim(os2.replace(data, ""));
        }
        if (os2 && os2.indexOf(name) != -1 && !RegExp(name + " OS").test(os2)) {
          os2 = os2.replace(RegExp(" *" + qualify(name) + " *"), "");
        }
        if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os2) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
          (data = layout[layout.length - 1]) && description.push(data);
        }
        if (description.length) {
          description = ["(" + description.join("; ") + ")"];
        }
        if (manufacturer && product && product.indexOf(manufacturer) < 0) {
          description.push("on " + manufacturer);
        }
        if (product) {
          description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
        }
        if (os2) {
          data = / ([\d.+]+)$/.exec(os2);
          isSpecialCasedOS = data && os2.charAt(os2.length - data[0].length - 1) == "/";
          os2 = {
            "architecture": 32,
            "family": data && !isSpecialCasedOS ? os2.replace(data[0], "") : os2,
            "version": data ? data[1] : null,
            "toString": function() {
              var version2 = this.version;
              return this.family + (version2 && !isSpecialCasedOS ? " " + version2 : "") + (this.architecture == 64 ? " 64-bit" : "");
            }
          };
        }
        if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
          if (os2) {
            os2.architecture = 64;
            os2.family = os2.family.replace(RegExp(" *" + data), "");
          }
          if (name && (/\bWOW64\b/i.test(ua2) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua2))) {
            description.unshift("32-bit");
          }
        } else if (os2 && /^OS X/.test(os2.family) && name == "Chrome" && parseFloat(version) >= 39) {
          os2.architecture = 64;
        }
        ua2 || (ua2 = null);
        var platform2 = {};
        platform2.description = ua2;
        platform2.layout = layout && layout[0];
        platform2.manufacturer = manufacturer;
        platform2.name = name;
        platform2.prerelease = prerelease;
        platform2.product = product;
        platform2.ua = ua2;
        platform2.version = name && version;
        platform2.os = os2 || {
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          "architecture": null,
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          "family": null,
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          "version": null,
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          "toString": function() {
            return "null";
          }
        };
        platform2.parse = parse;
        platform2.toString = toStringPlatform;
        if (platform2.version) {
          description.unshift(version);
        }
        if (platform2.name) {
          description.unshift(name);
        }
        if (os2 && name && !(os2 == String(os2).split(" ")[0] && (os2 == name.split(" ")[0] || product))) {
          description.push(product ? "(" + os2 + ")" : "on " + os2);
        }
        if (description.length) {
          platform2.description = description.join(" ");
        }
        return platform2;
      }
      var platform = parse();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root.platform = platform;
        define(function() {
          return platform;
        });
      } else if (freeExports && freeModule) {
        forOwn(platform, function(value, key) {
          freeExports[key] = value;
        });
      } else {
        root.platform = platform;
      }
    }).call(exports);
  }
});

// bug-reporter.ts
function report(msg) {
  if (["ResizeObserver loop completed with undelivered notifications.", "ResizeObserver loop limit exceeded", "Uncaught aborting javascript here"].includes(msg))
    return;
  API.bugReport({
    type: "web-frontend",
    platform: import_platform.default.os?.family,
    platformVersion: import_platform.default.os?.version,
    error: msg instanceof Error ? msg.message : msg,
    errorStack: msg instanceof Error ? msg.stack : msg,
    browser: import_platform.default.name,
    // null safe version of getting the error
    userId: localStorage["access-token"]?.split(".").filter((_5, i4) => i4 <= 1).map((x5) => JSON.parse(atob(x5))).filter((_5, i4) => i4 == 1).map((it) => it.userId).join(),
    browserVersion: import_platform.default.version,
    location: location.toString()
  }).catch(() => {
  });
}
var import_platform;
var init_bug_reporter = __esm({
  "bug-reporter.ts"() {
    init_restSpec();
    import_platform = __toESM(require_platform());
    globalThis.onunhandledrejection = (e) => {
      report(e.reason);
    };
    globalThis.onerror = (e) => {
      report(typeof e == "string" ? e : e.error);
    };
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/outlined.css
var require_outlined = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/outlined.css"(exports, module) {
    module.exports = {};
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/filled.css
var require_filled = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/filled.css"(exports, module) {
    module.exports = {};
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/round.css
var require_round = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/round.css"(exports, module) {
    module.exports = {};
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/sharp.css
var require_sharp = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/sharp.css"(exports, module) {
    module.exports = {};
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/two-tone.css
var require_two_tone = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/material-icons@1.13.12/iconfont/two-tone.css"(exports, module) {
    module.exports = {};
  }
});

// esbuild_serve:http-import:https://esm.sh/v135/@kurkle/color@0.3.2/denonext/color.mjs
function l(n3) {
  return n3 + 0.5 | 0;
}
function m2(n3) {
  return b2(l(n3 * 2.55), 0, 255);
}
function d2(n3) {
  return b2(l(n3 * 255), 0, 255);
}
function o(n3) {
  return b2(l(n3 / 2.55) / 100, 0, 1);
}
function X2(n3) {
  return b2(l(n3 * 100), 0, 100);
}
function V2(n3) {
  var e = n3.length, f4;
  return n3[0] === "#" && (e === 4 || e === 5 ? f4 = { r: 255 & i[n3[1]] * 17, g: 255 & i[n3[2]] * 17, b: 255 & i[n3[3]] * 17, a: e === 5 ? i[n3[4]] * 17 : 255 } : (e === 7 || e === 9) && (f4 = { r: i[n3[1]] << 4 | i[n3[2]], g: i[n3[3]] << 4 | i[n3[4]], b: i[n3[5]] << 4 | i[n3[6]], a: e === 9 ? i[n3[7]] << 4 | i[n3[8]] : 255 })), f4;
}
function W2(n3) {
  var e = U2(n3) ? Z2 : A2;
  return n3 ? "#" + e(n3.r) + e(n3.g) + e(n3.b) + H2(n3.a, e) : void 0;
}
function $2(n3, e, f4) {
  let t = e * Math.min(f4, 1 - f4), r = (a2, s2 = (a2 + n3 / 30) % 12) => f4 - t * Math.max(Math.min(s2 - 3, 9 - s2, 1), -1);
  return [r(0), r(8), r(4)];
}
function L2(n3, e, f4) {
  let t = (r, a2 = (r + n3 / 60) % 6) => f4 - f4 * e * Math.max(Math.min(a2, 4 - a2, 1), 0);
  return [t(5), t(3), t(1)];
}
function j2(n3, e, f4) {
  let t = $2(n3, 1, 0.5), r;
  for (e + f4 > 1 && (r = 1 / (e + f4), e *= r, f4 *= r), r = 0; r < 3; r++)
    t[r] *= 1 - e - f4, t[r] += e;
  return t;
}
function N2(n3, e, f4, t, r) {
  return n3 === r ? (e - f4) / t + (e < f4 ? 6 : 0) : e === r ? (f4 - n3) / t + 2 : (n3 - e) / t + 4;
}
function _2(n3) {
  let f4 = n3.r / 255, t = n3.g / 255, r = n3.b / 255, a2 = Math.max(f4, t, r), s2 = Math.min(f4, t, r), c3 = (a2 + s2) / 2, g4, u3, x5;
  return a2 !== s2 && (x5 = a2 - s2, u3 = c3 > 0.5 ? x5 / (2 - a2 - s2) : x5 / (a2 + s2), g4 = N2(f4, t, r, x5, a2), g4 = g4 * 60 + 0.5), [g4 | 0, u3 || 0, c3];
}
function M2(n3, e, f4, t) {
  return (Array.isArray(e) ? n3(e[0], e[1], e[2]) : n3(e, f4, t)).map(d2);
}
function S2(n3, e, f4) {
  return M2($2, n3, e, f4);
}
function K2(n3, e, f4) {
  return M2(j2, n3, e, f4);
}
function B2(n3, e, f4) {
  return M2(L2, n3, e, f4);
}
function P2(n3) {
  return (n3 % 360 + 360) % 360;
}
function Q2(n3) {
  let e = q2.exec(n3), f4 = 255, t;
  if (!e)
    return;
  e[5] !== t && (f4 = e[6] ? m2(+e[5]) : d2(+e[5]));
  let r = P2(+e[2]), a2 = +e[3] / 100, s2 = +e[4] / 100;
  return e[1] === "hwb" ? t = K2(r, a2, s2) : e[1] === "hsv" ? t = B2(r, a2, s2) : t = S2(r, a2, s2), { r: t[0], g: t[1], b: t[2], a: f4 };
}
function C2(n3, e) {
  var f4 = _2(n3);
  f4[0] = P2(f4[0] + e), f4 = S2(f4), n3.r = f4[0], n3.g = f4[1], n3.b = f4[2];
}
function D2(n3) {
  if (!n3)
    return;
  let e = _2(n3), f4 = e[0], t = X2(e[1]), r = X2(e[2]);
  return n3.a < 255 ? `hsla(${f4}, ${t}%, ${r}%, ${o(n3.a)})` : `hsl(${f4}, ${t}%, ${r}%)`;
}
function v2() {
  let n3 = {}, e = Object.keys(E), f4 = Object.keys(O2), t, r, a2, s2, c3;
  for (t = 0; t < e.length; t++) {
    for (s2 = c3 = e[t], r = 0; r < f4.length; r++)
      a2 = f4[r], c3 = c3.replace(a2, O2[a2]);
    a2 = parseInt(E[s2], 16), n3[c3] = [a2 >> 16 & 255, a2 >> 8 & 255, a2 & 255];
  }
  return n3;
}
function G2(n3) {
  F2 || (F2 = v2(), F2.transparent = [0, 0, 0, 0]);
  let e = F2[n3.toLowerCase()];
  return e && { r: e[0], g: e[1], b: e[2], a: e.length === 4 ? e[3] : 255 };
}
function J2(n3) {
  let e = I2.exec(n3), f4 = 255, t, r, a2;
  if (e) {
    if (e[7] !== t) {
      let s2 = +e[7];
      f4 = e[8] ? m2(s2) : b2(s2 * 255, 0, 255);
    }
    return t = +e[1], r = +e[3], a2 = +e[5], t = 255 & (e[2] ? m2(t) : b2(t, 0, 255)), r = 255 & (e[4] ? m2(r) : b2(r, 0, 255)), a2 = 255 & (e[6] ? m2(a2) : b2(a2, 0, 255)), { r: t, g: r, b: a2, a: f4 };
  }
}
function z(n3) {
  return n3 && (n3.a < 255 ? `rgba(${n3.r}, ${n3.g}, ${n3.b}, ${o(n3.a)})` : `rgb(${n3.r}, ${n3.g}, ${n3.b})`);
}
function ee(n3, e, f4) {
  let t = h2(o(n3.r)), r = h2(o(n3.g)), a2 = h2(o(n3.b));
  return { r: d2(Y2(t + f4 * (h2(o(e.r)) - t))), g: d2(Y2(r + f4 * (h2(o(e.g)) - r))), b: d2(Y2(a2 + f4 * (h2(o(e.b)) - a2))), a: n3.a + f4 * (e.a - n3.a) };
}
function p2(n3, e, f4) {
  if (n3) {
    let t = _2(n3);
    t[e] = Math.max(0, Math.min(t[e] + t[e] * f4, e === 0 ? 360 : 1)), t = S2(t), n3.r = t[0], n3.g = t[1], n3.b = t[2];
  }
}
function T2(n3, e) {
  return n3 && Object.assign(e || {}, n3);
}
function R(n3) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(n3) ? n3.length >= 3 && (e = { r: n3[0], g: n3[1], b: n3[2], a: 255 }, n3.length > 3 && (e.a = d2(n3[3]))) : (e = T2(n3, { r: 0, g: 0, b: 0, a: 1 }), e.a = d2(e.a)), e;
}
function ne(n3) {
  return n3.charAt(0) === "r" ? J2(n3) : Q2(n3);
}
var b2, i, w, Z2, A2, y2, U2, H2, q2, O2, E, F2, I2, Y2, h2, k2;
var init_color = __esm({
  "esbuild_serve:http-import:https://esm.sh/v135/@kurkle/color@0.3.2/denonext/color.mjs"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    b2 = (n3, e, f4) => Math.max(Math.min(n3, f4), e);
    i = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
    w = [..."0123456789ABCDEF"];
    Z2 = (n3) => w[n3 & 15];
    A2 = (n3) => w[(n3 & 240) >> 4] + w[n3 & 15];
    y2 = (n3) => (n3 & 240) >> 4 === (n3 & 15);
    U2 = (n3) => y2(n3.r) && y2(n3.g) && y2(n3.b) && y2(n3.a);
    H2 = (n3, e) => n3 < 255 ? e(n3) : "";
    q2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    O2 = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" };
    E = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" };
    I2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    Y2 = (n3) => n3 <= 31308e-7 ? n3 * 12.92 : Math.pow(n3, 1 / 2.4) * 1.055 - 0.055;
    h2 = (n3) => n3 <= 0.04045 ? n3 / 12.92 : Math.pow((n3 + 0.055) / 1.055, 2.4);
    k2 = class n {
      constructor(e) {
        if (e instanceof n)
          return e;
        let f4 = typeof e, t;
        f4 === "object" ? t = R(e) : f4 === "string" && (t = V2(e) || G2(e) || ne(e)), this._rgb = t, this._valid = !!t;
      }
      get valid() {
        return this._valid;
      }
      get rgb() {
        var e = T2(this._rgb);
        return e && (e.a = o(e.a)), e;
      }
      set rgb(e) {
        this._rgb = R(e);
      }
      rgbString() {
        return this._valid ? z(this._rgb) : void 0;
      }
      hexString() {
        return this._valid ? W2(this._rgb) : void 0;
      }
      hslString() {
        return this._valid ? D2(this._rgb) : void 0;
      }
      mix(e, f4) {
        if (e) {
          let t = this.rgb, r = e.rgb, a2, s2 = f4 === a2 ? 0.5 : f4, c3 = 2 * s2 - 1, g4 = t.a - r.a, u3 = ((c3 * g4 === -1 ? c3 : (c3 + g4) / (1 + c3 * g4)) + 1) / 2;
          a2 = 1 - u3, t.r = 255 & u3 * t.r + a2 * r.r + 0.5, t.g = 255 & u3 * t.g + a2 * r.g + 0.5, t.b = 255 & u3 * t.b + a2 * r.b + 0.5, t.a = s2 * t.a + (1 - s2) * r.a, this.rgb = t;
        }
        return this;
      }
      interpolate(e, f4) {
        return e && (this._rgb = ee(this._rgb, e._rgb, f4)), this;
      }
      clone() {
        return new n(this.rgb);
      }
      alpha(e) {
        return this._rgb.a = d2(e), this;
      }
      clearer(e) {
        let f4 = this._rgb;
        return f4.a *= 1 - e, this;
      }
      greyscale() {
        let e = this._rgb, f4 = l(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
        return e.r = e.g = e.b = f4, this;
      }
      opaquer(e) {
        let f4 = this._rgb;
        return f4.a *= 1 + e, this;
      }
      negate() {
        let e = this._rgb;
        return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
      }
      lighten(e) {
        return p2(this._rgb, 2, e), this;
      }
      darken(e) {
        return p2(this._rgb, 2, -e), this;
      }
      saturate(e) {
        return p2(this._rgb, 1, e), this;
      }
      desaturate(e) {
        return p2(this._rgb, 1, -e), this;
      }
      rotate(e) {
        return C2(this._rgb, e), this;
      }
    };
  }
});

// esbuild_serve:http-import:https://esm.sh/v135/chart.js@4.4.2/denonext/auto.js
function rt() {
}
function L3(i4) {
  return i4 === null || typeof i4 > "u";
}
function I3(i4) {
  if (Array.isArray && Array.isArray(i4))
    return true;
  let t = Object.prototype.toString.call(i4);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function O3(i4) {
  return i4 !== null && Object.prototype.toString.call(i4) === "[object Object]";
}
function V3(i4) {
  return (typeof i4 == "number" || i4 instanceof Number) && isFinite(+i4);
}
function J3(i4, t) {
  return V3(i4) ? i4 : t;
}
function P3(i4, t) {
  return typeof i4 > "u" ? t : i4;
}
function E2(i4, t, e) {
  if (i4 && typeof i4.call == "function")
    return i4.apply(e, t);
}
function T3(i4, t, e, s2) {
  let n3, o3, a2;
  if (I3(i4))
    if (o3 = i4.length, s2)
      for (n3 = o3 - 1; n3 >= 0; n3--)
        t.call(e, i4[n3], n3);
    else
      for (n3 = 0; n3 < o3; n3++)
        t.call(e, i4[n3], n3);
  else if (O3(i4))
    for (a2 = Object.keys(i4), o3 = a2.length, n3 = 0; n3 < o3; n3++)
      t.call(e, i4[a2[n3]], a2[n3]);
}
function ie(i4, t) {
  let e, s2, n3, o3;
  if (!i4 || !t || i4.length !== t.length)
    return false;
  for (e = 0, s2 = i4.length; e < s2; ++e)
    if (n3 = i4[e], o3 = t[e], n3.datasetIndex !== o3.datasetIndex || n3.index !== o3.index)
      return false;
  return true;
}
function ke(i4) {
  if (I3(i4))
    return i4.map(ke);
  if (O3(i4)) {
    let t = /* @__PURE__ */ Object.create(null), e = Object.keys(i4), s2 = e.length, n3 = 0;
    for (; n3 < s2; ++n3)
      t[e[n3]] = ke(i4[e[n3]]);
    return t;
  }
  return i4;
}
function Os(i4) {
  return ["__proto__", "prototype", "constructor"].indexOf(i4) === -1;
}
function wo(i4, t, e, s2) {
  if (!Os(i4))
    return;
  let n3 = t[i4], o3 = e[i4];
  O3(n3) && O3(o3) ? Bt(n3, o3, s2) : t[i4] = ke(o3);
}
function Bt(i4, t, e) {
  let s2 = I3(t) ? t : [t], n3 = s2.length;
  if (!O3(i4))
    return i4;
  e = e || {};
  let o3 = e.merger || wo, a2;
  for (let r = 0; r < n3; ++r) {
    if (a2 = s2[r], !O3(a2))
      continue;
    let l4 = Object.keys(a2);
    for (let c3 = 0, h5 = l4.length; c3 < h5; ++c3)
      o3(l4[c3], i4, a2, e);
  }
  return i4;
}
function Wt(i4, t) {
  return Bt(i4, t, { merger: Po });
}
function Po(i4, t, e) {
  if (!Os(i4))
    return;
  let s2 = t[i4], n3 = e[i4];
  O3(s2) && O3(n3) ? Wt(s2, n3) : Object.prototype.hasOwnProperty.call(t, i4) || (t[i4] = ke(n3));
}
function Do(i4) {
  let t = i4.split("."), e = [], s2 = "";
  for (let n3 of t)
    s2 += n3, s2.endsWith("\\") ? s2 = s2.slice(0, -1) + "." : (e.push(s2), s2 = "");
  return e;
}
function Co(i4) {
  let t = Do(i4);
  return (e) => {
    for (let s2 of t) {
      if (s2 === "")
        break;
      e = e && e[s2];
    }
    return e;
  };
}
function gt(i4, t) {
  return (ms[t] || (ms[t] = Co(t)))(i4);
}
function De(i4) {
  return i4.charAt(0).toUpperCase() + i4.slice(1);
}
function As(i4) {
  return i4.type === "mouseup" || i4.type === "click" || i4.type === "contextmenu";
}
function Ht(i4, t, e) {
  return Math.abs(i4 - t) < e;
}
function ri(i4) {
  let t = Math.round(i4);
  i4 = Ht(i4, t, i4 / 1e3) ? t : i4;
  let e = Math.pow(10, Math.floor(ft(i4))), s2 = i4 / e;
  return (s2 <= 1 ? 1 : s2 <= 2 ? 2 : s2 <= 5 ? 5 : 10) * e;
}
function Ls(i4) {
  let t = [], e = Math.sqrt(i4), s2;
  for (s2 = 1; s2 < e; s2++)
    i4 % s2 === 0 && (t.push(s2), t.push(i4 / s2));
  return e === (e | 0) && t.push(e), t.sort((n3, o3) => n3 - o3).pop(), t;
}
function At(i4) {
  return !isNaN(parseFloat(i4)) && isFinite(i4);
}
function Ts(i4, t) {
  let e = Math.round(i4);
  return e - t <= i4 && e + t >= i4;
}
function li(i4, t, e) {
  let s2, n3, o3;
  for (s2 = 0, n3 = i4.length; s2 < n3; s2++)
    o3 = i4[s2][e], isNaN(o3) || (t.min = Math.min(t.min, o3), t.max = Math.max(t.max, o3));
}
function et(i4) {
  return i4 * (z2 / 180);
}
function Ce(i4) {
  return i4 * (180 / z2);
}
function ci(i4) {
  if (!V3(i4))
    return;
  let t = 1, e = 0;
  for (; Math.round(i4 * t) / t !== i4; )
    t *= 10, e++;
  return e;
}
function hi(i4, t) {
  let e = t.x - i4.x, s2 = t.y - i4.y, n3 = Math.sqrt(e * e + s2 * s2), o3 = Math.atan2(s2, e);
  return o3 < -0.5 * z2 && (o3 += F3), { angle: o3, distance: n3 };
}
function we(i4, t) {
  return Math.sqrt(Math.pow(t.x - i4.x, 2) + Math.pow(t.y - i4.y, 2));
}
function Lo(i4, t) {
  return (i4 - t + Oo) % F3 - z2;
}
function G3(i4) {
  return (i4 % F3 + F3) % F3;
}
function jt(i4, t, e, s2) {
  let n3 = G3(i4), o3 = G3(t), a2 = G3(e), r = G3(o3 - n3), l4 = G3(a2 - n3), c3 = G3(n3 - o3), h5 = G3(n3 - a2);
  return n3 === o3 || n3 === a2 || s2 && o3 === a2 || r > l4 && c3 < h5;
}
function $3(i4, t, e) {
  return Math.max(t, Math.min(e, i4));
}
function Rs(i4) {
  return $3(i4, -32768, 32767);
}
function lt(i4, t, e, s2 = 1e-6) {
  return i4 >= Math.min(t, e) - s2 && i4 <= Math.max(t, e) + s2;
}
function Oe(i4, t, e) {
  e = e || ((a2) => i4[a2] < t);
  let s2 = i4.length - 1, n3 = 0, o3;
  for (; s2 - n3 > 1; )
    o3 = n3 + s2 >> 1, e(o3) ? n3 = o3 : s2 = o3;
  return { lo: n3, hi: s2 };
}
function Is(i4, t, e) {
  let s2 = 0, n3 = i4.length;
  for (; s2 < n3 && i4[s2] < t; )
    s2++;
  for (; n3 > s2 && i4[n3 - 1] > e; )
    n3--;
  return s2 > 0 || n3 < i4.length ? i4.slice(s2, n3) : i4;
}
function Fs(i4, t) {
  if (i4._chartjs) {
    i4._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(i4, "_chartjs", { configurable: true, enumerable: false, value: { listeners: [t] } }), zs.forEach((e) => {
    let s2 = "_onData" + De(e), n3 = i4[e];
    Object.defineProperty(i4, e, { configurable: true, enumerable: false, value(...o3) {
      let a2 = n3.apply(this, o3);
      return i4._chartjs.listeners.forEach((r) => {
        typeof r[s2] == "function" && r[s2](...o3);
      }), a2;
    } });
  });
}
function di(i4, t) {
  let e = i4._chartjs;
  if (!e)
    return;
  let s2 = e.listeners, n3 = s2.indexOf(t);
  n3 !== -1 && s2.splice(n3, 1), !(s2.length > 0) && (zs.forEach((o3) => {
    delete i4[o3];
  }), delete i4._chartjs);
}
function ui(i4) {
  let t = new Set(i4);
  return t.size === i4.length ? i4 : Array.from(t);
}
function gi(i4, t) {
  let e = [], s2 = false;
  return function(...n3) {
    e = n3, s2 || (s2 = true, fi.call(window, () => {
      s2 = false, i4.apply(t, e);
    }));
  };
}
function Bs(i4, t) {
  let e;
  return function(...s2) {
    return t ? (clearTimeout(e), e = setTimeout(i4, t, s2)) : i4.apply(this, s2), t;
  };
}
function pi(i4, t, e) {
  let s2 = t.length, n3 = 0, o3 = s2;
  if (i4._sorted) {
    let { iScale: a2, _parsed: r } = i4, l4 = a2.axis, { min: c3, max: h5, minDefined: d5, maxDefined: u3 } = a2.getUserBounds();
    d5 && (n3 = $3(Math.min(ot(r, l4, c3).lo, e ? s2 : ot(t, l4, a2.getPixelForValue(c3)).lo), 0, s2 - 1)), u3 ? o3 = $3(Math.max(ot(r, a2.axis, h5, true).hi + 1, e ? 0 : ot(t, l4, a2.getPixelForValue(h5), true).hi + 1), n3, s2) - n3 : o3 = s2 - n3;
  }
  return { start: n3, count: o3 };
}
function mi(i4) {
  let { xScale: t, yScale: e, _scaleRanges: s2 } = i4, n3 = { xmin: t.min, xmax: t.max, ymin: e.min, ymax: e.max };
  if (!s2)
    return i4._scaleRanges = n3, true;
  let o3 = s2.xmin !== t.min || s2.xmax !== t.max || s2.ymin !== e.min || s2.ymax !== e.max;
  return Object.assign(s2, n3), o3;
}
function bi(i4) {
  if (i4 && typeof i4 == "object") {
    let t = i4.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return false;
}
function _i(i4) {
  return bi(i4) ? i4 : new k2(i4);
}
function ii(i4) {
  return bi(i4) ? i4 : new k2(i4).saturate(0.5).darken(0.1).hexString();
}
function Eo(i4) {
  i4.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), i4.describe("animation", { _fallback: false, _indexable: false, _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn" }), i4.set("animations", { colors: { type: "color", properties: Ro }, numbers: { type: "number", properties: To } }), i4.describe("animations", { _fallback: "animation" }), i4.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: (t) => t | 0 } } } });
}
function Io(i4) {
  i4.set("layout", { autoPadding: true, padding: { top: 0, right: 0, bottom: 0, left: 0 } });
}
function zo(i4, t) {
  t = t || {};
  let e = i4 + JSON.stringify(t), s2 = ys.get(e);
  return s2 || (s2 = new Intl.NumberFormat(i4, t), ys.set(e, s2)), s2;
}
function $t(i4, t, e) {
  return zo(t, e).format(i4);
}
function Fo(i4, t) {
  let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(e) >= 1 && i4 !== Math.floor(i4) && (e = i4 - Math.floor(i4)), e;
}
function Bo(i4) {
  i4.set("scale", { display: true, offset: false, reverse: false, beginAtZero: false, bounds: "ticks", clip: true, grace: 0, grid: { display: true, lineWidth: 1, drawOnChartArea: true, drawTicks: true, tickLength: 8, tickWidth: (t, e) => e.lineWidth, tickColor: (t, e) => e.color, offset: false }, border: { display: true, dash: [], dashOffset: 0, width: 1 }, title: { display: false, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: false, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: true, autoSkip: true, autoSkipPadding: 3, labelOffset: 0, callback: se.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: false, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), i4.route("scale.ticks", "color", "", "color"), i4.route("scale.grid", "color", "", "borderColor"), i4.route("scale.border", "color", "", "borderColor"), i4.route("scale.title", "color", "", "color"), i4.describe("scale", { _fallback: false, _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser", _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash" }), i4.describe("scales", { _fallback: "scale" }), i4.describe("scale.ticks", { _scriptable: (t) => t !== "backdropPadding" && t !== "callback", _indexable: (t) => t !== "backdropPadding" });
}
function te(i4, t) {
  if (!t)
    return i4;
  let e = t.split(".");
  for (let s2 = 0, n3 = e.length; s2 < n3; ++s2) {
    let o3 = e[s2];
    i4 = i4[o3] || (i4[o3] = /* @__PURE__ */ Object.create(null));
  }
  return i4;
}
function si(i4, t, e) {
  return typeof t == "string" ? Bt(te(i4, t), e) : Bt(te(i4, ""), t);
}
function Vo(i4) {
  return !i4 || L3(i4.size) || L3(i4.family) ? null : (i4.style ? i4.style + " " : "") + (i4.weight ? i4.weight + " " : "") + i4.size + "px " + i4.family;
}
function ee2(i4, t, e, s2, n3) {
  let o3 = t[n3];
  return o3 || (o3 = t[n3] = i4.measureText(n3).width, e.push(n3)), o3 > s2 && (s2 = o3), s2;
}
function Ns(i4, t, e, s2) {
  s2 = s2 || {};
  let n3 = s2.data = s2.data || {}, o3 = s2.garbageCollect = s2.garbageCollect || [];
  s2.font !== t && (n3 = s2.data = {}, o3 = s2.garbageCollect = [], s2.font = t), i4.save(), i4.font = t;
  let a2 = 0, r = e.length, l4, c3, h5, d5, u3;
  for (l4 = 0; l4 < r; l4++)
    if (d5 = e[l4], d5 != null && !I3(d5))
      a2 = ee2(i4, n3, o3, a2, d5);
    else if (I3(d5))
      for (c3 = 0, h5 = d5.length; c3 < h5; c3++)
        u3 = d5[c3], u3 != null && !I3(u3) && (a2 = ee2(i4, n3, o3, a2, u3));
  i4.restore();
  let f4 = o3.length / 2;
  if (f4 > e.length) {
    for (l4 = 0; l4 < f4; l4++)
      delete n3[o3[l4]];
    o3.splice(0, f4);
  }
  return a2;
}
function yt(i4, t, e) {
  let s2 = i4.currentDevicePixelRatio, n3 = e !== 0 ? Math.max(e / 2, 0.5) : 0;
  return Math.round((t - n3) * s2) / s2 + n3;
}
function xi(i4, t) {
  t = t || i4.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, i4.width, i4.height), t.restore();
}
function Te(i4, t, e, s2) {
  yi(i4, t, e, s2, null);
}
function yi(i4, t, e, s2, n3) {
  let o3, a2, r, l4, c3, h5, d5, u3, f4 = t.pointStyle, g4 = t.rotation, p6 = t.radius, m6 = (g4 || 0) * Ao;
  if (f4 && typeof f4 == "object" && (o3 = f4.toString(), o3 === "[object HTMLImageElement]" || o3 === "[object HTMLCanvasElement]")) {
    i4.save(), i4.translate(e, s2), i4.rotate(m6), i4.drawImage(f4, -f4.width / 2, -f4.height / 2, f4.width, f4.height), i4.restore();
    return;
  }
  if (!(isNaN(p6) || p6 <= 0)) {
    switch (i4.beginPath(), f4) {
      default:
        n3 ? i4.ellipse(e, s2, n3 / 2, p6, 0, 0, F3) : i4.arc(e, s2, p6, 0, F3), i4.closePath();
        break;
      case "triangle":
        h5 = n3 ? n3 / 2 : p6, i4.moveTo(e + Math.sin(m6) * h5, s2 - Math.cos(m6) * p6), m6 += bs, i4.lineTo(e + Math.sin(m6) * h5, s2 - Math.cos(m6) * p6), m6 += bs, i4.lineTo(e + Math.sin(m6) * h5, s2 - Math.cos(m6) * p6), i4.closePath();
        break;
      case "rectRounded":
        c3 = p6 * 0.516, l4 = p6 - c3, a2 = Math.cos(m6 + Dt) * l4, d5 = Math.cos(m6 + Dt) * (n3 ? n3 / 2 - c3 : l4), r = Math.sin(m6 + Dt) * l4, u3 = Math.sin(m6 + Dt) * (n3 ? n3 / 2 - c3 : l4), i4.arc(e - d5, s2 - r, c3, m6 - z2, m6 - N3), i4.arc(e + u3, s2 - a2, c3, m6 - N3, m6), i4.arc(e + d5, s2 + r, c3, m6, m6 + N3), i4.arc(e - u3, s2 + a2, c3, m6 + N3, m6 + z2), i4.closePath();
        break;
      case "rect":
        if (!g4) {
          l4 = Math.SQRT1_2 * p6, h5 = n3 ? n3 / 2 : l4, i4.rect(e - h5, s2 - l4, 2 * h5, 2 * l4);
          break;
        }
        m6 += Dt;
      case "rectRot":
        d5 = Math.cos(m6) * (n3 ? n3 / 2 : p6), a2 = Math.cos(m6) * p6, r = Math.sin(m6) * p6, u3 = Math.sin(m6) * (n3 ? n3 / 2 : p6), i4.moveTo(e - d5, s2 - r), i4.lineTo(e + u3, s2 - a2), i4.lineTo(e + d5, s2 + r), i4.lineTo(e - u3, s2 + a2), i4.closePath();
        break;
      case "crossRot":
        m6 += Dt;
      case "cross":
        d5 = Math.cos(m6) * (n3 ? n3 / 2 : p6), a2 = Math.cos(m6) * p6, r = Math.sin(m6) * p6, u3 = Math.sin(m6) * (n3 ? n3 / 2 : p6), i4.moveTo(e - d5, s2 - r), i4.lineTo(e + d5, s2 + r), i4.moveTo(e + u3, s2 - a2), i4.lineTo(e - u3, s2 + a2);
        break;
      case "star":
        d5 = Math.cos(m6) * (n3 ? n3 / 2 : p6), a2 = Math.cos(m6) * p6, r = Math.sin(m6) * p6, u3 = Math.sin(m6) * (n3 ? n3 / 2 : p6), i4.moveTo(e - d5, s2 - r), i4.lineTo(e + d5, s2 + r), i4.moveTo(e + u3, s2 - a2), i4.lineTo(e - u3, s2 + a2), m6 += Dt, d5 = Math.cos(m6) * (n3 ? n3 / 2 : p6), a2 = Math.cos(m6) * p6, r = Math.sin(m6) * p6, u3 = Math.sin(m6) * (n3 ? n3 / 2 : p6), i4.moveTo(e - d5, s2 - r), i4.lineTo(e + d5, s2 + r), i4.moveTo(e + u3, s2 - a2), i4.lineTo(e - u3, s2 + a2);
        break;
      case "line":
        a2 = n3 ? n3 / 2 : Math.cos(m6) * p6, r = Math.sin(m6) * p6, i4.moveTo(e - a2, s2 - r), i4.lineTo(e + a2, s2 + r);
        break;
      case "dash":
        i4.moveTo(e, s2), i4.lineTo(e + Math.cos(m6) * (n3 ? n3 / 2 : p6), s2 + Math.sin(m6) * p6);
        break;
      case false:
        i4.closePath();
        break;
    }
    i4.fill(), t.borderWidth > 0 && i4.stroke();
  }
}
function at(i4, t, e) {
  return e = e || 0.5, !t || i4 && i4.x > t.left - e && i4.x < t.right + e && i4.y > t.top - e && i4.y < t.bottom + e;
}
function ne2(i4, t) {
  i4.save(), i4.beginPath(), i4.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i4.clip();
}
function oe(i4) {
  i4.restore();
}
function Hs(i4, t, e, s2, n3) {
  if (!t)
    return i4.lineTo(e.x, e.y);
  if (n3 === "middle") {
    let o3 = (t.x + e.x) / 2;
    i4.lineTo(o3, t.y), i4.lineTo(o3, e.y);
  } else
    n3 === "after" != !!s2 ? i4.lineTo(t.x, e.y) : i4.lineTo(e.x, t.y);
  i4.lineTo(e.x, e.y);
}
function js(i4, t, e, s2) {
  if (!t)
    return i4.lineTo(e.x, e.y);
  i4.bezierCurveTo(s2 ? t.cp1x : t.cp2x, s2 ? t.cp1y : t.cp2y, s2 ? e.cp2x : e.cp1x, s2 ? e.cp2y : e.cp1y, e.x, e.y);
}
function Wo(i4, t) {
  t.translation && i4.translate(t.translation[0], t.translation[1]), L3(t.rotation) || i4.rotate(t.rotation), t.color && (i4.fillStyle = t.color), t.textAlign && (i4.textAlign = t.textAlign), t.textBaseline && (i4.textBaseline = t.textBaseline);
}
function No(i4, t, e, s2, n3) {
  if (n3.strikethrough || n3.underline) {
    let o3 = i4.measureText(s2), a2 = t - o3.actualBoundingBoxLeft, r = t + o3.actualBoundingBoxRight, l4 = e - o3.actualBoundingBoxAscent, c3 = e + o3.actualBoundingBoxDescent, h5 = n3.strikethrough ? (l4 + c3) / 2 : c3;
    i4.strokeStyle = i4.fillStyle, i4.beginPath(), i4.lineWidth = n3.decorationWidth || 2, i4.moveTo(a2, h5), i4.lineTo(r, h5), i4.stroke();
  }
}
function Ho(i4, t) {
  let e = i4.fillStyle;
  i4.fillStyle = t.color, i4.fillRect(t.left, t.top, t.width, t.height), i4.fillStyle = e;
}
function vt(i4, t, e, s2, n3, o3 = {}) {
  let a2 = I3(t) ? t : [t], r = o3.strokeWidth > 0 && o3.strokeColor !== "", l4, c3;
  for (i4.save(), i4.font = n3.string, Wo(i4, o3), l4 = 0; l4 < a2.length; ++l4)
    c3 = a2[l4], o3.backdrop && Ho(i4, o3.backdrop), r && (o3.strokeColor && (i4.strokeStyle = o3.strokeColor), L3(o3.strokeWidth) || (i4.lineWidth = o3.strokeWidth), i4.strokeText(c3, e, s2, o3.maxWidth)), i4.fillText(c3, e, s2, o3.maxWidth), No(i4, e, s2, c3, o3), s2 += Number(n3.lineHeight);
  i4.restore();
}
function Ut(i4, t) {
  let { x: e, y: s2, w: n3, h: o3, radius: a2 } = t;
  i4.arc(e + a2.topLeft, s2 + a2.topLeft, a2.topLeft, 1.5 * z2, z2, true), i4.lineTo(e, s2 + o3 - a2.bottomLeft), i4.arc(e + a2.bottomLeft, s2 + o3 - a2.bottomLeft, a2.bottomLeft, z2, N3, true), i4.lineTo(e + n3 - a2.bottomRight, s2 + o3), i4.arc(e + n3 - a2.bottomRight, s2 + o3 - a2.bottomRight, a2.bottomRight, N3, 0, true), i4.lineTo(e + n3, s2 + a2.topRight), i4.arc(e + n3 - a2.topRight, s2 + a2.topRight, a2.topRight, 0, -N3, true), i4.lineTo(e + a2.topLeft, s2);
}
function Uo(i4, t) {
  let e = ("" + i4).match(jo);
  if (!e || e[1] === "normal")
    return t * 1.2;
  switch (i4 = +e[2], e[3]) {
    case "px":
      return i4;
    case "%":
      i4 /= 100;
      break;
  }
  return t * i4;
}
function Re(i4, t) {
  let e = {}, s2 = O3(t), n3 = s2 ? Object.keys(t) : t, o3 = O3(i4) ? s2 ? (a2) => P3(i4[a2], i4[t[a2]]) : (a2) => i4[a2] : () => i4;
  for (let a2 of n3)
    e[a2] = Yo(o3(a2));
  return e;
}
function vi(i4) {
  return Re(i4, { top: "y", right: "x", bottom: "y", left: "x" });
}
function Mt(i4) {
  return Re(i4, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function X3(i4) {
  let t = vi(i4);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function j3(i4, t) {
  i4 = i4 || {}, t = t || W3.font;
  let e = P3(i4.size, t.size);
  typeof e == "string" && (e = parseInt(e, 10));
  let s2 = P3(i4.style, t.style);
  s2 && !("" + s2).match($o) && (console.warn('Invalid font style specified: "' + s2 + '"'), s2 = void 0);
  let n3 = { family: P3(i4.family, t.family), lineHeight: Uo(P3(i4.lineHeight, t.lineHeight), e), size: e, style: s2, weight: P3(i4.weight, t.weight), string: "" };
  return n3.string = Vo(n3), n3;
}
function Yt(i4, t, e, s2) {
  let n3 = true, o3, a2, r;
  for (o3 = 0, a2 = i4.length; o3 < a2; ++o3)
    if (r = i4[o3], r !== void 0 && (t !== void 0 && typeof r == "function" && (r = r(t), n3 = false), e !== void 0 && I3(r) && (r = r[e % r.length], n3 = false), r !== void 0))
      return s2 && !n3 && (s2.cacheable = false), r;
}
function $s(i4, t, e) {
  let { min: s2, max: n3 } = i4, o3 = oi(t, (n3 - s2) / 2), a2 = (r, l4) => e && r === 0 ? 0 : r + l4;
  return { min: a2(s2, -Math.abs(o3)), max: a2(n3, o3) };
}
function pt(i4, t) {
  return Object.assign(Object.create(i4), t);
}
function Ee(i4, t = [""], e, s2, n3 = () => i4[0]) {
  let o3 = e || i4;
  typeof s2 > "u" && (s2 = Xs("_fallback", i4));
  let a2 = { [Symbol.toStringTag]: "Object", _cacheable: true, _scopes: i4, _rootScopes: o3, _fallback: s2, _getTarget: n3, override: (r) => Ee([r, ...i4], t, o3, s2) };
  return new Proxy(a2, { deleteProperty(r, l4) {
    return delete r[l4], delete r._keys, delete i4[0][l4], true;
  }, get(r, l4) {
    return Us(r, l4, () => ta(l4, t, i4, r));
  }, getOwnPropertyDescriptor(r, l4) {
    return Reflect.getOwnPropertyDescriptor(r._scopes[0], l4);
  }, getPrototypeOf() {
    return Reflect.getPrototypeOf(i4[0]);
  }, has(r, l4) {
    return Ms(r).includes(l4);
  }, ownKeys(r) {
    return Ms(r);
  }, set(r, l4, c3) {
    let h5 = r._storage || (r._storage = n3());
    return r[l4] = h5[l4] = c3, delete r._keys, true;
  } });
}
function Ot(i4, t, e, s2) {
  let n3 = { _cacheable: false, _proxy: i4, _context: t, _subProxy: e, _stack: /* @__PURE__ */ new Set(), _descriptors: Mi(i4, s2), setContext: (o3) => Ot(i4, o3, e, s2), override: (o3) => Ot(i4.override(o3), t, e, s2) };
  return new Proxy(n3, { deleteProperty(o3, a2) {
    return delete o3[a2], delete i4[a2], true;
  }, get(o3, a2, r) {
    return Us(o3, a2, () => Ko(o3, a2, r));
  }, getOwnPropertyDescriptor(o3, a2) {
    return o3._descriptors.allKeys ? Reflect.has(i4, a2) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(i4, a2);
  }, getPrototypeOf() {
    return Reflect.getPrototypeOf(i4);
  }, has(o3, a2) {
    return Reflect.has(i4, a2);
  }, ownKeys() {
    return Reflect.ownKeys(i4);
  }, set(o3, a2, r) {
    return i4[a2] = r, delete o3[a2], true;
  } });
}
function Mi(i4, t = { scriptable: true, indexable: true }) {
  let { _scriptable: e = t.scriptable, _indexable: s2 = t.indexable, _allKeys: n3 = t.allKeys } = i4;
  return { allKeys: n3, scriptable: e, indexable: s2, isScriptable: ut(e) ? e : () => e, isIndexable: ut(s2) ? s2 : () => s2 };
}
function Us(i4, t, e) {
  if (Object.prototype.hasOwnProperty.call(i4, t))
    return i4[t];
  let s2 = e();
  return i4[t] = s2, s2;
}
function Ko(i4, t, e) {
  let { _proxy: s2, _context: n3, _subProxy: o3, _descriptors: a2 } = i4, r = s2[t];
  return ut(r) && a2.isScriptable(t) && (r = qo(t, r, i4, e)), I3(r) && r.length && (r = Go(t, r, i4, a2.isIndexable)), ki(t, r) && (r = Ot(r, n3, o3 && o3[t], a2)), r;
}
function qo(i4, t, e, s2) {
  let { _proxy: n3, _context: o3, _subProxy: a2, _stack: r } = e;
  if (r.has(i4))
    throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + i4);
  r.add(i4);
  let l4 = t(o3, a2 || s2);
  return r.delete(i4), ki(i4, l4) && (l4 = Si(n3._scopes, n3, i4, l4)), l4;
}
function Go(i4, t, e, s2) {
  let { _proxy: n3, _context: o3, _subProxy: a2, _descriptors: r } = e;
  if (typeof o3.index < "u" && s2(i4))
    return t[o3.index % t.length];
  if (O3(t[0])) {
    let l4 = t, c3 = n3._scopes.filter((h5) => h5 !== l4);
    t = [];
    for (let h5 of l4) {
      let d5 = Si(c3, n3, i4, h5);
      t.push(Ot(d5, o3, a2 && a2[i4], r));
    }
  }
  return t;
}
function Ys(i4, t, e) {
  return ut(i4) ? i4(t, e) : i4;
}
function Qo(i4, t, e, s2, n3) {
  for (let o3 of t) {
    let a2 = Jo(e, o3);
    if (a2) {
      i4.add(a2);
      let r = Ys(a2._fallback, e, n3);
      if (typeof r < "u" && r !== e && r !== s2)
        return r;
    } else if (a2 === false && typeof s2 < "u" && e !== s2)
      return null;
  }
  return false;
}
function Si(i4, t, e, s2) {
  let n3 = t._rootScopes, o3 = Ys(t._fallback, e, s2), a2 = [...i4, ...n3], r = /* @__PURE__ */ new Set();
  r.add(s2);
  let l4 = vs(r, a2, e, o3 || e, s2);
  return l4 === null || typeof o3 < "u" && o3 !== e && (l4 = vs(r, a2, o3, l4, s2), l4 === null) ? false : Ee(Array.from(r), [""], n3, o3, () => Zo(t, e, s2));
}
function vs(i4, t, e, s2, n3) {
  for (; e; )
    e = Qo(i4, t, e, s2, n3);
  return e;
}
function Zo(i4, t, e) {
  let s2 = i4._getTarget();
  t in s2 || (s2[t] = {});
  let n3 = s2[t];
  return I3(n3) && O3(e) ? e : n3 || {};
}
function ta(i4, t, e, s2) {
  let n3;
  for (let o3 of t)
    if (n3 = Xs(Xo(o3, i4), e), typeof n3 < "u")
      return ki(i4, n3) ? Si(e, s2, i4, n3) : n3;
}
function Xs(i4, t) {
  for (let e of t) {
    if (!e)
      continue;
    let s2 = e[i4];
    if (typeof s2 < "u")
      return s2;
  }
}
function Ms(i4) {
  let t = i4._keys;
  return t || (t = i4._keys = ea(i4._scopes)), t;
}
function ea(i4) {
  let t = /* @__PURE__ */ new Set();
  for (let e of i4)
    for (let s2 of Object.keys(e).filter((n3) => !n3.startsWith("_")))
      t.add(s2);
  return Array.from(t);
}
function wi(i4, t, e, s2) {
  let { iScale: n3 } = i4, { key: o3 = "r" } = this._parsing, a2 = new Array(s2), r, l4, c3, h5;
  for (r = 0, l4 = s2; r < l4; ++r)
    c3 = r + e, h5 = t[c3], a2[r] = { r: n3.parse(gt(h5, o3), c3) };
  return a2;
}
function sa(i4, t, e, s2) {
  let n3 = i4.skip ? t : i4, o3 = t, a2 = e.skip ? t : e, r = we(o3, n3), l4 = we(a2, o3), c3 = r / (r + l4), h5 = l4 / (r + l4);
  c3 = isNaN(c3) ? 0 : c3, h5 = isNaN(h5) ? 0 : h5;
  let d5 = s2 * c3, u3 = s2 * h5;
  return { previous: { x: o3.x - d5 * (a2.x - n3.x), y: o3.y - d5 * (a2.y - n3.y) }, next: { x: o3.x + u3 * (a2.x - n3.x), y: o3.y + u3 * (a2.y - n3.y) } };
}
function na(i4, t, e) {
  let s2 = i4.length, n3, o3, a2, r, l4, c3 = Vt(i4, 0);
  for (let h5 = 0; h5 < s2 - 1; ++h5)
    if (l4 = c3, c3 = Vt(i4, h5 + 1), !(!l4 || !c3)) {
      if (Ht(t[h5], 0, ia)) {
        e[h5] = e[h5 + 1] = 0;
        continue;
      }
      n3 = e[h5] / t[h5], o3 = e[h5 + 1] / t[h5], r = Math.pow(n3, 2) + Math.pow(o3, 2), !(r <= 9) && (a2 = 3 / Math.sqrt(r), e[h5] = n3 * a2 * t[h5], e[h5 + 1] = o3 * a2 * t[h5]);
    }
}
function oa(i4, t, e = "x") {
  let s2 = Ks(e), n3 = i4.length, o3, a2, r, l4 = Vt(i4, 0);
  for (let c3 = 0; c3 < n3; ++c3) {
    if (a2 = r, r = l4, l4 = Vt(i4, c3 + 1), !r)
      continue;
    let h5 = r[e], d5 = r[s2];
    a2 && (o3 = (h5 - a2[e]) / 3, r[`cp1${e}`] = h5 - o3, r[`cp1${s2}`] = d5 - o3 * t[c3]), l4 && (o3 = (l4[e] - h5) / 3, r[`cp2${e}`] = h5 + o3, r[`cp2${s2}`] = d5 + o3 * t[c3]);
  }
}
function aa(i4, t = "x") {
  let e = Ks(t), s2 = i4.length, n3 = Array(s2).fill(0), o3 = Array(s2), a2, r, l4, c3 = Vt(i4, 0);
  for (a2 = 0; a2 < s2; ++a2)
    if (r = l4, l4 = c3, c3 = Vt(i4, a2 + 1), !!l4) {
      if (c3) {
        let h5 = c3[t] - l4[t];
        n3[a2] = h5 !== 0 ? (c3[e] - l4[e]) / h5 : 0;
      }
      o3[a2] = r ? c3 ? st(n3[a2 - 1]) !== st(n3[a2]) ? 0 : (n3[a2 - 1] + n3[a2]) / 2 : n3[a2 - 1] : n3[a2];
    }
  na(i4, n3, o3), oa(i4, o3, t);
}
function ve(i4, t, e) {
  return Math.max(Math.min(i4, e), t);
}
function ra(i4, t) {
  let e, s2, n3, o3, a2, r = at(i4[0], t);
  for (e = 0, s2 = i4.length; e < s2; ++e)
    a2 = o3, o3 = r, r = e < s2 - 1 && at(i4[e + 1], t), o3 && (n3 = i4[e], a2 && (n3.cp1x = ve(n3.cp1x, t.left, t.right), n3.cp1y = ve(n3.cp1y, t.top, t.bottom)), r && (n3.cp2x = ve(n3.cp2x, t.left, t.right), n3.cp2y = ve(n3.cp2y, t.top, t.bottom)));
}
function qs(i4, t, e, s2, n3) {
  let o3, a2, r, l4;
  if (t.spanGaps && (i4 = i4.filter((c3) => !c3.skip)), t.cubicInterpolationMode === "monotone")
    aa(i4, n3);
  else {
    let c3 = s2 ? i4[i4.length - 1] : i4[0];
    for (o3 = 0, a2 = i4.length; o3 < a2; ++o3)
      r = i4[o3], l4 = sa(c3, r, i4[Math.min(o3 + 1, a2 - (s2 ? 0 : 1)) % a2], t.tension), r.cp1x = l4.previous.x, r.cp1y = l4.previous.y, r.cp2x = l4.next.x, r.cp2y = l4.next.y, c3 = r;
  }
  t.capBezierPoints && ra(i4, e);
}
function Ie() {
  return typeof window < "u" && typeof document < "u";
}
function ze(i4) {
  let t = i4.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function Pe(i4, t, e) {
  let s2;
  return typeof i4 == "string" ? (s2 = parseInt(i4, 10), i4.indexOf("%") !== -1 && (s2 = s2 / 100 * t.parentNode[e])) : s2 = i4, s2;
}
function la(i4, t) {
  return Fe(i4).getPropertyValue(t);
}
function Ct(i4, t, e) {
  let s2 = {};
  e = e ? "-" + e : "";
  for (let n3 = 0; n3 < 4; n3++) {
    let o3 = ca[n3];
    s2[o3] = parseFloat(i4[t + "-" + o3 + e]) || 0;
  }
  return s2.width = s2.left + s2.right, s2.height = s2.top + s2.bottom, s2;
}
function da(i4, t) {
  let e = i4.touches, s2 = e && e.length ? e[0] : i4, { offsetX: n3, offsetY: o3 } = s2, a2 = false, r, l4;
  if (ha(n3, o3, i4.target))
    r = n3, l4 = o3;
  else {
    let c3 = t.getBoundingClientRect();
    r = s2.clientX - c3.left, l4 = s2.clientY - c3.top, a2 = true;
  }
  return { x: r, y: l4, box: a2 };
}
function kt(i4, t) {
  if ("native" in i4)
    return i4;
  let { canvas: e, currentDevicePixelRatio: s2 } = t, n3 = Fe(e), o3 = n3.boxSizing === "border-box", a2 = Ct(n3, "padding"), r = Ct(n3, "border", "width"), { x: l4, y: c3, box: h5 } = da(i4, e), d5 = a2.left + (h5 && r.left), u3 = a2.top + (h5 && r.top), { width: f4, height: g4 } = t;
  return o3 && (f4 -= a2.width + r.width, g4 -= a2.height + r.height), { x: Math.round((l4 - d5) / f4 * e.width / s2), y: Math.round((c3 - u3) / g4 * e.height / s2) };
}
function ua(i4, t, e) {
  let s2, n3;
  if (t === void 0 || e === void 0) {
    let o3 = ze(i4);
    if (!o3)
      t = i4.clientWidth, e = i4.clientHeight;
    else {
      let a2 = o3.getBoundingClientRect(), r = Fe(o3), l4 = Ct(r, "border", "width"), c3 = Ct(r, "padding");
      t = a2.width - c3.width - l4.width, e = a2.height - c3.height - l4.height, s2 = Pe(r.maxWidth, o3, "clientWidth"), n3 = Pe(r.maxHeight, o3, "clientHeight");
    }
  }
  return { width: t, height: e, maxWidth: s2 || Se, maxHeight: n3 || Se };
}
function Gs(i4, t, e, s2) {
  let n3 = Fe(i4), o3 = Ct(n3, "margin"), a2 = Pe(n3.maxWidth, i4, "clientWidth") || Se, r = Pe(n3.maxHeight, i4, "clientHeight") || Se, l4 = ua(i4, t, e), { width: c3, height: h5 } = l4;
  if (n3.boxSizing === "content-box") {
    let u3 = Ct(n3, "border", "width"), f4 = Ct(n3, "padding");
    c3 -= f4.width + u3.width, h5 -= f4.height + u3.height;
  }
  return c3 = Math.max(0, c3 - o3.width), h5 = Math.max(0, s2 ? c3 / s2 : h5 - o3.height), c3 = Me(Math.min(c3, a2, l4.maxWidth)), h5 = Me(Math.min(h5, r, l4.maxHeight)), c3 && !h5 && (h5 = Me(c3 / 2)), (t !== void 0 || e !== void 0) && s2 && l4.height && h5 > l4.height && (h5 = l4.height, c3 = Me(Math.floor(h5 * s2))), { width: c3, height: h5 };
}
function Pi(i4, t, e) {
  let s2 = t || 1, n3 = Math.floor(i4.height * s2), o3 = Math.floor(i4.width * s2);
  i4.height = Math.floor(i4.height), i4.width = Math.floor(i4.width);
  let a2 = i4.canvas;
  return a2.style && (e || !a2.style.height && !a2.style.width) && (a2.style.height = `${i4.height}px`, a2.style.width = `${i4.width}px`), i4.currentDevicePixelRatio !== s2 || a2.height !== n3 || a2.width !== o3 ? (i4.currentDevicePixelRatio = s2, a2.height = n3, a2.width = o3, i4.ctx.setTransform(s2, 0, 0, s2, 0, 0), true) : false;
}
function Di(i4, t) {
  let e = la(i4, t), s2 = e && e.match(/^(\d+)(\.\d+)?px$/);
  return s2 ? +s2[1] : void 0;
}
function _t(i4, t, e, s2) {
  return { x: i4.x + e * (t.x - i4.x), y: i4.y + e * (t.y - i4.y) };
}
function Qs(i4, t, e, s2) {
  return { x: i4.x + e * (t.x - i4.x), y: s2 === "middle" ? e < 0.5 ? i4.y : t.y : s2 === "after" ? e < 1 ? i4.y : t.y : e > 0 ? t.y : i4.y };
}
function Zs(i4, t, e, s2) {
  let n3 = { x: i4.cp2x, y: i4.cp2y }, o3 = { x: t.cp1x, y: t.cp1y }, a2 = _t(i4, n3, e), r = _t(n3, o3, e), l4 = _t(o3, t, e), c3 = _t(a2, r, e), h5 = _t(r, l4, e);
  return _t(c3, h5, e);
}
function Lt(i4, t, e) {
  return i4 ? fa(t, e) : ga();
}
function Ci(i4, t) {
  let e, s2;
  (t === "ltr" || t === "rtl") && (e = i4.canvas.style, s2 = [e.getPropertyValue("direction"), e.getPropertyPriority("direction")], e.setProperty("direction", t, "important"), i4.prevTextDirection = s2);
}
function Oi(i4, t) {
  t !== void 0 && (delete i4.prevTextDirection, i4.canvas.style.setProperty("direction", t[0], t[1]));
}
function tn(i4) {
  return i4 === "angle" ? { between: jt, compare: Lo, normalize: G3 } : { between: lt, compare: (t, e) => t - e, normalize: (t) => t };
}
function ks({ start: i4, end: t, count: e, loop: s2, style: n3 }) {
  return { start: i4 % e, end: t % e, loop: s2 && (t - i4 + 1) % e === 0, style: n3 };
}
function pa(i4, t, e) {
  let { property: s2, start: n3, end: o3 } = e, { between: a2, normalize: r } = tn(s2), l4 = t.length, { start: c3, end: h5, loop: d5 } = i4, u3, f4;
  if (d5) {
    for (c3 += l4, h5 += l4, u3 = 0, f4 = l4; u3 < f4 && a2(r(t[c3 % l4][s2]), n3, o3); ++u3)
      c3--, h5--;
    c3 %= l4, h5 %= l4;
  }
  return h5 < c3 && (h5 += l4), { start: c3, end: h5, loop: d5, style: i4.style };
}
function Ai(i4, t, e) {
  if (!e)
    return [i4];
  let { property: s2, start: n3, end: o3 } = e, a2 = t.length, { compare: r, between: l4, normalize: c3 } = tn(s2), { start: h5, end: d5, loop: u3, style: f4 } = pa(i4, t, e), g4 = [], p6 = false, m6 = null, b5, _5, v5, y5 = () => l4(n3, v5, b5) && r(n3, v5) !== 0, x5 = () => r(o3, b5) === 0 || l4(o3, v5, b5), M5 = () => p6 || y5(), k4 = () => !p6 || x5();
  for (let S6 = h5, w4 = h5; S6 <= d5; ++S6)
    _5 = t[S6 % a2], !_5.skip && (b5 = c3(_5[s2]), b5 !== v5 && (p6 = l4(b5, n3, o3), m6 === null && M5() && (m6 = r(b5, n3) === 0 ? S6 : w4), m6 !== null && k4() && (g4.push(ks({ start: m6, end: S6, loop: u3, count: a2, style: f4 })), m6 = null), w4 = S6, v5 = b5));
  return m6 !== null && g4.push(ks({ start: m6, end: d5, loop: u3, count: a2, style: f4 })), g4;
}
function Li(i4, t) {
  let e = [], s2 = i4.segments;
  for (let n3 = 0; n3 < s2.length; n3++) {
    let o3 = Ai(s2[n3], i4.points, t);
    o3.length && e.push(...o3);
  }
  return e;
}
function ma(i4, t, e, s2) {
  let n3 = 0, o3 = t - 1;
  if (e && !s2)
    for (; n3 < t && !i4[n3].skip; )
      n3++;
  for (; n3 < t && i4[n3].skip; )
    n3++;
  for (n3 %= t, e && (o3 += n3); o3 > n3 && i4[o3 % t].skip; )
    o3--;
  return o3 %= t, { start: n3, end: o3 };
}
function ba(i4, t, e, s2) {
  let n3 = i4.length, o3 = [], a2 = t, r = i4[t], l4;
  for (l4 = t + 1; l4 <= e; ++l4) {
    let c3 = i4[l4 % n3];
    c3.skip || c3.stop ? r.skip || (s2 = false, o3.push({ start: t % n3, end: (l4 - 1) % n3, loop: s2 }), t = a2 = c3.stop ? l4 : null) : (a2 = l4, r.skip && (t = l4)), r = c3;
  }
  return a2 !== null && o3.push({ start: t % n3, end: a2 % n3, loop: s2 }), o3;
}
function en(i4, t) {
  let e = i4.points, s2 = i4.options.spanGaps, n3 = e.length;
  if (!n3)
    return [];
  let o3 = !!i4._loop, { start: a2, end: r } = ma(e, n3, o3, s2);
  if (s2 === true)
    return Ss(i4, [{ start: a2, end: r, loop: o3 }], e, t);
  let l4 = r < a2 ? r + n3 : r, c3 = !!i4._fullLoop && a2 === 0 && r === n3 - 1;
  return Ss(i4, ba(e, a2, l4, c3), e, t);
}
function Ss(i4, t, e, s2) {
  return !s2 || !s2.setContext || !e ? t : _a(i4, t, e, s2);
}
function _a(i4, t, e, s2) {
  let n3 = i4._chart.getContext(), o3 = ws(i4.options), { _datasetIndex: a2, options: { spanGaps: r } } = i4, l4 = e.length, c3 = [], h5 = o3, d5 = t[0].start, u3 = d5;
  function f4(g4, p6, m6, b5) {
    let _5 = r ? -1 : 1;
    if (g4 !== p6) {
      for (g4 += l4; e[g4 % l4].skip; )
        g4 -= _5;
      for (; e[p6 % l4].skip; )
        p6 += _5;
      g4 % l4 !== p6 % l4 && (c3.push({ start: g4 % l4, end: p6 % l4, loop: m6, style: b5 }), h5 = b5, d5 = p6 % l4);
    }
  }
  for (let g4 of t) {
    d5 = r ? d5 : g4.start;
    let p6 = e[d5 % l4], m6;
    for (u3 = d5 + 1; u3 <= g4.end; u3++) {
      let b5 = e[u3 % l4];
      m6 = ws(s2.setContext(pt(n3, { type: "segment", p0: p6, p1: b5, p0DataIndex: (u3 - 1) % l4, p1DataIndex: u3 % l4, datasetIndex: a2 }))), xa(m6, h5) && f4(d5, u3 - 1, g4.loop, h5), p6 = b5, h5 = m6;
    }
    d5 < u3 - 1 && f4(d5, u3 - 1, g4.loop, h5);
  }
  return c3;
}
function ws(i4) {
  return { backgroundColor: i4.backgroundColor, borderCapStyle: i4.borderCapStyle, borderDash: i4.borderDash, borderDashOffset: i4.borderDashOffset, borderJoinStyle: i4.borderJoinStyle, borderWidth: i4.borderWidth, borderColor: i4.borderColor };
}
function xa(i4, t) {
  if (!t)
    return false;
  let e = [], s2 = function(n3, o3) {
    return bi(o3) ? (e.includes(o3) || e.push(o3), e.indexOf(o3)) : o3;
  };
  return JSON.stringify(i4, s2) !== JSON.stringify(t, s2);
}
function va(i4, t) {
  let e = [], s2 = Object.keys(t);
  for (let n3 = 0; n3 < s2.length; n3++) {
    let o3 = i4[s2[n3]];
    o3 && o3.active() && e.push(o3.wait());
  }
  return Promise.all(e);
}
function Ma(i4, t) {
  if (!t)
    return;
  let e = i4.options;
  if (!e) {
    i4.options = t;
    return;
  }
  return e.$shared && (i4.options = e = Object.assign({}, e, { $shared: false, $animations: {} })), e;
}
function nn(i4, t) {
  let e = i4 && i4.options || {}, s2 = e.reverse, n3 = e.min === void 0 ? t : 0, o3 = e.max === void 0 ? t : 0;
  return { start: s2 ? o3 : n3, end: s2 ? n3 : o3 };
}
function ka(i4, t, e) {
  if (e === false)
    return false;
  let s2 = nn(i4, e), n3 = nn(t, e);
  return { top: n3.end, right: s2.end, bottom: n3.start, left: s2.start };
}
function Sa(i4) {
  let t, e, s2, n3;
  return O3(i4) ? (t = i4.top, e = i4.right, s2 = i4.bottom, n3 = i4.left) : t = e = s2 = n3 = i4, { top: t, right: e, bottom: s2, left: n3, disabled: i4 === false };
}
function so(i4, t) {
  let e = [], s2 = i4._getSortedDatasetMetas(t), n3, o3;
  for (n3 = 0, o3 = s2.length; n3 < o3; ++n3)
    e.push(s2[n3].index);
  return e;
}
function on(i4, t, e, s2 = {}) {
  let n3 = i4.keys, o3 = s2.mode === "single", a2, r, l4, c3;
  if (t !== null) {
    for (a2 = 0, r = n3.length; a2 < r; ++a2) {
      if (l4 = +n3[a2], l4 === e) {
        if (s2.all)
          continue;
        break;
      }
      c3 = i4.values[l4], V3(c3) && (o3 || t === 0 || st(t) === st(c3)) && (t += c3);
    }
    return t;
  }
}
function wa(i4) {
  let t = Object.keys(i4), e = new Array(t.length), s2, n3, o3;
  for (s2 = 0, n3 = t.length; s2 < n3; ++s2)
    o3 = t[s2], e[s2] = { x: o3, y: i4[o3] };
  return e;
}
function an(i4, t) {
  let e = i4 && i4.options.stacked;
  return e || e === void 0 && t.stack !== void 0;
}
function Pa(i4, t, e) {
  return `${i4.id}.${t.id}.${e.stack || e.type}`;
}
function Da(i4) {
  let { min: t, max: e, minDefined: s2, maxDefined: n3 } = i4.getUserBounds();
  return { min: s2 ? t : Number.NEGATIVE_INFINITY, max: n3 ? e : Number.POSITIVE_INFINITY };
}
function Ca(i4, t, e) {
  let s2 = i4[t] || (i4[t] = {});
  return s2[e] || (s2[e] = {});
}
function rn(i4, t, e, s2) {
  for (let n3 of t.getMatchingVisibleMetas(s2).reverse()) {
    let o3 = i4[n3.index];
    if (e && o3 > 0 || !e && o3 < 0)
      return n3.index;
  }
  return null;
}
function ln(i4, t) {
  let { chart: e, _cachedMeta: s2 } = i4, n3 = e._stacks || (e._stacks = {}), { iScale: o3, vScale: a2, index: r } = s2, l4 = o3.axis, c3 = a2.axis, h5 = Pa(o3, a2, s2), d5 = t.length, u3;
  for (let f4 = 0; f4 < d5; ++f4) {
    let g4 = t[f4], { [l4]: p6, [c3]: m6 } = g4, b5 = g4._stacks || (g4._stacks = {});
    u3 = b5[c3] = Ca(n3, h5, p6), u3[r] = m6, u3._top = rn(u3, a2, true, s2.type), u3._bottom = rn(u3, a2, false, s2.type);
    let _5 = u3._visualValues || (u3._visualValues = {});
    _5[r] = m6;
  }
}
function Ti(i4, t) {
  let e = i4.scales;
  return Object.keys(e).filter((s2) => e[s2].axis === t).shift();
}
function Oa(i4, t) {
  return pt(i4, { active: false, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" });
}
function Aa(i4, t, e) {
  return pt(i4, { active: false, dataIndex: t, parsed: void 0, raw: void 0, element: e, index: t, mode: "default", type: "data" });
}
function ae(i4, t) {
  let e = i4.controller.index, s2 = i4.vScale && i4.vScale.axis;
  if (s2) {
    t = t || i4._parsed;
    for (let n3 of t) {
      let o3 = n3._stacks;
      if (!o3 || o3[s2] === void 0 || o3[s2][e] === void 0)
        return;
      delete o3[s2][e], o3[s2]._visualValues !== void 0 && o3[s2]._visualValues[e] !== void 0 && delete o3[s2]._visualValues[e];
    }
  }
}
function Ta(i4, t) {
  if (!i4._cache.$bar) {
    let e = i4.getMatchingVisibleMetas(t), s2 = [];
    for (let n3 = 0, o3 = e.length; n3 < o3; n3++)
      s2 = s2.concat(e[n3].controller.getAllParsedValues(i4));
    i4._cache.$bar = ui(s2.sort((n3, o3) => n3 - o3));
  }
  return i4._cache.$bar;
}
function Ra(i4) {
  let t = i4.iScale, e = Ta(t, i4.type), s2 = t._length, n3, o3, a2, r, l4 = () => {
    a2 === 32767 || a2 === -32768 || (Nt(r) && (s2 = Math.min(s2, Math.abs(a2 - r) || s2)), r = a2);
  };
  for (n3 = 0, o3 = e.length; n3 < o3; ++n3)
    a2 = t.getPixelForValue(e[n3]), l4();
  for (r = void 0, n3 = 0, o3 = t.ticks.length; n3 < o3; ++n3)
    a2 = t.getPixelForTick(n3), l4();
  return s2;
}
function Ea(i4, t, e, s2) {
  let n3 = e.barThickness, o3, a2;
  return L3(n3) ? (o3 = t.min * e.categoryPercentage, a2 = e.barPercentage) : (o3 = n3 * s2, a2 = 1), { chunk: o3 / s2, ratio: a2, start: t.pixels[i4] - o3 / 2 };
}
function Ia(i4, t, e, s2) {
  let n3 = t.pixels, o3 = n3[i4], a2 = i4 > 0 ? n3[i4 - 1] : null, r = i4 < n3.length - 1 ? n3[i4 + 1] : null, l4 = e.categoryPercentage;
  a2 === null && (a2 = o3 - (r === null ? t.end - t.start : r - o3)), r === null && (r = o3 + o3 - a2);
  let c3 = o3 - (o3 - Math.min(a2, r)) / 2 * l4;
  return { chunk: Math.abs(r - a2) / 2 * l4 / s2, ratio: e.barPercentage, start: c3 };
}
function za(i4, t, e, s2) {
  let n3 = e.parse(i4[0], s2), o3 = e.parse(i4[1], s2), a2 = Math.min(n3, o3), r = Math.max(n3, o3), l4 = a2, c3 = r;
  Math.abs(a2) > Math.abs(r) && (l4 = r, c3 = a2), t[e.axis] = c3, t._custom = { barStart: l4, barEnd: c3, start: n3, end: o3, min: a2, max: r };
}
function no(i4, t, e, s2) {
  return I3(i4) ? za(i4, t, e, s2) : t[e.axis] = e.parse(i4, s2), t;
}
function hn(i4, t, e, s2) {
  let n3 = i4.iScale, o3 = i4.vScale, a2 = n3.getLabels(), r = n3 === o3, l4 = [], c3, h5, d5, u3;
  for (c3 = e, h5 = e + s2; c3 < h5; ++c3)
    u3 = t[c3], d5 = {}, d5[n3.axis] = r || n3.parse(a2[c3], c3), l4.push(no(u3, d5, o3, c3));
  return l4;
}
function Ei(i4) {
  return i4 && i4.barStart !== void 0 && i4.barEnd !== void 0;
}
function Fa(i4, t, e) {
  return i4 !== 0 ? st(i4) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);
}
function Ba(i4) {
  let t, e, s2, n3, o3;
  return i4.horizontal ? (t = i4.base > i4.x, e = "left", s2 = "right") : (t = i4.base < i4.y, e = "bottom", s2 = "top"), t ? (n3 = "end", o3 = "start") : (n3 = "start", o3 = "end"), { start: e, end: s2, reverse: t, top: n3, bottom: o3 };
}
function Va(i4, t, e, s2) {
  let n3 = t.borderSkipped, o3 = {};
  if (!n3) {
    i4.borderSkipped = o3;
    return;
  }
  if (n3 === true) {
    i4.borderSkipped = { top: true, right: true, bottom: true, left: true };
    return;
  }
  let { start: a2, end: r, reverse: l4, top: c3, bottom: h5 } = Ba(i4);
  n3 === "middle" && e && (i4.enableBorderRadius = true, (e._top || 0) === s2 ? n3 = c3 : (e._bottom || 0) === s2 ? n3 = h5 : (o3[dn(h5, a2, r, l4)] = true, n3 = c3)), o3[dn(n3, a2, r, l4)] = true, i4.borderSkipped = o3;
}
function dn(i4, t, e, s2) {
  return s2 ? (i4 = Wa(i4, t, e), i4 = un(i4, e, t)) : i4 = un(i4, t, e), i4;
}
function Wa(i4, t, e) {
  return i4 === t ? e : i4 === e ? t : i4;
}
function un(i4, t, e) {
  return i4 === "start" ? t : i4 === "end" ? e : i4;
}
function Na(i4, { inflateAmount: t }, e) {
  i4.inflateAmount = t === "auto" ? e === 1 ? 0.33 : 0 : t;
}
function Ha(i4, t, e) {
  let s2 = 1, n3 = 1, o3 = 0, a2 = 0;
  if (t < F3) {
    let r = i4, l4 = r + t, c3 = Math.cos(r), h5 = Math.sin(r), d5 = Math.cos(l4), u3 = Math.sin(l4), f4 = (v5, y5, x5) => jt(v5, r, l4, true) ? 1 : Math.max(y5, y5 * e, x5, x5 * e), g4 = (v5, y5, x5) => jt(v5, r, l4, true) ? -1 : Math.min(y5, y5 * e, x5, x5 * e), p6 = f4(0, c3, d5), m6 = f4(N3, h5, u3), b5 = g4(z2, c3, d5), _5 = g4(z2 + N3, h5, u3);
    s2 = (p6 - b5) / 2, n3 = (m6 - _5) / 2, o3 = -(p6 + b5) / 2, a2 = -(m6 + _5) / 2;
  }
  return { ratioX: s2, ratioY: n3, offsetX: o3, offsetY: a2 };
}
function Tt() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
function Ua(i4, t, e, s2) {
  let { controller: n3, data: o3, _sorted: a2 } = i4, r = n3._cachedMeta.iScale;
  if (r && t === r.axis && t !== "r" && a2 && o3.length) {
    let l4 = r._reversePixels ? Es : ot;
    if (s2) {
      if (n3._sharedOptions) {
        let c3 = o3[0], h5 = typeof c3.getRange == "function" && c3.getRange(t);
        if (h5) {
          let d5 = l4(o3, t, e - h5), u3 = l4(o3, t, e + h5);
          return { lo: d5.lo, hi: u3.hi };
        }
      }
    } else
      return l4(o3, t, e);
  }
  return { lo: 0, hi: o3.length - 1 };
}
function _e(i4, t, e, s2, n3) {
  let o3 = i4.getSortedVisibleDatasetMetas(), a2 = e[t];
  for (let r = 0, l4 = o3.length; r < l4; ++r) {
    let { index: c3, data: h5 } = o3[r], { lo: d5, hi: u3 } = Ua(o3[r], t, a2, n3);
    for (let f4 = d5; f4 <= u3; ++f4) {
      let g4 = h5[f4];
      g4.skip || s2(g4, c3, f4);
    }
  }
}
function Ya(i4) {
  let t = i4.indexOf("x") !== -1, e = i4.indexOf("y") !== -1;
  return function(s2, n3) {
    let o3 = t ? Math.abs(s2.x - n3.x) : 0, a2 = e ? Math.abs(s2.y - n3.y) : 0;
    return Math.sqrt(Math.pow(o3, 2) + Math.pow(a2, 2));
  };
}
function Ii(i4, t, e, s2, n3) {
  let o3 = [];
  return !n3 && !i4.isPointInArea(t) || _e(i4, e, t, function(r, l4, c3) {
    !n3 && !at(r, i4.chartArea, 0) || r.inRange(t.x, t.y, s2) && o3.push({ element: r, datasetIndex: l4, index: c3 });
  }, true), o3;
}
function Xa(i4, t, e, s2) {
  let n3 = [];
  function o3(a2, r, l4) {
    let { startAngle: c3, endAngle: h5 } = a2.getProps(["startAngle", "endAngle"], s2), { angle: d5 } = hi(a2, { x: t.x, y: t.y });
    jt(d5, c3, h5) && n3.push({ element: a2, datasetIndex: r, index: l4 });
  }
  return _e(i4, e, t, o3), n3;
}
function Ka(i4, t, e, s2, n3, o3) {
  let a2 = [], r = Ya(e), l4 = Number.POSITIVE_INFINITY;
  function c3(h5, d5, u3) {
    let f4 = h5.inRange(t.x, t.y, n3);
    if (s2 && !f4)
      return;
    let g4 = h5.getCenterPoint(n3);
    if (!(!!o3 || i4.isPointInArea(g4)) && !f4)
      return;
    let m6 = r(t, g4);
    m6 < l4 ? (a2 = [{ element: h5, datasetIndex: d5, index: u3 }], l4 = m6) : m6 === l4 && a2.push({ element: h5, datasetIndex: d5, index: u3 });
  }
  return _e(i4, e, t, c3), a2;
}
function zi(i4, t, e, s2, n3, o3) {
  return !o3 && !i4.isPointInArea(t) ? [] : e === "r" && !s2 ? Xa(i4, t, e, n3) : Ka(i4, t, e, s2, n3, o3);
}
function fn(i4, t, e, s2, n3) {
  let o3 = [], a2 = e === "x" ? "inXRange" : "inYRange", r = false;
  return _e(i4, e, t, (l4, c3, h5) => {
    l4[a2](t[e], n3) && (o3.push({ element: l4, datasetIndex: c3, index: h5 }), r = r || l4.inRange(t.x, t.y, n3));
  }), s2 && !r ? [] : o3;
}
function re(i4, t) {
  return i4.filter((e) => e.pos === t);
}
function gn(i4, t) {
  return i4.filter((e) => oo.indexOf(e.pos) === -1 && e.box.axis === t);
}
function le(i4, t) {
  return i4.sort((e, s2) => {
    let n3 = t ? s2 : e, o3 = t ? e : s2;
    return n3.weight === o3.weight ? n3.index - o3.index : n3.weight - o3.weight;
  });
}
function Ga(i4) {
  let t = [], e, s2, n3, o3, a2, r;
  for (e = 0, s2 = (i4 || []).length; e < s2; ++e)
    n3 = i4[e], { position: o3, options: { stack: a2, stackWeight: r = 1 } } = n3, t.push({ index: e, box: n3, pos: o3, horizontal: n3.isHorizontal(), weight: n3.weight, stack: a2 && o3 + a2, stackWeight: r });
  return t;
}
function Ja(i4) {
  let t = {};
  for (let e of i4) {
    let { stack: s2, pos: n3, stackWeight: o3 } = e;
    if (!s2 || !oo.includes(n3))
      continue;
    let a2 = t[s2] || (t[s2] = { count: 0, placed: 0, weight: 0, size: 0 });
    a2.count++, a2.weight += o3;
  }
  return t;
}
function Qa(i4, t) {
  let e = Ja(i4), { vBoxMaxWidth: s2, hBoxMaxHeight: n3 } = t, o3, a2, r;
  for (o3 = 0, a2 = i4.length; o3 < a2; ++o3) {
    r = i4[o3];
    let { fullSize: l4 } = r.box, c3 = e[r.stack], h5 = c3 && r.stackWeight / c3.weight;
    r.horizontal ? (r.width = h5 ? h5 * s2 : l4 && t.availableWidth, r.height = n3) : (r.width = s2, r.height = h5 ? h5 * n3 : l4 && t.availableHeight);
  }
  return e;
}
function Za(i4) {
  let t = Ga(i4), e = le(t.filter((c3) => c3.box.fullSize), true), s2 = le(re(t, "left"), true), n3 = le(re(t, "right")), o3 = le(re(t, "top"), true), a2 = le(re(t, "bottom")), r = gn(t, "x"), l4 = gn(t, "y");
  return { fullSize: e, leftAndTop: s2.concat(o3), rightAndBottom: n3.concat(l4).concat(a2).concat(r), chartArea: re(t, "chartArea"), vertical: s2.concat(n3).concat(l4), horizontal: o3.concat(a2).concat(r) };
}
function pn(i4, t, e, s2) {
  return Math.max(i4[e], t[e]) + Math.max(i4[s2], t[s2]);
}
function ao(i4, t) {
  i4.top = Math.max(i4.top, t.top), i4.left = Math.max(i4.left, t.left), i4.bottom = Math.max(i4.bottom, t.bottom), i4.right = Math.max(i4.right, t.right);
}
function tr(i4, t, e, s2) {
  let { pos: n3, box: o3 } = e, a2 = i4.maxPadding;
  if (!O3(n3)) {
    e.size && (i4[n3] -= e.size);
    let d5 = s2[e.stack] || { size: 0, count: 1 };
    d5.size = Math.max(d5.size, e.horizontal ? o3.height : o3.width), e.size = d5.size / d5.count, i4[n3] += e.size;
  }
  o3.getPadding && ao(a2, o3.getPadding());
  let r = Math.max(0, t.outerWidth - pn(a2, i4, "left", "right")), l4 = Math.max(0, t.outerHeight - pn(a2, i4, "top", "bottom")), c3 = r !== i4.w, h5 = l4 !== i4.h;
  return i4.w = r, i4.h = l4, e.horizontal ? { same: c3, other: h5 } : { same: h5, other: c3 };
}
function er(i4) {
  let t = i4.maxPadding;
  function e(s2) {
    let n3 = Math.max(t[s2] - i4[s2], 0);
    return i4[s2] += n3, n3;
  }
  i4.y += e("top"), i4.x += e("left"), e("right"), e("bottom");
}
function ir(i4, t) {
  let e = t.maxPadding;
  function s2(n3) {
    let o3 = { left: 0, top: 0, right: 0, bottom: 0 };
    return n3.forEach((a2) => {
      o3[a2] = Math.max(t[a2], e[a2]);
    }), o3;
  }
  return s2(i4 ? ["left", "right"] : ["top", "bottom"]);
}
function de(i4, t, e, s2) {
  let n3 = [], o3, a2, r, l4, c3, h5;
  for (o3 = 0, a2 = i4.length, c3 = 0; o3 < a2; ++o3) {
    r = i4[o3], l4 = r.box, l4.update(r.width || t.w, r.height || t.h, ir(r.horizontal, t));
    let { same: d5, other: u3 } = tr(t, e, r, s2);
    c3 |= d5 && n3.length, h5 = h5 || u3, l4.fullSize || n3.push(r);
  }
  return c3 && de(n3, t, e, s2) || h5;
}
function Be(i4, t, e, s2, n3) {
  i4.top = e, i4.left = t, i4.right = t + s2, i4.bottom = e + n3, i4.width = s2, i4.height = n3;
}
function mn(i4, t, e, s2) {
  let n3 = e.padding, { x: o3, y: a2 } = t;
  for (let r of i4) {
    let l4 = r.box, c3 = s2[r.stack] || { count: 1, placed: 0, weight: 1 }, h5 = r.stackWeight / c3.weight || 1;
    if (r.horizontal) {
      let d5 = t.w * h5, u3 = c3.size || l4.height;
      Nt(c3.start) && (a2 = c3.start), l4.fullSize ? Be(l4, n3.left, a2, e.outerWidth - n3.right - n3.left, u3) : Be(l4, t.left + c3.placed, a2, d5, u3), c3.start = a2, c3.placed += d5, a2 = l4.bottom;
    } else {
      let d5 = t.h * h5, u3 = c3.size || l4.width;
      Nt(c3.start) && (o3 = c3.start), l4.fullSize ? Be(l4, o3, n3.top, u3, e.outerHeight - n3.bottom - n3.top) : Be(l4, o3, t.top + c3.placed, u3, d5), c3.start = o3, c3.placed += d5, o3 = l4.right;
    }
  }
  t.x = o3, t.y = a2;
}
function nr(i4, t) {
  let e = i4.style, s2 = i4.getAttribute("height"), n3 = i4.getAttribute("width");
  if (i4[Ue] = { initial: { height: s2, width: n3, style: { display: e.display, height: e.height, width: e.width } } }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", bn(n3)) {
    let o3 = Di(i4, "width");
    o3 !== void 0 && (i4.width = o3);
  }
  if (bn(s2))
    if (i4.style.height === "")
      i4.height = i4.width / (t || 2);
    else {
      let o3 = Di(i4, "height");
      o3 !== void 0 && (i4.height = o3);
    }
  return i4;
}
function or(i4, t, e) {
  i4 && i4.addEventListener(t, e, ro);
}
function ar(i4, t, e) {
  i4 && i4.canvas && i4.canvas.removeEventListener(t, e, ro);
}
function rr(i4, t) {
  let e = sr[i4.type] || i4.type, { x: s2, y: n3 } = kt(i4, t);
  return { type: e, chart: t, native: i4, x: s2 !== void 0 ? s2 : null, y: n3 !== void 0 ? n3 : null };
}
function Ge(i4, t) {
  for (let e of i4)
    if (e === t || e.contains(t))
      return true;
}
function lr(i4, t, e) {
  let s2 = i4.canvas, n3 = new MutationObserver((o3) => {
    let a2 = false;
    for (let r of o3)
      a2 = a2 || Ge(r.addedNodes, s2), a2 = a2 && !Ge(r.removedNodes, s2);
    a2 && e();
  });
  return n3.observe(document, { childList: true, subtree: true }), n3;
}
function cr(i4, t, e) {
  let s2 = i4.canvas, n3 = new MutationObserver((o3) => {
    let a2 = false;
    for (let r of o3)
      a2 = a2 || Ge(r.removedNodes, s2), a2 = a2 && !Ge(r.addedNodes, s2);
    a2 && e();
  });
  return n3.observe(document, { childList: true, subtree: true }), n3;
}
function lo() {
  let i4 = window.devicePixelRatio;
  i4 !== _n && (_n = i4, ge.forEach((t, e) => {
    e.currentDevicePixelRatio !== i4 && t();
  }));
}
function hr(i4, t) {
  ge.size || window.addEventListener("resize", lo), ge.set(i4, t);
}
function dr(i4) {
  ge.delete(i4), ge.size || window.removeEventListener("resize", lo);
}
function ur(i4, t, e) {
  let s2 = i4.canvas, n3 = s2 && ze(s2);
  if (!n3)
    return;
  let o3 = gi((r, l4) => {
    let c3 = n3.clientWidth;
    e(r, l4), c3 < n3.clientWidth && e();
  }, window), a2 = new ResizeObserver((r) => {
    let l4 = r[0], c3 = l4.contentRect.width, h5 = l4.contentRect.height;
    c3 === 0 && h5 === 0 || o3(c3, h5);
  });
  return a2.observe(n3), hr(i4, o3), a2;
}
function Fi(i4, t, e) {
  e && e.disconnect(), t === "resize" && dr(i4);
}
function fr(i4, t, e) {
  let s2 = i4.canvas, n3 = gi((o3) => {
    i4.ctx !== null && e(rr(o3, i4));
  }, i4);
  return or(s2, t, n3), n3;
}
function gr(i4) {
  return !Ie() || typeof OffscreenCanvas < "u" && i4 instanceof OffscreenCanvas ? Gi : Ji;
}
function pr(i4, t) {
  let e = i4.options.ticks, s2 = mr(i4), n3 = Math.min(e.maxTicksLimit || s2, s2), o3 = e.major.enabled ? _r(t) : [], a2 = o3.length, r = o3[0], l4 = o3[a2 - 1], c3 = [];
  if (a2 > n3)
    return xr(t, c3, o3, a2 / n3), c3;
  let h5 = br(o3, t, n3);
  if (a2 > 0) {
    let d5, u3, f4 = a2 > 1 ? Math.round((l4 - r) / (a2 - 1)) : null;
    for (Ve(t, c3, h5, L3(f4) ? 0 : r - f4, r), d5 = 0, u3 = a2 - 1; d5 < u3; d5++)
      Ve(t, c3, h5, o3[d5], o3[d5 + 1]);
    return Ve(t, c3, h5, l4, L3(f4) ? t.length : l4 + f4), c3;
  }
  return Ve(t, c3, h5), c3;
}
function mr(i4) {
  let t = i4.options.offset, e = i4._tickSize(), s2 = i4._length / e + (t ? 0 : 1), n3 = i4._maxLength / e;
  return Math.floor(Math.min(s2, n3));
}
function br(i4, t, e) {
  let s2 = yr(i4), n3 = t.length / e;
  if (!s2)
    return Math.max(n3, 1);
  let o3 = Ls(s2);
  for (let a2 = 0, r = o3.length - 1; a2 < r; a2++) {
    let l4 = o3[a2];
    if (l4 > n3)
      return l4;
  }
  return Math.max(n3, 1);
}
function _r(i4) {
  let t = [], e, s2;
  for (e = 0, s2 = i4.length; e < s2; e++)
    i4[e].major && t.push(e);
  return t;
}
function xr(i4, t, e, s2) {
  let n3 = 0, o3 = e[0], a2;
  for (s2 = Math.ceil(s2), a2 = 0; a2 < i4.length; a2++)
    a2 === o3 && (t.push(i4[a2]), n3++, o3 = e[n3 * s2]);
}
function Ve(i4, t, e, s2, n3) {
  let o3 = P3(s2, 0), a2 = Math.min(P3(n3, i4.length), i4.length), r = 0, l4, c3, h5;
  for (e = Math.ceil(e), n3 && (l4 = n3 - s2, e = l4 / Math.floor(l4 / e)), h5 = o3; h5 < 0; )
    r++, h5 = Math.round(o3 + r * e);
  for (c3 = Math.max(o3, 0); c3 < a2; c3++)
    c3 === h5 && (t.push(i4[c3]), r++, h5 = Math.round(o3 + r * e));
}
function yr(i4) {
  let t = i4.length, e, s2;
  if (t < 2)
    return false;
  for (s2 = i4[0], e = 1; e < t; ++e)
    if (i4[e] - i4[e - 1] !== s2)
      return false;
  return s2;
}
function vn(i4, t) {
  let e = [], s2 = i4.length / t, n3 = i4.length, o3 = 0;
  for (; o3 < n3; o3 += s2)
    e.push(i4[Math.floor(o3)]);
  return e;
}
function Mr(i4, t, e) {
  let s2 = i4.ticks.length, n3 = Math.min(t, s2 - 1), o3 = i4._startPixel, a2 = i4._endPixel, r = 1e-6, l4 = i4.getPixelForTick(n3), c3;
  if (!(e && (s2 === 1 ? c3 = Math.max(l4 - o3, a2 - l4) : t === 0 ? c3 = (i4.getPixelForTick(1) - l4) / 2 : c3 = (l4 - i4.getPixelForTick(n3 - 1)) / 2, l4 += n3 < t ? c3 : -c3, l4 < o3 - r || l4 > a2 + r)))
    return l4;
}
function kr(i4, t) {
  T3(i4, (e) => {
    let s2 = e.gc, n3 = s2.length / 2, o3;
    if (n3 > t) {
      for (o3 = 0; o3 < n3; ++o3)
        delete e.data[s2[o3]];
      s2.splice(0, n3);
    }
  });
}
function ce(i4) {
  return i4.drawTicks ? i4.tickLength : 0;
}
function Mn(i4, t) {
  if (!i4.display)
    return 0;
  let e = j3(i4.font, t), s2 = X3(i4.padding);
  return (I3(i4.text) ? i4.text.length : 1) * e.lineHeight + s2.height;
}
function Sr(i4, t) {
  return pt(i4, { scale: t, type: "scale" });
}
function wr(i4, t, e) {
  return pt(i4, { tick: e, index: t, type: "tick" });
}
function Pr(i4, t, e) {
  let s2 = Ae(i4);
  return (e && t !== "right" || !e && t === "right") && (s2 = vr(s2)), s2;
}
function Dr(i4, t, e, s2) {
  let { top: n3, left: o3, bottom: a2, right: r, chart: l4 } = i4, { chartArea: c3, scales: h5 } = l4, d5 = 0, u3, f4, g4, p6 = a2 - n3, m6 = r - o3;
  if (i4.isHorizontal()) {
    if (f4 = Y3(s2, o3, r), O3(e)) {
      let b5 = Object.keys(e)[0], _5 = e[b5];
      g4 = h5[b5].getPixelForValue(_5) + p6 - t;
    } else
      e === "center" ? g4 = (c3.bottom + c3.top) / 2 + p6 - t : g4 = xn(i4, e, t);
    u3 = r - o3;
  } else {
    if (O3(e)) {
      let b5 = Object.keys(e)[0], _5 = e[b5];
      f4 = h5[b5].getPixelForValue(_5) - m6 + t;
    } else
      e === "center" ? f4 = (c3.left + c3.right) / 2 - m6 + t : f4 = xn(i4, e, t);
    g4 = Y3(s2, a2, n3), d5 = e === "left" ? -N3 : N3;
  }
  return { titleX: f4, titleY: g4, maxWidth: u3, rotation: d5 };
}
function Cr(i4, t, e) {
  let s2 = Bt(/* @__PURE__ */ Object.create(null), [e ? W3.get(e) : {}, W3.get(t), i4.defaults]);
  W3.set(t, s2), i4.defaultRoutes && Or(t, i4.defaultRoutes), i4.descriptors && W3.describe(t, i4.descriptors);
}
function Or(i4, t) {
  Object.keys(t).forEach((e) => {
    let s2 = e.split("."), n3 = s2.pop(), o3 = [i4].concat(s2).join("."), a2 = t[e].split("."), r = a2.pop(), l4 = a2.join(".");
    W3.route(o3, n3, l4, r);
  });
}
function Ar(i4) {
  return "id" in i4 && "defaults" in i4;
}
function Lr(i4) {
  let t = {}, e = [], s2 = Object.keys(ht.plugins.items);
  for (let o3 = 0; o3 < s2.length; o3++)
    e.push(ht.getPlugin(s2[o3]));
  let n3 = i4.plugins || [];
  for (let o3 = 0; o3 < n3.length; o3++) {
    let a2 = n3[o3];
    e.indexOf(a2) === -1 && (e.push(a2), t[a2.id] = true);
  }
  return { plugins: e, localIds: t };
}
function Tr(i4, t) {
  return !t && i4 === false ? null : i4 === true ? {} : i4;
}
function Rr(i4, { plugins: t, localIds: e }, s2, n3) {
  let o3 = [], a2 = i4.getContext();
  for (let r of t) {
    let l4 = r.id, c3 = Tr(s2[l4], n3);
    c3 !== null && o3.push({ plugin: r, options: Er(i4.config, { plugin: r, local: e[l4] }, c3, a2) });
  }
  return o3;
}
function Er(i4, { plugin: t, local: e }, s2, n3) {
  let o3 = i4.pluginScopeKeys(t), a2 = i4.getOptionScopes(s2, o3);
  return e && t.defaults && a2.push(t.defaults), i4.createResolver(a2, n3, [""], { scriptable: false, indexable: false, allKeys: true });
}
function ts(i4, t) {
  let e = W3.datasets[i4] || {};
  return ((t.datasets || {})[i4] || {}).indexAxis || t.indexAxis || e.indexAxis || "x";
}
function Ir(i4, t) {
  let e = i4;
  return i4 === "_index_" ? e = t : i4 === "_value_" && (e = t === "x" ? "y" : "x"), e;
}
function zr(i4, t) {
  return i4 === t ? "_index_" : "_value_";
}
function kn(i4) {
  if (i4 === "x" || i4 === "y" || i4 === "r")
    return i4;
}
function Fr(i4) {
  if (i4 === "top" || i4 === "bottom")
    return "x";
  if (i4 === "left" || i4 === "right")
    return "y";
}
function es(i4, ...t) {
  if (kn(i4))
    return i4;
  for (let e of t) {
    let s2 = e.axis || Fr(e.position) || i4.length > 1 && kn(i4[0].toLowerCase());
    if (s2)
      return s2;
  }
  throw new Error(`Cannot determine type of '${i4}' axis. Please provide 'axis' or 'position' option.`);
}
function Sn(i4, t, e) {
  if (e[t + "AxisID"] === i4)
    return { axis: t };
}
function Br(i4, t) {
  if (t.data && t.data.datasets) {
    let e = t.data.datasets.filter((s2) => s2.xAxisID === i4 || s2.yAxisID === i4);
    if (e.length)
      return Sn(i4, "x", e[0]) || Sn(i4, "y", e[0]);
  }
  return {};
}
function Vr(i4, t) {
  let e = xt[i4.type] || { scales: {} }, s2 = t.scales || {}, n3 = ts(i4.type, t), o3 = /* @__PURE__ */ Object.create(null);
  return Object.keys(s2).forEach((a2) => {
    let r = s2[a2];
    if (!O3(r))
      return console.error(`Invalid scale configuration for scale: ${a2}`);
    if (r._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a2}`);
    let l4 = es(a2, r, Br(a2, i4), W3.scales[r.type]), c3 = zr(l4, n3), h5 = e.scales || {};
    o3[a2] = Wt(/* @__PURE__ */ Object.create(null), [{ axis: l4 }, r, h5[l4], h5[c3]]);
  }), i4.data.datasets.forEach((a2) => {
    let r = a2.type || i4.type, l4 = a2.indexAxis || ts(r, t), h5 = (xt[r] || {}).scales || {};
    Object.keys(h5).forEach((d5) => {
      let u3 = Ir(d5, l4), f4 = a2[u3 + "AxisID"] || u3;
      o3[f4] = o3[f4] || /* @__PURE__ */ Object.create(null), Wt(o3[f4], [{ axis: u3 }, s2[f4], h5[d5]]);
    });
  }), Object.keys(o3).forEach((a2) => {
    let r = o3[a2];
    Wt(r, [W3.scales[r.type], W3.scale]);
  }), o3;
}
function co(i4) {
  let t = i4.options || (i4.options = {});
  t.plugins = P3(t.plugins, {}), t.scales = Vr(i4, t);
}
function ho(i4) {
  return i4 = i4 || {}, i4.datasets = i4.datasets || [], i4.labels = i4.labels || [], i4;
}
function Wr(i4) {
  return i4 = i4 || {}, i4.data = ho(i4.data), co(i4), i4;
}
function We(i4, t) {
  let e = wn.get(i4);
  return e || (e = t(), wn.set(i4, e), uo.add(e)), e;
}
function Pn(i4, t, e) {
  let s2 = i4.get(t);
  s2 || (s2 = /* @__PURE__ */ new Map(), i4.set(t, s2));
  let n3 = e.join(), o3 = s2.get(n3);
  return o3 || (o3 = { resolver: Ee(t, e), subPrefixes: e.filter((r) => !r.toLowerCase().includes("hover")) }, s2.set(n3, o3)), o3;
}
function Hr(i4, t) {
  let { isScriptable: e, isIndexable: s2 } = Mi(i4);
  for (let n3 of t) {
    let o3 = e(n3), a2 = s2(n3), r = (a2 || o3) && i4[n3];
    if (o3 && (ut(r) || Nr(r)) || a2 && I3(r))
      return true;
  }
  return false;
}
function Dn(i4, t) {
  return i4 === "top" || i4 === "bottom" || $r.indexOf(i4) === -1 && t === "x";
}
function Cn(i4, t) {
  return function(e, s2) {
    return e[i4] === s2[i4] ? e[t] - s2[t] : e[i4] - s2[i4];
  };
}
function On(i4) {
  let t = i4.chart, e = t.options.animation;
  t.notifyPlugins("afterRender"), E2(e && e.onComplete, [i4], t);
}
function Ur(i4) {
  let t = i4.chart, e = t.options.animation;
  E2(e && e.onProgress, [i4], t);
}
function fo(i4) {
  return Ie() && typeof i4 == "string" ? i4 = document.getElementById(i4) : i4 && i4.length && (i4 = i4[0]), i4 && i4.canvas && (i4 = i4.canvas), i4;
}
function Yr(i4, t, e) {
  let s2 = Object.keys(i4);
  for (let n3 of s2) {
    let o3 = +n3;
    if (o3 >= t) {
      let a2 = i4[n3];
      delete i4[n3], (e > 0 || o3 > t) && (i4[o3 + e] = a2);
    }
  }
}
function Xr(i4, t, e, s2) {
  return !e || i4.type === "mouseout" ? null : s2 ? t : i4;
}
function Ne(i4, t, e) {
  return i4.options.clip ? i4[e] : t[e];
}
function Kr(i4, t) {
  let { xScale: e, yScale: s2 } = i4;
  return e && s2 ? { left: Ne(e, t, "left"), right: Ne(e, t, "right"), top: Ne(s2, t, "top"), bottom: Ne(s2, t, "bottom") } : t;
}
function Ln() {
  return T3(qt.instances, (i4) => i4._plugins.invalidate());
}
function qr(i4, t, e) {
  let { startAngle: s2, pixelMargin: n3, x: o3, y: a2, outerRadius: r, innerRadius: l4 } = t, c3 = n3 / r;
  i4.beginPath(), i4.arc(o3, a2, r, s2 - c3, e + c3), l4 > n3 ? (c3 = n3 / l4, i4.arc(o3, a2, l4, e + c3, s2 - c3, true)) : i4.arc(o3, a2, n3, e + N3, s2 - N3), i4.closePath(), i4.clip();
}
function Gr(i4) {
  return Re(i4, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function Jr(i4, t, e, s2) {
  let n3 = Gr(i4.options.borderRadius), o3 = (e - t) / 2, a2 = Math.min(o3, s2 * t / 2), r = (l4) => {
    let c3 = (e - Math.min(o3, l4)) * s2 / 2;
    return $3(l4, 0, Math.min(o3, c3));
  };
  return { outerStart: r(n3.outerStart), outerEnd: r(n3.outerEnd), innerStart: $3(n3.innerStart, 0, a2), innerEnd: $3(n3.innerEnd, 0, a2) };
}
function Xt(i4, t, e, s2) {
  return { x: e + i4 * Math.cos(t), y: s2 + i4 * Math.sin(t) };
}
function Je(i4, t, e, s2, n3, o3) {
  let { x: a2, y: r, startAngle: l4, pixelMargin: c3, innerRadius: h5 } = t, d5 = Math.max(t.outerRadius + s2 + e - c3, 0), u3 = h5 > 0 ? h5 + s2 + e + c3 : 0, f4 = 0, g4 = n3 - l4;
  if (s2) {
    let R4 = h5 > 0 ? h5 - s2 : 0, B4 = d5 > 0 ? d5 - s2 : 0, H4 = (R4 + B4) / 2, it = H4 !== 0 ? g4 * H4 / (H4 + s2) : g4;
    f4 = (g4 - it) / 2;
  }
  let p6 = Math.max(1e-3, g4 * d5 - e / z2) / d5, m6 = (g4 - p6) / 2, b5 = l4 + m6 + f4, _5 = n3 - m6 - f4, { outerStart: v5, outerEnd: y5, innerStart: x5, innerEnd: M5 } = Jr(t, u3, d5, _5 - b5), k4 = d5 - v5, S6 = d5 - y5, w4 = b5 + v5 / k4, D5 = _5 - y5 / S6, C5 = u3 + x5, A5 = u3 + M5, U4 = b5 + x5 / C5, tt = _5 - M5 / A5;
  if (i4.beginPath(), o3) {
    let R4 = (w4 + D5) / 2;
    if (i4.arc(a2, r, d5, w4, R4), i4.arc(a2, r, d5, R4, D5), y5 > 0) {
      let K3 = Xt(S6, D5, a2, r);
      i4.arc(K3.x, K3.y, y5, D5, _5 + N3);
    }
    let B4 = Xt(A5, _5, a2, r);
    if (i4.lineTo(B4.x, B4.y), M5 > 0) {
      let K3 = Xt(A5, tt, a2, r);
      i4.arc(K3.x, K3.y, M5, _5 + N3, tt + Math.PI);
    }
    let H4 = (_5 - M5 / u3 + (b5 + x5 / u3)) / 2;
    if (i4.arc(a2, r, u3, _5 - M5 / u3, H4, true), i4.arc(a2, r, u3, H4, b5 + x5 / u3, true), x5 > 0) {
      let K3 = Xt(C5, U4, a2, r);
      i4.arc(K3.x, K3.y, x5, U4 + Math.PI, b5 - N3);
    }
    let it = Xt(k4, b5, a2, r);
    if (i4.lineTo(it.x, it.y), v5 > 0) {
      let K3 = Xt(k4, w4, a2, r);
      i4.arc(K3.x, K3.y, v5, b5 - N3, w4);
    }
  } else {
    i4.moveTo(a2, r);
    let R4 = Math.cos(w4) * d5 + a2, B4 = Math.sin(w4) * d5 + r;
    i4.lineTo(R4, B4);
    let H4 = Math.cos(D5) * d5 + a2, it = Math.sin(D5) * d5 + r;
    i4.lineTo(H4, it);
  }
  i4.closePath();
}
function Qr(i4, t, e, s2, n3) {
  let { fullCircles: o3, startAngle: a2, circumference: r } = t, l4 = t.endAngle;
  if (o3) {
    Je(i4, t, e, s2, l4, n3);
    for (let c3 = 0; c3 < o3; ++c3)
      i4.fill();
    isNaN(r) || (l4 = a2 + (r % F3 || F3));
  }
  return Je(i4, t, e, s2, l4, n3), i4.fill(), l4;
}
function Zr(i4, t, e, s2, n3) {
  let { fullCircles: o3, startAngle: a2, circumference: r, options: l4 } = t, { borderWidth: c3, borderJoinStyle: h5, borderDash: d5, borderDashOffset: u3 } = l4, f4 = l4.borderAlign === "inner";
  if (!c3)
    return;
  i4.setLineDash(d5 || []), i4.lineDashOffset = u3, f4 ? (i4.lineWidth = c3 * 2, i4.lineJoin = h5 || "round") : (i4.lineWidth = c3, i4.lineJoin = h5 || "bevel");
  let g4 = t.endAngle;
  if (o3) {
    Je(i4, t, e, s2, g4, n3);
    for (let p6 = 0; p6 < o3; ++p6)
      i4.stroke();
    isNaN(r) || (g4 = a2 + (r % F3 || F3));
  }
  f4 && qr(i4, t, g4), o3 || (Je(i4, t, e, s2, g4, n3), i4.stroke());
}
function go(i4, t, e = t) {
  i4.lineCap = P3(e.borderCapStyle, t.borderCapStyle), i4.setLineDash(P3(e.borderDash, t.borderDash)), i4.lineDashOffset = P3(e.borderDashOffset, t.borderDashOffset), i4.lineJoin = P3(e.borderJoinStyle, t.borderJoinStyle), i4.lineWidth = P3(e.borderWidth, t.borderWidth), i4.strokeStyle = P3(e.borderColor, t.borderColor);
}
function tl(i4, t, e) {
  i4.lineTo(e.x, e.y);
}
function el(i4) {
  return i4.stepped ? Hs : i4.tension || i4.cubicInterpolationMode === "monotone" ? js : tl;
}
function po(i4, t, e = {}) {
  let s2 = i4.length, { start: n3 = 0, end: o3 = s2 - 1 } = e, { start: a2, end: r } = t, l4 = Math.max(n3, a2), c3 = Math.min(o3, r), h5 = n3 < a2 && o3 < a2 || n3 > r && o3 > r;
  return { count: s2, start: l4, loop: t.loop, ilen: c3 < l4 && !h5 ? s2 + c3 - l4 : c3 - l4 };
}
function il(i4, t, e, s2) {
  let { points: n3, options: o3 } = t, { count: a2, start: r, loop: l4, ilen: c3 } = po(n3, e, s2), h5 = el(o3), { move: d5 = true, reverse: u3 } = s2 || {}, f4, g4, p6;
  for (f4 = 0; f4 <= c3; ++f4)
    g4 = n3[(r + (u3 ? c3 - f4 : f4)) % a2], !g4.skip && (d5 ? (i4.moveTo(g4.x, g4.y), d5 = false) : h5(i4, p6, g4, u3, o3.stepped), p6 = g4);
  return l4 && (g4 = n3[(r + (u3 ? c3 : 0)) % a2], h5(i4, p6, g4, u3, o3.stepped)), !!l4;
}
function sl(i4, t, e, s2) {
  let n3 = t.points, { count: o3, start: a2, ilen: r } = po(n3, e, s2), { move: l4 = true, reverse: c3 } = s2 || {}, h5 = 0, d5 = 0, u3, f4, g4, p6, m6, b5, _5 = (y5) => (a2 + (c3 ? r - y5 : y5)) % o3, v5 = () => {
    p6 !== m6 && (i4.lineTo(h5, m6), i4.lineTo(h5, p6), i4.lineTo(h5, b5));
  };
  for (l4 && (f4 = n3[_5(0)], i4.moveTo(f4.x, f4.y)), u3 = 0; u3 <= r; ++u3) {
    if (f4 = n3[_5(u3)], f4.skip)
      continue;
    let y5 = f4.x, x5 = f4.y, M5 = y5 | 0;
    M5 === g4 ? (x5 < p6 ? p6 = x5 : x5 > m6 && (m6 = x5), h5 = (d5 * h5 + y5) / ++d5) : (v5(), i4.lineTo(y5, x5), g4 = M5, d5 = 0, p6 = m6 = x5), b5 = x5;
  }
  v5();
}
function ns(i4) {
  let t = i4.options, e = t.borderDash && t.borderDash.length;
  return !i4._decimated && !i4._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? sl : il;
}
function nl(i4) {
  return i4.stepped ? Qs : i4.tension || i4.cubicInterpolationMode === "monotone" ? Zs : _t;
}
function ol(i4, t, e, s2) {
  let n3 = t._path;
  n3 || (n3 = t._path = new Path2D(), t.path(n3, e, s2) && n3.closePath()), go(i4, t.options), i4.stroke(n3);
}
function al(i4, t, e, s2) {
  let { segments: n3, options: o3 } = t, a2 = ns(t);
  for (let r of n3)
    go(i4, o3, r.style), i4.beginPath(), a2(i4, t, r, { start: e, end: e + s2 - 1 }) && i4.closePath(), i4.stroke();
}
function ll(i4, t, e, s2) {
  rl && !t.options.segment ? ol(i4, t, e, s2) : al(i4, t, e, s2);
}
function Tn(i4, t, e, s2) {
  let n3 = i4.options, { [e]: o3 } = i4.getProps([e], s2);
  return Math.abs(t - o3) < n3.radius + n3.hitRadius;
}
function mo(i4, t) {
  let { x: e, y: s2, base: n3, width: o3, height: a2 } = i4.getProps(["x", "y", "base", "width", "height"], t), r, l4, c3, h5, d5;
  return i4.horizontal ? (d5 = a2 / 2, r = Math.min(e, n3), l4 = Math.max(e, n3), c3 = s2 - d5, h5 = s2 + d5) : (d5 = o3 / 2, r = e - d5, l4 = e + d5, c3 = Math.min(s2, n3), h5 = Math.max(s2, n3)), { left: r, top: c3, right: l4, bottom: h5 };
}
function St(i4, t, e, s2) {
  return i4 ? 0 : $3(t, e, s2);
}
function cl(i4, t, e) {
  let s2 = i4.options.borderWidth, n3 = i4.borderSkipped, o3 = vi(s2);
  return { t: St(n3.top, o3.top, 0, e), r: St(n3.right, o3.right, 0, t), b: St(n3.bottom, o3.bottom, 0, e), l: St(n3.left, o3.left, 0, t) };
}
function hl(i4, t, e) {
  let { enableBorderRadius: s2 } = i4.getProps(["enableBorderRadius"]), n3 = i4.options.borderRadius, o3 = Mt(n3), a2 = Math.min(t, e), r = i4.borderSkipped, l4 = s2 || O3(n3);
  return { topLeft: St(!l4 || r.top || r.left, o3.topLeft, 0, a2), topRight: St(!l4 || r.top || r.right, o3.topRight, 0, a2), bottomLeft: St(!l4 || r.bottom || r.left, o3.bottomLeft, 0, a2), bottomRight: St(!l4 || r.bottom || r.right, o3.bottomRight, 0, a2) };
}
function dl(i4) {
  let t = mo(i4), e = t.right - t.left, s2 = t.bottom - t.top, n3 = cl(i4, e / 2, s2 / 2), o3 = hl(i4, e / 2, s2 / 2);
  return { outer: { x: t.left, y: t.top, w: e, h: s2, radius: o3 }, inner: { x: t.left + n3.l, y: t.top + n3.t, w: e - n3.l - n3.r, h: s2 - n3.t - n3.b, radius: { topLeft: Math.max(0, o3.topLeft - Math.max(n3.t, n3.l)), topRight: Math.max(0, o3.topRight - Math.max(n3.t, n3.r)), bottomLeft: Math.max(0, o3.bottomLeft - Math.max(n3.b, n3.l)), bottomRight: Math.max(0, o3.bottomRight - Math.max(n3.b, n3.r)) } } };
}
function Bi(i4, t, e, s2) {
  let n3 = t === null, o3 = e === null, r = i4 && !(n3 && o3) && mo(i4, s2);
  return r && (n3 || lt(t, r.left, r.right)) && (o3 || lt(e, r.top, r.bottom));
}
function ul(i4) {
  return i4.topLeft || i4.topRight || i4.bottomLeft || i4.bottomRight;
}
function fl(i4, t) {
  i4.rect(t.x, t.y, t.w, t.h);
}
function Vi(i4, t, e = {}) {
  let s2 = i4.x !== e.x ? -t : 0, n3 = i4.y !== e.y ? -t : 0, o3 = (i4.x + i4.w !== e.x + e.w ? t : 0) - s2, a2 = (i4.y + i4.h !== e.y + e.h ? t : 0) - n3;
  return { x: i4.x + s2, y: i4.y + n3, w: i4.w + o3, h: i4.h + a2, radius: i4.radius };
}
function bo(i4) {
  return rs[i4 % rs.length];
}
function _o(i4) {
  return Rn[i4 % Rn.length];
}
function pl(i4, t) {
  return i4.borderColor = bo(t), i4.backgroundColor = _o(t), ++t;
}
function ml(i4, t) {
  return i4.backgroundColor = i4.data.map(() => bo(t++)), t;
}
function bl(i4, t) {
  return i4.backgroundColor = i4.data.map(() => _o(t++)), t;
}
function _l(i4) {
  let t = 0;
  return (e, s2) => {
    let n3 = i4.getDatasetMeta(s2).controller;
    n3 instanceof fe ? t = ml(e, t) : n3 instanceof Ke ? t = bl(e, t) : n3 && (t = pl(e, t));
  };
}
function En(i4) {
  let t;
  for (t in i4)
    if (i4[t].borderColor || i4[t].backgroundColor)
      return true;
  return false;
}
function xl(i4) {
  return i4 && (i4.borderColor || i4.backgroundColor);
}
function vl(i4, t, e, s2, n3) {
  let o3 = n3.samples || s2;
  if (o3 >= e)
    return i4.slice(t, t + e);
  let a2 = [], r = (e - 2) / (o3 - 2), l4 = 0, c3 = t + e - 1, h5 = t, d5, u3, f4, g4, p6;
  for (a2[l4++] = i4[h5], d5 = 0; d5 < o3 - 2; d5++) {
    let m6 = 0, b5 = 0, _5, v5 = Math.floor((d5 + 1) * r) + 1 + t, y5 = Math.min(Math.floor((d5 + 2) * r) + 1, e) + t, x5 = y5 - v5;
    for (_5 = v5; _5 < y5; _5++)
      m6 += i4[_5].x, b5 += i4[_5].y;
    m6 /= x5, b5 /= x5;
    let M5 = Math.floor(d5 * r) + 1 + t, k4 = Math.min(Math.floor((d5 + 1) * r) + 1, e) + t, { x: S6, y: w4 } = i4[h5];
    for (f4 = g4 = -1, _5 = M5; _5 < k4; _5++)
      g4 = 0.5 * Math.abs((S6 - m6) * (i4[_5].y - w4) - (S6 - i4[_5].x) * (b5 - w4)), g4 > f4 && (f4 = g4, u3 = i4[_5], p6 = _5);
    a2[l4++] = u3, h5 = p6;
  }
  return a2[l4++] = i4[c3], a2;
}
function Ml(i4, t, e, s2) {
  let n3 = 0, o3 = 0, a2, r, l4, c3, h5, d5, u3, f4, g4, p6, m6 = [], b5 = t + e - 1, _5 = i4[t].x, y5 = i4[b5].x - _5;
  for (a2 = t; a2 < t + e; ++a2) {
    r = i4[a2], l4 = (r.x - _5) / y5 * s2, c3 = r.y;
    let x5 = l4 | 0;
    if (x5 === h5)
      c3 < g4 ? (g4 = c3, d5 = a2) : c3 > p6 && (p6 = c3, u3 = a2), n3 = (o3 * n3 + r.x) / ++o3;
    else {
      let M5 = a2 - 1;
      if (!L3(d5) && !L3(u3)) {
        let k4 = Math.min(d5, u3), S6 = Math.max(d5, u3);
        k4 !== f4 && k4 !== M5 && m6.push({ ...i4[k4], x: n3 }), S6 !== f4 && S6 !== M5 && m6.push({ ...i4[S6], x: n3 });
      }
      a2 > 0 && M5 !== f4 && m6.push(i4[M5]), m6.push(r), h5 = x5, o3 = 0, g4 = p6 = c3, d5 = u3 = f4 = a2;
    }
  }
  return m6;
}
function xo(i4) {
  if (i4._decimated) {
    let t = i4._data;
    delete i4._decimated, delete i4._data, Object.defineProperty(i4, "data", { configurable: true, enumerable: true, writable: true, value: t });
  }
}
function In(i4) {
  i4.data.datasets.forEach((t) => {
    xo(t);
  });
}
function kl(i4, t) {
  let e = t.length, s2 = 0, n3, { iScale: o3 } = i4, { min: a2, max: r, minDefined: l4, maxDefined: c3 } = o3.getUserBounds();
  return l4 && (s2 = $3(ot(t, o3.axis, a2).lo, 0, e - 1)), c3 ? n3 = $3(ot(t, o3.axis, r).hi + 1, s2, e) - s2 : n3 = e - s2, { start: s2, count: n3 };
}
function wl(i4, t, e) {
  let s2 = i4.segments, n3 = i4.points, o3 = t.points, a2 = [];
  for (let r of s2) {
    let { start: l4, end: c3 } = r;
    c3 = ps(l4, c3, n3);
    let h5 = ls(e, n3[l4], n3[c3], r.loop);
    if (!t.segments) {
      a2.push({ source: r, target: h5, start: n3[l4], end: n3[c3] });
      continue;
    }
    let d5 = Li(t, h5);
    for (let u3 of d5) {
      let f4 = ls(e, o3[u3.start], o3[u3.end], u3.loop), g4 = Ai(r, n3, f4);
      for (let p6 of g4)
        a2.push({ source: p6, target: u3, start: { [e]: zn(h5, f4, "start", Math.max) }, end: { [e]: zn(h5, f4, "end", Math.min) } });
    }
  }
  return a2;
}
function ls(i4, t, e, s2) {
  if (s2)
    return;
  let n3 = t[i4], o3 = e[i4];
  return i4 === "angle" && (n3 = G3(n3), o3 = G3(o3)), { property: i4, start: n3, end: o3 };
}
function Pl(i4, t) {
  let { x: e = null, y: s2 = null } = i4 || {}, n3 = t.points, o3 = [];
  return t.segments.forEach(({ start: a2, end: r }) => {
    r = ps(a2, r, n3);
    let l4 = n3[a2], c3 = n3[r];
    s2 !== null ? (o3.push({ x: l4.x, y: s2 }), o3.push({ x: c3.x, y: s2 })) : e !== null && (o3.push({ x: e, y: l4.y }), o3.push({ x: e, y: c3.y }));
  }), o3;
}
function ps(i4, t, e) {
  for (; t > i4; t--) {
    let s2 = e[t];
    if (!isNaN(s2.x) && !isNaN(s2.y))
      break;
  }
  return t;
}
function zn(i4, t, e, s2) {
  return i4 && t ? s2(i4[e], t[e]) : i4 ? i4[e] : t ? t[e] : 0;
}
function yo(i4, t) {
  let e = [], s2 = false;
  return I3(i4) ? (s2 = true, e = i4) : e = Pl(i4, t), e.length ? new Gt({ points: e, options: { tension: 0 }, _loop: s2, _fullLoop: s2 }) : null;
}
function Fn(i4) {
  return i4 && i4.fill !== false;
}
function Dl(i4, t, e) {
  let n3 = i4[t].fill, o3 = [t], a2;
  if (!e)
    return n3;
  for (; n3 !== false && o3.indexOf(n3) === -1; ) {
    if (!V3(n3))
      return n3;
    if (a2 = i4[n3], !a2)
      return false;
    if (a2.visible)
      return n3;
    o3.push(n3), n3 = a2.fill;
  }
  return false;
}
function Cl(i4, t, e) {
  let s2 = Tl(i4);
  if (O3(s2))
    return isNaN(s2.value) ? false : s2;
  let n3 = parseFloat(s2);
  return V3(n3) && Math.floor(n3) === n3 ? Ol(s2[0], t, n3, e) : ["origin", "start", "end", "stack", "shape"].indexOf(s2) >= 0 && s2;
}
function Ol(i4, t, e, s2) {
  return (i4 === "-" || i4 === "+") && (e = t + e), e === t || e < 0 || e >= s2 ? false : e;
}
function Al(i4, t) {
  let e = null;
  return i4 === "start" ? e = t.bottom : i4 === "end" ? e = t.top : O3(i4) ? e = t.getPixelForValue(i4.value) : t.getBasePixel && (e = t.getBasePixel()), e;
}
function Ll(i4, t, e) {
  let s2;
  return i4 === "start" ? s2 = e : i4 === "end" ? s2 = t.options.reverse ? t.min : t.max : O3(i4) ? s2 = i4.value : s2 = t.getBaseValue(), s2;
}
function Tl(i4) {
  let t = i4.options, e = t.fill, s2 = P3(e && e.target, e);
  return s2 === void 0 && (s2 = !!t.backgroundColor), s2 === false || s2 === null ? false : s2 === true ? "origin" : s2;
}
function Rl(i4) {
  let { scale: t, index: e, line: s2 } = i4, n3 = [], o3 = s2.segments, a2 = s2.points, r = El(t, e);
  r.push(yo({ x: null, y: t.bottom }, s2));
  for (let l4 = 0; l4 < o3.length; l4++) {
    let c3 = o3[l4];
    for (let h5 = c3.start; h5 <= c3.end; h5++)
      Il(n3, a2[h5], r);
  }
  return new Gt({ points: n3, options: {} });
}
function El(i4, t) {
  let e = [], s2 = i4.getMatchingVisibleMetas("line");
  for (let n3 = 0; n3 < s2.length; n3++) {
    let o3 = s2[n3];
    if (o3.index === t)
      break;
    o3.hidden || e.unshift(o3.dataset);
  }
  return e;
}
function Il(i4, t, e) {
  let s2 = [];
  for (let n3 = 0; n3 < e.length; n3++) {
    let o3 = e[n3], { first: a2, last: r, point: l4 } = zl(o3, t, "x");
    if (!(!l4 || a2 && r)) {
      if (a2)
        s2.unshift(l4);
      else if (i4.push(l4), !r)
        break;
    }
  }
  i4.push(...s2);
}
function zl(i4, t, e) {
  let s2 = i4.interpolate(t, e);
  if (!s2)
    return {};
  let n3 = s2[e], o3 = i4.segments, a2 = i4.points, r = false, l4 = false;
  for (let c3 = 0; c3 < o3.length; c3++) {
    let h5 = o3[c3], d5 = a2[h5.start][e], u3 = a2[h5.end][e];
    if (lt(n3, d5, u3)) {
      r = n3 === d5, l4 = n3 === u3;
      break;
    }
  }
  return { first: r, last: l4, point: s2 };
}
function Fl(i4) {
  let { chart: t, fill: e, line: s2 } = i4;
  if (V3(e))
    return Bl(t, e);
  if (e === "stack")
    return Rl(i4);
  if (e === "shape")
    return true;
  let n3 = Vl(i4);
  return n3 instanceof Qe ? n3 : yo(n3, s2);
}
function Bl(i4, t) {
  let e = i4.getDatasetMeta(t);
  return e && i4.isDatasetVisible(t) ? e.dataset : null;
}
function Vl(i4) {
  return (i4.scale || {}).getPointPositionForValue ? Nl(i4) : Wl(i4);
}
function Wl(i4) {
  let { scale: t = {}, fill: e } = i4, s2 = Al(e, t);
  if (V3(s2)) {
    let n3 = t.isHorizontal();
    return { x: n3 ? s2 : null, y: n3 ? null : s2 };
  }
  return null;
}
function Nl(i4) {
  let { scale: t, fill: e } = i4, s2 = t.options, n3 = t.getLabels().length, o3 = s2.reverse ? t.max : t.min, a2 = Ll(e, t, o3), r = [];
  if (s2.grid.circular) {
    let l4 = t.getPointPositionForValue(0, o3);
    return new Qe({ x: l4.x, y: l4.y, radius: t.getDistanceFromCenterForValue(a2) });
  }
  for (let l4 = 0; l4 < n3; ++l4)
    r.push(t.getPointPositionForValue(l4, a2));
  return r;
}
function Wi(i4, t, e) {
  let s2 = Fl(t), { line: n3, scale: o3, axis: a2 } = t, r = n3.options, l4 = r.fill, c3 = r.backgroundColor, { above: h5 = c3, below: d5 = c3 } = l4 || {};
  s2 && n3.points.length && (ne2(i4, e), Hl(i4, { line: n3, target: s2, above: h5, below: d5, area: e, scale: o3, axis: a2 }), oe(i4));
}
function Hl(i4, t) {
  let { line: e, target: s2, above: n3, below: o3, area: a2, scale: r } = t, l4 = e._loop ? "angle" : t.axis;
  i4.save(), l4 === "x" && o3 !== n3 && (Bn(i4, s2, a2.top), Vn(i4, { line: e, target: s2, color: n3, scale: r, property: l4 }), i4.restore(), i4.save(), Bn(i4, s2, a2.bottom)), Vn(i4, { line: e, target: s2, color: o3, scale: r, property: l4 }), i4.restore();
}
function Bn(i4, t, e) {
  let { segments: s2, points: n3 } = t, o3 = true, a2 = false;
  i4.beginPath();
  for (let r of s2) {
    let { start: l4, end: c3 } = r, h5 = n3[l4], d5 = n3[ps(l4, c3, n3)];
    o3 ? (i4.moveTo(h5.x, h5.y), o3 = false) : (i4.lineTo(h5.x, e), i4.lineTo(h5.x, h5.y)), a2 = !!t.pathSegment(i4, r, { move: a2 }), a2 ? i4.closePath() : i4.lineTo(d5.x, e);
  }
  i4.lineTo(t.first().x, e), i4.closePath(), i4.clip();
}
function Vn(i4, t) {
  let { line: e, target: s2, property: n3, color: o3, scale: a2 } = t, r = wl(e, s2, n3);
  for (let { source: l4, target: c3, start: h5, end: d5 } of r) {
    let { style: { backgroundColor: u3 = o3 } = {} } = l4, f4 = s2 !== true;
    i4.save(), i4.fillStyle = u3, jl(i4, a2, f4 && ls(n3, h5, d5)), i4.beginPath();
    let g4 = !!e.pathSegment(i4, l4), p6;
    if (f4) {
      g4 ? i4.closePath() : Wn(i4, s2, d5, n3);
      let m6 = !!s2.pathSegment(i4, c3, { move: g4, reverse: true });
      p6 = g4 && m6, p6 || Wn(i4, s2, h5, n3);
    }
    i4.closePath(), i4.fill(p6 ? "evenodd" : "nonzero"), i4.restore();
  }
}
function jl(i4, t, e) {
  let { top: s2, bottom: n3 } = t.chart.chartArea, { property: o3, start: a2, end: r } = e || {};
  o3 === "x" && (i4.beginPath(), i4.rect(a2, s2, r - a2, n3 - s2), i4.clip());
}
function Wn(i4, t, e, s2) {
  let n3 = t.interpolate(e, s2);
  n3 && i4.lineTo(n3.x, n3.y);
}
function Yl(i4, t, e, s2, n3) {
  let o3 = Xl(s2, i4, t, e), a2 = Kl(n3, s2, t.lineHeight);
  return { itemWidth: o3, itemHeight: a2 };
}
function Xl(i4, t, e, s2) {
  let n3 = i4.text;
  return n3 && typeof n3 != "string" && (n3 = n3.reduce((o3, a2) => o3.length > a2.length ? o3 : a2)), t + e.size / 2 + s2.measureText(n3).width;
}
function Kl(i4, t, e) {
  let s2 = i4;
  return typeof t.text != "string" && (s2 = vo(t, e)), s2;
}
function vo(i4, t) {
  let e = i4.text ? i4.text.length : 0;
  return t * e;
}
function ql(i4, t) {
  return !!((i4 === "mousemove" || i4 === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (i4 === "click" || i4 === "mouseup"));
}
function Jl(i4, t) {
  let e = new pe({ ctx: i4.ctx, options: t, chart: i4 });
  q3.configure(i4, e, t), q3.addBox(i4, e), i4.titleBlock = e;
}
function ct(i4, t) {
  return t && (I3(t) ? Array.prototype.push.apply(i4, t) : i4.push(t)), i4;
}
function bt(i4) {
  return (typeof i4 == "string" || i4 instanceof String) && i4.indexOf(`
`) > -1 ? i4.split(`
`) : i4;
}
function tc(i4, t) {
  let { element: e, datasetIndex: s2, index: n3 } = t, o3 = i4.getDatasetMeta(s2).controller, { label: a2, value: r } = o3.getLabelAndValue(n3);
  return { chart: i4, label: a2, parsed: o3.getParsed(n3), raw: i4.data.datasets[s2].data[n3], formattedValue: r, dataset: o3.getDataset(), dataIndex: n3, datasetIndex: s2, element: e };
}
function Hn(i4, t) {
  let e = i4.chart.ctx, { body: s2, footer: n3, title: o3 } = i4, { boxWidth: a2, boxHeight: r } = t, l4 = j3(t.bodyFont), c3 = j3(t.titleFont), h5 = j3(t.footerFont), d5 = o3.length, u3 = n3.length, f4 = s2.length, g4 = X3(t.padding), p6 = g4.height, m6 = 0, b5 = s2.reduce((y5, x5) => y5 + x5.before.length + x5.lines.length + x5.after.length, 0);
  if (b5 += i4.beforeBody.length + i4.afterBody.length, d5 && (p6 += d5 * c3.lineHeight + (d5 - 1) * t.titleSpacing + t.titleMarginBottom), b5) {
    let y5 = t.displayColors ? Math.max(r, l4.lineHeight) : l4.lineHeight;
    p6 += f4 * y5 + (b5 - f4) * l4.lineHeight + (b5 - 1) * t.bodySpacing;
  }
  u3 && (p6 += t.footerMarginTop + u3 * h5.lineHeight + (u3 - 1) * t.footerSpacing);
  let _5 = 0, v5 = function(y5) {
    m6 = Math.max(m6, e.measureText(y5).width + _5);
  };
  return e.save(), e.font = c3.string, T3(i4.title, v5), e.font = l4.string, T3(i4.beforeBody.concat(i4.afterBody), v5), _5 = t.displayColors ? a2 + 2 + t.boxPadding : 0, T3(s2, (y5) => {
    T3(y5.before, v5), T3(y5.lines, v5), T3(y5.after, v5);
  }), _5 = 0, e.font = h5.string, T3(i4.footer, v5), e.restore(), m6 += g4.width, { width: m6, height: p6 };
}
function ec(i4, t) {
  let { y: e, height: s2 } = t;
  return e < s2 / 2 ? "top" : e > i4.height - s2 / 2 ? "bottom" : "center";
}
function ic(i4, t, e, s2) {
  let { x: n3, width: o3 } = s2, a2 = e.caretSize + e.caretPadding;
  if (i4 === "left" && n3 + o3 + a2 > t.width || i4 === "right" && n3 - o3 - a2 < 0)
    return true;
}
function sc(i4, t, e, s2) {
  let { x: n3, width: o3 } = e, { width: a2, chartArea: { left: r, right: l4 } } = i4, c3 = "center";
  return s2 === "center" ? c3 = n3 <= (r + l4) / 2 ? "left" : "right" : n3 <= o3 / 2 ? c3 = "left" : n3 >= a2 - o3 / 2 && (c3 = "right"), ic(c3, i4, t, e) && (c3 = "center"), c3;
}
function jn(i4, t, e) {
  let s2 = e.yAlign || t.yAlign || ec(i4, e);
  return { xAlign: e.xAlign || t.xAlign || sc(i4, t, e, s2), yAlign: s2 };
}
function nc(i4, t) {
  let { x: e, width: s2 } = i4;
  return t === "right" ? e -= s2 : t === "center" && (e -= s2 / 2), e;
}
function oc(i4, t, e) {
  let { y: s2, height: n3 } = i4;
  return t === "top" ? s2 += e : t === "bottom" ? s2 -= n3 + e : s2 -= n3 / 2, s2;
}
function $n(i4, t, e, s2) {
  let { caretSize: n3, caretPadding: o3, cornerRadius: a2 } = i4, { xAlign: r, yAlign: l4 } = e, c3 = n3 + o3, { topLeft: h5, topRight: d5, bottomLeft: u3, bottomRight: f4 } = Mt(a2), g4 = nc(t, r), p6 = oc(t, l4, c3);
  return l4 === "center" ? r === "left" ? g4 += c3 : r === "right" && (g4 -= c3) : r === "left" ? g4 -= Math.max(h5, u3) + n3 : r === "right" && (g4 += Math.max(d5, f4) + n3), { x: $3(g4, 0, s2.width - t.width), y: $3(p6, 0, s2.height - t.height) };
}
function je(i4, t, e) {
  let s2 = X3(e.padding);
  return t === "center" ? i4.x + i4.width / 2 : t === "right" ? i4.x + i4.width - s2.right : i4.x + s2.left;
}
function Un(i4) {
  return ct([], bt(i4));
}
function ac(i4, t, e) {
  return pt(i4, { tooltip: t, tooltipItems: e, type: "tooltip" });
}
function Yn(i4, t) {
  let e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return e ? i4.override(e) : i4;
}
function Q3(i4, t, e, s2) {
  let n3 = i4[t].call(e, s2);
  return typeof n3 > "u" ? Mo[t].call(e, s2) : n3;
}
function hc(i4, t, e, s2) {
  let n3 = i4.indexOf(t);
  if (n3 === -1)
    return cc(i4, t, e, s2);
  let o3 = i4.lastIndexOf(t);
  return n3 !== o3 ? e : n3;
}
function Xn(i4) {
  let t = this.getLabels();
  return i4 >= 0 && i4 < t.length ? t[i4] : i4;
}
function uc(i4, t) {
  let e = [], { bounds: n3, step: o3, min: a2, max: r, precision: l4, count: c3, maxTicks: h5, maxDigits: d5, includeBounds: u3 } = i4, f4 = o3 || 1, g4 = h5 - 1, { min: p6, max: m6 } = t, b5 = !L3(a2), _5 = !L3(r), v5 = !L3(c3), y5 = (m6 - p6) / (d5 + 1), x5 = ri((m6 - p6) / g4 / f4) * f4, M5, k4, S6, w4;
  if (x5 < 1e-14 && !b5 && !_5)
    return [{ value: p6 }, { value: m6 }];
  w4 = Math.ceil(m6 / x5) - Math.floor(p6 / x5), w4 > g4 && (x5 = ri(w4 * x5 / g4 / f4) * f4), L3(l4) || (M5 = Math.pow(10, l4), x5 = Math.ceil(x5 * M5) / M5), n3 === "ticks" ? (k4 = Math.floor(p6 / x5) * x5, S6 = Math.ceil(m6 / x5) * x5) : (k4 = p6, S6 = m6), b5 && _5 && o3 && Ts((r - a2) / o3, x5 / 1e3) ? (w4 = Math.round(Math.min((r - a2) / x5, h5)), x5 = (r - a2) / w4, k4 = a2, S6 = r) : v5 ? (k4 = b5 ? a2 : k4, S6 = _5 ? r : S6, w4 = c3 - 1, x5 = (S6 - k4) / w4) : (w4 = (S6 - k4) / x5, Ht(w4, Math.round(w4), x5 / 1e3) ? w4 = Math.round(w4) : w4 = Math.ceil(w4));
  let D5 = Math.max(ci(x5), ci(k4));
  M5 = Math.pow(10, L3(l4) ? D5 : l4), k4 = Math.round(k4 * M5) / M5, S6 = Math.round(S6 * M5) / M5;
  let C5 = 0;
  for (b5 && (u3 && k4 !== a2 ? (e.push({ value: a2 }), k4 < a2 && C5++, Ht(Math.round((k4 + C5 * x5) * M5) / M5, a2, Kn(a2, y5, i4)) && C5++) : k4 < a2 && C5++); C5 < w4; ++C5) {
    let A5 = Math.round((k4 + C5 * x5) * M5) / M5;
    if (_5 && A5 > r)
      break;
    e.push({ value: A5 });
  }
  return _5 && u3 && S6 !== r ? e.length && Ht(e[e.length - 1].value, r, Kn(r, y5, i4)) ? e[e.length - 1].value = r : e.push({ value: r }) : (!_5 || S6 === r) && e.push({ value: S6 }), e;
}
function Kn(i4, t, { horizontal: e, minRotation: s2 }) {
  let n3 = et(s2), o3 = (e ? Math.sin(n3) : Math.cos(n3)) || 1e-3, a2 = 0.75 * t * ("" + i4).length;
  return Math.min(t / o3, a2);
}
function qn(i4) {
  return i4 / Math.pow(10, me(i4)) === 1;
}
function Gn(i4, t, e) {
  let s2 = Math.pow(10, e), n3 = Math.floor(i4 / s2);
  return Math.ceil(t / s2) - n3;
}
function fc(i4, t) {
  let e = t - i4, s2 = me(e);
  for (; Gn(i4, t, s2) > 10; )
    s2++;
  for (; Gn(i4, t, s2) < 10; )
    s2--;
  return Math.min(s2, me(i4));
}
function gc(i4, { min: t, max: e }) {
  t = J3(i4.min, t);
  let s2 = [], n3 = me(t), o3 = fc(t, e), a2 = o3 < 0 ? Math.pow(10, Math.abs(o3)) : 1, r = Math.pow(10, o3), l4 = n3 > o3 ? Math.pow(10, n3) : 0, c3 = Math.round((t - l4) * a2) / a2, h5 = Math.floor((t - l4) / r / 10) * r * 10, d5 = Math.floor((c3 - h5) / Math.pow(10, o3)), u3 = J3(i4.min, Math.round((l4 + h5 + d5 * Math.pow(10, o3)) * a2) / a2);
  for (; u3 < e; )
    s2.push({ value: u3, major: qn(u3), significand: d5 }), d5 >= 10 ? d5 = d5 < 15 ? 15 : 20 : d5++, d5 >= 20 && (o3++, d5 = 2, a2 = o3 >= 0 ? 1 : a2), u3 = Math.round((l4 + h5 + d5 * Math.pow(10, o3)) * a2) / a2;
  let f4 = J3(i4.max, u3);
  return s2.push({ value: f4, major: qn(f4), significand: d5 }), s2;
}
function us(i4) {
  let t = i4.ticks;
  if (t.display && i4.display) {
    let e = X3(t.backdropPadding);
    return P3(t.font && t.font.size, W3.font.size) + e.height;
  }
  return 0;
}
function pc(i4, t, e) {
  return e = I3(e) ? e : [e], { w: Ns(i4, t.string, e), h: e.length * t.lineHeight };
}
function Jn(i4, t, e, s2, n3) {
  return i4 === s2 || i4 === n3 ? { start: t - e / 2, end: t + e / 2 } : i4 < s2 || i4 > n3 ? { start: t - e, end: t } : { start: t, end: t + e };
}
function mc(i4) {
  let t = { l: i4.left + i4._padding.left, r: i4.right - i4._padding.right, t: i4.top + i4._padding.top, b: i4.bottom - i4._padding.bottom }, e = Object.assign({}, t), s2 = [], n3 = [], o3 = i4._pointLabels.length, a2 = i4.options.pointLabels, r = a2.centerPointLabels ? z2 / o3 : 0;
  for (let l4 = 0; l4 < o3; l4++) {
    let c3 = a2.setContext(i4.getPointLabelContext(l4));
    n3[l4] = c3.padding;
    let h5 = i4.getPointPosition(l4, i4.drawingArea + n3[l4], r), d5 = j3(c3.font), u3 = pc(i4.ctx, d5, i4._pointLabels[l4]);
    s2[l4] = u3;
    let f4 = G3(i4.getIndexAngle(l4) + r), g4 = Math.round(Ce(f4)), p6 = Jn(g4, h5.x, u3.w, 0, 180), m6 = Jn(g4, h5.y, u3.h, 90, 270);
    bc(e, t, f4, p6, m6);
  }
  i4.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), i4._pointLabelItems = yc(i4, s2, n3);
}
function bc(i4, t, e, s2, n3) {
  let o3 = Math.abs(Math.sin(e)), a2 = Math.abs(Math.cos(e)), r = 0, l4 = 0;
  s2.start < t.l ? (r = (t.l - s2.start) / o3, i4.l = Math.min(i4.l, t.l - r)) : s2.end > t.r && (r = (s2.end - t.r) / o3, i4.r = Math.max(i4.r, t.r + r)), n3.start < t.t ? (l4 = (t.t - n3.start) / a2, i4.t = Math.min(i4.t, t.t - l4)) : n3.end > t.b && (l4 = (n3.end - t.b) / a2, i4.b = Math.max(i4.b, t.b + l4));
}
function _c(i4, t, e) {
  let s2 = i4.drawingArea, { extra: n3, additionalAngle: o3, padding: a2, size: r } = e, l4 = i4.getPointPosition(t, s2 + n3 + a2, o3), c3 = Math.round(Ce(G3(l4.angle + N3))), h5 = kc(l4.y, r.h, c3), d5 = vc(c3), u3 = Mc(l4.x, r.w, d5);
  return { visible: true, x: l4.x, y: h5, textAlign: d5, left: u3, top: h5, right: u3 + r.w, bottom: h5 + r.h };
}
function xc(i4, t) {
  if (!t)
    return true;
  let { left: e, top: s2, right: n3, bottom: o3 } = i4;
  return !(at({ x: e, y: s2 }, t) || at({ x: e, y: o3 }, t) || at({ x: n3, y: s2 }, t) || at({ x: n3, y: o3 }, t));
}
function yc(i4, t, e) {
  let s2 = [], n3 = i4._pointLabels.length, o3 = i4.options, { centerPointLabels: a2, display: r } = o3.pointLabels, l4 = { extra: us(o3) / 2, additionalAngle: a2 ? z2 / n3 : 0 }, c3;
  for (let h5 = 0; h5 < n3; h5++) {
    l4.padding = e[h5], l4.size = t[h5];
    let d5 = _c(i4, h5, l4);
    s2.push(d5), r === "auto" && (d5.visible = xc(d5, c3), d5.visible && (c3 = d5));
  }
  return s2;
}
function vc(i4) {
  return i4 === 0 || i4 === 180 ? "center" : i4 < 180 ? "left" : "right";
}
function Mc(i4, t, e) {
  return e === "right" ? i4 -= t : e === "center" && (i4 -= t / 2), i4;
}
function kc(i4, t, e) {
  return e === 90 || e === 270 ? i4 -= t / 2 : (e > 270 || e < 90) && (i4 -= t), i4;
}
function Sc(i4, t, e) {
  let { left: s2, top: n3, right: o3, bottom: a2 } = e, { backdropColor: r } = t;
  if (!L3(r)) {
    let l4 = Mt(t.borderRadius), c3 = X3(t.backdropPadding);
    i4.fillStyle = r;
    let h5 = s2 - c3.left, d5 = n3 - c3.top, u3 = o3 - s2 + c3.width, f4 = a2 - n3 + c3.height;
    Object.values(l4).some((g4) => g4 !== 0) ? (i4.beginPath(), Ut(i4, { x: h5, y: d5, w: u3, h: f4, radius: l4 }), i4.fill()) : i4.fillRect(h5, d5, u3, f4);
  }
}
function wc(i4, t) {
  let { ctx: e, options: { pointLabels: s2 } } = i4;
  for (let n3 = t - 1; n3 >= 0; n3--) {
    let o3 = i4._pointLabelItems[n3];
    if (!o3.visible)
      continue;
    let a2 = s2.setContext(i4.getPointLabelContext(n3));
    Sc(e, a2, o3);
    let r = j3(a2.font), { x: l4, y: c3, textAlign: h5 } = o3;
    vt(e, i4._pointLabels[n3], l4, c3 + r.lineHeight / 2, r, { color: a2.color, textAlign: h5, textBaseline: "middle" });
  }
}
function ko(i4, t, e, s2) {
  let { ctx: n3 } = i4;
  if (e)
    n3.arc(i4.xCenter, i4.yCenter, t, 0, F3);
  else {
    let o3 = i4.getPointPosition(0, t);
    n3.moveTo(o3.x, o3.y);
    for (let a2 = 1; a2 < s2; a2++)
      o3 = i4.getPointPosition(a2, t), n3.lineTo(o3.x, o3.y);
  }
}
function Pc(i4, t, e, s2, n3) {
  let o3 = i4.ctx, a2 = t.circular, { color: r, lineWidth: l4 } = t;
  !a2 && !s2 || !r || !l4 || e < 0 || (o3.save(), o3.strokeStyle = r, o3.lineWidth = l4, o3.setLineDash(n3.dash), o3.lineDashOffset = n3.dashOffset, o3.beginPath(), ko(i4, e, a2, s2), o3.closePath(), o3.stroke(), o3.restore());
}
function Dc(i4, t, e) {
  return pt(i4, { label: e, index: t, type: "pointLabel" });
}
function Qn(i4, t) {
  return i4 - t;
}
function Zn(i4, t) {
  if (L3(t))
    return null;
  let e = i4._adapter, { parser: s2, round: n3, isoWeekday: o3 } = i4._parseOpts, a2 = t;
  return typeof s2 == "function" && (a2 = s2(a2)), V3(a2) || (a2 = typeof s2 == "string" ? e.parse(a2, s2) : e.parse(a2)), a2 === null ? null : (n3 && (a2 = n3 === "week" && (At(o3) || o3 === true) ? e.startOf(a2, "isoWeek", o3) : e.startOf(a2, n3)), +a2);
}
function to(i4, t, e, s2) {
  let n3 = Z3.length;
  for (let o3 = Z3.indexOf(i4); o3 < n3 - 1; ++o3) {
    let a2 = ei[Z3[o3]], r = a2.steps ? a2.steps : Number.MAX_SAFE_INTEGER;
    if (a2.common && Math.ceil((e - t) / (r * a2.size)) <= s2)
      return Z3[o3];
  }
  return Z3[n3 - 1];
}
function Cc(i4, t, e, s2, n3) {
  for (let o3 = Z3.length - 1; o3 >= Z3.indexOf(e); o3--) {
    let a2 = Z3[o3];
    if (ei[a2].common && i4._adapter.diff(n3, s2, a2) >= t - 1)
      return a2;
  }
  return Z3[e ? Z3.indexOf(e) : 0];
}
function Oc(i4) {
  for (let t = Z3.indexOf(i4) + 1, e = Z3.length; t < e; ++t)
    if (ei[Z3[t]].common)
      return Z3[t];
}
function eo(i4, t, e) {
  if (!e)
    i4[t] = true;
  else if (e.length) {
    let { lo: s2, hi: n3 } = Oe(e, t), o3 = e[s2] >= t ? e[s2] : e[n3];
    i4[o3] = true;
  }
}
function Ac(i4, t, e, s2) {
  let n3 = i4._adapter, o3 = +n3.startOf(t[0].value, s2), a2 = t[t.length - 1].value, r, l4;
  for (r = o3; r <= a2; r = +n3.add(r, 1, s2))
    l4 = e[r], l4 >= 0 && (t[l4].major = true);
  return t;
}
function io(i4, t, e) {
  let s2 = [], n3 = {}, o3 = t.length, a2, r;
  for (a2 = 0; a2 < o3; ++a2)
    r = t[a2], n3[r] = a2, s2.push({ value: r, major: false });
  return o3 === 0 || !e ? s2 : Ac(i4, s2, n3, e);
}
function $e(i4, t, e) {
  let s2 = 0, n3 = i4.length - 1, o3, a2, r, l4;
  e ? (t >= i4[s2].pos && t <= i4[n3].pos && ({ lo: s2, hi: n3 } = ot(i4, "pos", t)), { pos: o3, time: r } = i4[s2], { pos: a2, time: l4 } = i4[n3]) : (t >= i4[s2].time && t <= i4[n3].time && ({ lo: s2, hi: n3 } = ot(i4, "time", t)), { time: o3, pos: r } = i4[s2], { time: a2, pos: l4 } = i4[n3]);
  let c3 = a2 - o3;
  return c3 ? r + (l4 - r) * (t - o3) / c3 : r;
}
var Ds, Cs, oi, ms, Nt, ut, ai, z2, F3, Oo, Se, Ao, N3, Dt, bs, ft, st, ot, Es, zs, fi, Ae, Y3, Vs, ye, _s, xs, Ft, To, Ro, ys, Ws, se, xt, Le, ni, W3, jo, $o, Yo, Xo, ki, Jo, ia, Vt, Ks, Fe, ca, ha, Me, Js, fa, ga, Ni, mt, sn, ya, Hi, Xe, Ri, cn, La, dt, ji, $i, fe, Ui, Ke, Yi, Xi, Ki, ja, qi, $a, qa, oo, q3, qe, Gi, Ue, sr, bn, ro, ge, _n, Ji, nt, vr, xn, yn, Et, Kt, Qi, ht, Zi, wn, uo, he, is, Nr, jr, $r, Ye, An, qt, ss, rl, Gt, os, as, gl, rs, Rn, yl, Sl, Qe, $l, Nn, Ul, Ze, Gl, pe, Ql, He, Zl, ue, Mo, ti, rc, lc, cc, dc, cs, Jt, hs, me, Rt, ds, fs, ei, Z3, be, gs, Lc, So, Bc;
var init_auto = __esm({
  "esbuild_serve:http-import:https://esm.sh/v135/chart.js@4.4.2/denonext/auto.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_color();
    init_color();
    Ds = /* @__PURE__ */ (() => {
      let i4 = 0;
      return () => i4++;
    })();
    Cs = (i4, t) => typeof i4 == "string" && i4.endsWith("%") ? parseFloat(i4) / 100 : +i4 / t;
    oi = (i4, t) => typeof i4 == "string" && i4.endsWith("%") ? parseFloat(i4) / 100 * t : +i4;
    ms = { "": (i4) => i4, x: (i4) => i4.x, y: (i4) => i4.y };
    Nt = (i4) => typeof i4 < "u";
    ut = (i4) => typeof i4 == "function";
    ai = (i4, t) => {
      if (i4.size !== t.size)
        return false;
      for (let e of i4)
        if (!t.has(e))
          return false;
      return true;
    };
    z2 = Math.PI;
    F3 = 2 * z2;
    Oo = F3 + z2;
    Se = Number.POSITIVE_INFINITY;
    Ao = z2 / 180;
    N3 = z2 / 2;
    Dt = z2 / 4;
    bs = z2 * 2 / 3;
    ft = Math.log10;
    st = Math.sign;
    ot = (i4, t, e, s2) => Oe(i4, e, s2 ? (n3) => {
      let o3 = i4[n3][t];
      return o3 < e || o3 === e && i4[n3 + 1][t] === e;
    } : (n3) => i4[n3][t] < e);
    Es = (i4, t, e) => Oe(i4, e, (s2) => i4[s2][t] >= e);
    zs = ["push", "pop", "shift", "splice", "unshift"];
    fi = function() {
      return typeof window > "u" ? function(i4) {
        return i4();
      } : window.requestAnimationFrame;
    }();
    Ae = (i4) => i4 === "start" ? "left" : i4 === "end" ? "right" : "center";
    Y3 = (i4, t, e) => i4 === "start" ? t : i4 === "end" ? e : (t + e) / 2;
    Vs = (i4, t, e, s2) => i4 === (s2 ? "left" : "right") ? e : i4 === "center" ? (t + e) / 2 : t;
    ye = (i4) => i4 === 0 || i4 === 1;
    _s = (i4, t, e) => -(Math.pow(2, 10 * (i4 -= 1)) * Math.sin((i4 - t) * F3 / e));
    xs = (i4, t, e) => Math.pow(2, -10 * i4) * Math.sin((i4 - t) * F3 / e) + 1;
    Ft = { linear: (i4) => i4, easeInQuad: (i4) => i4 * i4, easeOutQuad: (i4) => -i4 * (i4 - 2), easeInOutQuad: (i4) => (i4 /= 0.5) < 1 ? 0.5 * i4 * i4 : -0.5 * (--i4 * (i4 - 2) - 1), easeInCubic: (i4) => i4 * i4 * i4, easeOutCubic: (i4) => (i4 -= 1) * i4 * i4 + 1, easeInOutCubic: (i4) => (i4 /= 0.5) < 1 ? 0.5 * i4 * i4 * i4 : 0.5 * ((i4 -= 2) * i4 * i4 + 2), easeInQuart: (i4) => i4 * i4 * i4 * i4, easeOutQuart: (i4) => -((i4 -= 1) * i4 * i4 * i4 - 1), easeInOutQuart: (i4) => (i4 /= 0.5) < 1 ? 0.5 * i4 * i4 * i4 * i4 : -0.5 * ((i4 -= 2) * i4 * i4 * i4 - 2), easeInQuint: (i4) => i4 * i4 * i4 * i4 * i4, easeOutQuint: (i4) => (i4 -= 1) * i4 * i4 * i4 * i4 + 1, easeInOutQuint: (i4) => (i4 /= 0.5) < 1 ? 0.5 * i4 * i4 * i4 * i4 * i4 : 0.5 * ((i4 -= 2) * i4 * i4 * i4 * i4 + 2), easeInSine: (i4) => -Math.cos(i4 * N3) + 1, easeOutSine: (i4) => Math.sin(i4 * N3), easeInOutSine: (i4) => -0.5 * (Math.cos(z2 * i4) - 1), easeInExpo: (i4) => i4 === 0 ? 0 : Math.pow(2, 10 * (i4 - 1)), easeOutExpo: (i4) => i4 === 1 ? 1 : -Math.pow(2, -10 * i4) + 1, easeInOutExpo: (i4) => ye(i4) ? i4 : i4 < 0.5 ? 0.5 * Math.pow(2, 10 * (i4 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i4 * 2 - 1)) + 2), easeInCirc: (i4) => i4 >= 1 ? i4 : -(Math.sqrt(1 - i4 * i4) - 1), easeOutCirc: (i4) => Math.sqrt(1 - (i4 -= 1) * i4), easeInOutCirc: (i4) => (i4 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i4 * i4) - 1) : 0.5 * (Math.sqrt(1 - (i4 -= 2) * i4) + 1), easeInElastic: (i4) => ye(i4) ? i4 : _s(i4, 0.075, 0.3), easeOutElastic: (i4) => ye(i4) ? i4 : xs(i4, 0.075, 0.3), easeInOutElastic(i4) {
      return ye(i4) ? i4 : i4 < 0.5 ? 0.5 * _s(i4 * 2, 0.1125, 0.45) : 0.5 + 0.5 * xs(i4 * 2 - 1, 0.1125, 0.45);
    }, easeInBack(i4) {
      return i4 * i4 * ((1.70158 + 1) * i4 - 1.70158);
    }, easeOutBack(i4) {
      return (i4 -= 1) * i4 * ((1.70158 + 1) * i4 + 1.70158) + 1;
    }, easeInOutBack(i4) {
      let t = 1.70158;
      return (i4 /= 0.5) < 1 ? 0.5 * (i4 * i4 * (((t *= 1.525) + 1) * i4 - t)) : 0.5 * ((i4 -= 2) * i4 * (((t *= 1.525) + 1) * i4 + t) + 2);
    }, easeInBounce: (i4) => 1 - Ft.easeOutBounce(1 - i4), easeOutBounce(i4) {
      return i4 < 1 / 2.75 ? 7.5625 * i4 * i4 : i4 < 2 / 2.75 ? 7.5625 * (i4 -= 1.5 / 2.75) * i4 + 0.75 : i4 < 2.5 / 2.75 ? 7.5625 * (i4 -= 2.25 / 2.75) * i4 + 0.9375 : 7.5625 * (i4 -= 2.625 / 2.75) * i4 + 0.984375;
    }, easeInOutBounce: (i4) => i4 < 0.5 ? Ft.easeInBounce(i4 * 2) * 0.5 : Ft.easeOutBounce(i4 * 2 - 1) * 0.5 + 0.5 };
    To = ["x", "y", "borderWidth", "radius", "tension"];
    Ro = ["color", "borderColor", "backgroundColor"];
    ys = /* @__PURE__ */ new Map();
    Ws = { values(i4) {
      return I3(i4) ? i4 : "" + i4;
    }, numeric(i4, t, e) {
      if (i4 === 0)
        return "0";
      let s2 = this.chart.options.locale, n3, o3 = i4;
      if (e.length > 1) {
        let c3 = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));
        (c3 < 1e-4 || c3 > 1e15) && (n3 = "scientific"), o3 = Fo(i4, e);
      }
      let a2 = ft(Math.abs(o3)), r = isNaN(a2) ? 1 : Math.max(Math.min(-1 * Math.floor(a2), 20), 0), l4 = { notation: n3, minimumFractionDigits: r, maximumFractionDigits: r };
      return Object.assign(l4, this.options.ticks.format), $t(i4, s2, l4);
    }, logarithmic(i4, t, e) {
      if (i4 === 0)
        return "0";
      let s2 = e[t].significand || i4 / Math.pow(10, Math.floor(ft(i4)));
      return [1, 2, 3, 5, 10, 15].includes(s2) || t > 0.8 * e.length ? Ws.numeric.call(this, i4, t, e) : "";
    } };
    se = { formatters: Ws };
    xt = /* @__PURE__ */ Object.create(null);
    Le = /* @__PURE__ */ Object.create(null);
    ni = class {
      constructor(t, e) {
        this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (s2) => s2.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (s2, n3) => ii(n3.backgroundColor), this.hoverBorderColor = (s2, n3) => ii(n3.borderColor), this.hoverColor = (s2, n3) => ii(n3.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: true, includeInvisible: false }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(t), this.apply(e);
      }
      set(t, e) {
        return si(this, t, e);
      }
      get(t) {
        return te(this, t);
      }
      describe(t, e) {
        return si(Le, t, e);
      }
      override(t, e) {
        return si(xt, t, e);
      }
      route(t, e, s2, n3) {
        let o3 = te(this, t), a2 = te(this, s2), r = "_" + e;
        Object.defineProperties(o3, { [r]: { value: o3[e], writable: true }, [e]: { enumerable: true, get() {
          let l4 = this[r], c3 = a2[n3];
          return O3(l4) ? Object.assign({}, c3, l4) : P3(l4, c3);
        }, set(l4) {
          this[r] = l4;
        } } });
      }
      apply(t) {
        t.forEach((e) => e(this));
      }
    };
    W3 = new ni({ _scriptable: (i4) => !i4.startsWith("on"), _indexable: (i4) => i4 !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: false, _indexable: false } }, [Eo, Io, Bo]);
    jo = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
    $o = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
    Yo = (i4) => +i4 || 0;
    Xo = (i4, t) => i4 ? i4 + De(t) : t;
    ki = (i4, t) => O3(t) && i4 !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
    Jo = (i4, t) => i4 === true ? t : typeof i4 == "string" ? gt(t, i4) : void 0;
    ia = Number.EPSILON || 1e-14;
    Vt = (i4, t) => t < i4.length && !i4[t].skip && i4[t];
    Ks = (i4) => i4 === "x" ? "y" : "x";
    Fe = (i4) => i4.ownerDocument.defaultView.getComputedStyle(i4, null);
    ca = ["top", "right", "bottom", "left"];
    ha = (i4, t, e) => (i4 > 0 || t > 0) && (!e || !e.shadowRoot);
    Me = (i4) => Math.round(i4 * 10) / 10;
    Js = function() {
      let i4 = false;
      try {
        let t = { get passive() {
          return i4 = true, false;
        } };
        Ie() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
      } catch {
      }
      return i4;
    }();
    fa = function(i4, t) {
      return { x(e) {
        return i4 + i4 + t - e;
      }, setWidth(e) {
        t = e;
      }, textAlign(e) {
        return e === "center" ? e : e === "right" ? "left" : "right";
      }, xPlus(e, s2) {
        return e - s2;
      }, leftForLtr(e, s2) {
        return e - s2;
      } };
    };
    ga = function() {
      return { x(i4) {
        return i4;
      }, setWidth(i4) {
      }, textAlign(i4) {
        return i4;
      }, xPlus(i4, t) {
        return i4 + t;
      }, leftForLtr(i4, t) {
        return i4;
      } };
    };
    Ni = class {
      constructor() {
        this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
      }
      _notify(t, e, s2, n3) {
        let o3 = e.listeners[n3], a2 = e.duration;
        o3.forEach((r) => r({ chart: t, initial: e.initial, numSteps: a2, currentStep: Math.min(s2 - e.start, a2) }));
      }
      _refresh() {
        this._request || (this._running = true, this._request = fi.call(window, () => {
          this._update(), this._request = null, this._running && this._refresh();
        }));
      }
      _update(t = Date.now()) {
        let e = 0;
        this._charts.forEach((s2, n3) => {
          if (!s2.running || !s2.items.length)
            return;
          let o3 = s2.items, a2 = o3.length - 1, r = false, l4;
          for (; a2 >= 0; --a2)
            l4 = o3[a2], l4._active ? (l4._total > s2.duration && (s2.duration = l4._total), l4.tick(t), r = true) : (o3[a2] = o3[o3.length - 1], o3.pop());
          r && (n3.draw(), this._notify(n3, s2, t, "progress")), o3.length || (s2.running = false, this._notify(n3, s2, t, "complete"), s2.initial = false), e += o3.length;
        }), this._lastDate = t, e === 0 && (this._running = false);
      }
      _getAnims(t) {
        let e = this._charts, s2 = e.get(t);
        return s2 || (s2 = { running: false, initial: true, items: [], listeners: { complete: [], progress: [] } }, e.set(t, s2)), s2;
      }
      listen(t, e, s2) {
        this._getAnims(t).listeners[e].push(s2);
      }
      add(t, e) {
        !e || !e.length || this._getAnims(t).items.push(...e);
      }
      has(t) {
        return this._getAnims(t).items.length > 0;
      }
      start(t) {
        let e = this._charts.get(t);
        e && (e.running = true, e.start = Date.now(), e.duration = e.items.reduce((s2, n3) => Math.max(s2, n3._duration), 0), this._refresh());
      }
      running(t) {
        if (!this._running)
          return false;
        let e = this._charts.get(t);
        return !(!e || !e.running || !e.items.length);
      }
      stop(t) {
        let e = this._charts.get(t);
        if (!e || !e.items.length)
          return;
        let s2 = e.items, n3 = s2.length - 1;
        for (; n3 >= 0; --n3)
          s2[n3].cancel();
        e.items = [], this._notify(t, e, Date.now(), "complete");
      }
      remove(t) {
        return this._charts.delete(t);
      }
    };
    mt = new Ni();
    sn = "transparent";
    ya = { boolean(i4, t, e) {
      return e > 0.5 ? t : i4;
    }, color(i4, t, e) {
      let s2 = _i(i4 || sn), n3 = s2.valid && _i(t || sn);
      return n3 && n3.valid ? n3.mix(s2, e).hexString() : t;
    }, number(i4, t, e) {
      return i4 + (t - i4) * e;
    } };
    Hi = class {
      constructor(t, e, s2, n3) {
        let o3 = e[s2];
        n3 = Yt([t.to, n3, o3, t.from]);
        let a2 = Yt([t.from, o3, n3]);
        this._active = true, this._fn = t.fn || ya[t.type || typeof a2], this._easing = Ft[t.easing] || Ft.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s2, this._from = a2, this._to = n3, this._promises = void 0;
      }
      active() {
        return this._active;
      }
      update(t, e, s2) {
        if (this._active) {
          this._notify(false);
          let n3 = this._target[this._prop], o3 = s2 - this._start, a2 = this._duration - o3;
          this._start = s2, this._duration = Math.floor(Math.max(a2, t.duration)), this._total += o3, this._loop = !!t.loop, this._to = Yt([t.to, e, n3, t.from]), this._from = Yt([t.from, n3, e]);
        }
      }
      cancel() {
        this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
      }
      tick(t) {
        let e = t - this._start, s2 = this._duration, n3 = this._prop, o3 = this._from, a2 = this._loop, r = this._to, l4;
        if (this._active = o3 !== r && (a2 || e < s2), !this._active) {
          this._target[n3] = r, this._notify(true);
          return;
        }
        if (e < 0) {
          this._target[n3] = o3;
          return;
        }
        l4 = e / s2 % 2, l4 = a2 && l4 > 1 ? 2 - l4 : l4, l4 = this._easing(Math.min(1, Math.max(0, l4))), this._target[n3] = this._fn(o3, r, l4);
      }
      wait() {
        let t = this._promises || (this._promises = []);
        return new Promise((e, s2) => {
          t.push({ res: e, rej: s2 });
        });
      }
      _notify(t) {
        let e = t ? "res" : "rej", s2 = this._promises || [];
        for (let n3 = 0; n3 < s2.length; n3++)
          s2[n3][e]();
      }
    };
    Xe = class {
      constructor(t, e) {
        this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);
      }
      configure(t) {
        if (!O3(t))
          return;
        let e = Object.keys(W3.animation), s2 = this._properties;
        Object.getOwnPropertyNames(t).forEach((n3) => {
          let o3 = t[n3];
          if (!O3(o3))
            return;
          let a2 = {};
          for (let r of e)
            a2[r] = o3[r];
          (I3(o3.properties) && o3.properties || [n3]).forEach((r) => {
            (r === n3 || !s2.has(r)) && s2.set(r, a2);
          });
        });
      }
      _animateOptions(t, e) {
        let s2 = e.options, n3 = Ma(t, s2);
        if (!n3)
          return [];
        let o3 = this._createAnimations(n3, s2);
        return s2.$shared && va(t.options.$animations, s2).then(() => {
          t.options = s2;
        }, () => {
        }), o3;
      }
      _createAnimations(t, e) {
        let s2 = this._properties, n3 = [], o3 = t.$animations || (t.$animations = {}), a2 = Object.keys(e), r = Date.now(), l4;
        for (l4 = a2.length - 1; l4 >= 0; --l4) {
          let c3 = a2[l4];
          if (c3.charAt(0) === "$")
            continue;
          if (c3 === "options") {
            n3.push(...this._animateOptions(t, e));
            continue;
          }
          let h5 = e[c3], d5 = o3[c3], u3 = s2.get(c3);
          if (d5)
            if (u3 && d5.active()) {
              d5.update(u3, h5, r);
              continue;
            } else
              d5.cancel();
          if (!u3 || !u3.duration) {
            t[c3] = h5;
            continue;
          }
          o3[c3] = d5 = new Hi(u3, t, c3, h5), n3.push(d5);
        }
        return n3;
      }
      update(t, e) {
        if (this._properties.size === 0) {
          Object.assign(t, e);
          return;
        }
        let s2 = this._createAnimations(t, e);
        if (s2.length)
          return mt.add(this._chart, s2), true;
      }
    };
    Ri = (i4) => i4 === "reset" || i4 === "none";
    cn = (i4, t) => t ? i4 : Object.assign({}, i4);
    La = (i4, t, e) => i4 && !t.hidden && t._stacked && { keys: so(e, true), values: null };
    dt = class {
      static defaults = {};
      static datasetElementType = null;
      static dataElementType = null;
      constructor(t, e) {
        this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
      }
      initialize() {
        let t = this._cachedMeta;
        this.configure(), this.linkScales(), t._stacked = an(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
      updateIndex(t) {
        this.index !== t && ae(this._cachedMeta), this.index = t;
      }
      linkScales() {
        let t = this.chart, e = this._cachedMeta, s2 = this.getDataset(), n3 = (d5, u3, f4, g4) => d5 === "x" ? u3 : d5 === "r" ? g4 : f4, o3 = e.xAxisID = P3(s2.xAxisID, Ti(t, "x")), a2 = e.yAxisID = P3(s2.yAxisID, Ti(t, "y")), r = e.rAxisID = P3(s2.rAxisID, Ti(t, "r")), l4 = e.indexAxis, c3 = e.iAxisID = n3(l4, o3, a2, r), h5 = e.vAxisID = n3(l4, a2, o3, r);
        e.xScale = this.getScaleForId(o3), e.yScale = this.getScaleForId(a2), e.rScale = this.getScaleForId(r), e.iScale = this.getScaleForId(c3), e.vScale = this.getScaleForId(h5);
      }
      getDataset() {
        return this.chart.data.datasets[this.index];
      }
      getMeta() {
        return this.chart.getDatasetMeta(this.index);
      }
      getScaleForId(t) {
        return this.chart.scales[t];
      }
      _getOtherScale(t) {
        let e = this._cachedMeta;
        return t === e.iScale ? e.vScale : e.iScale;
      }
      reset() {
        this._update("reset");
      }
      _destroy() {
        let t = this._cachedMeta;
        this._data && di(this._data, this), t._stacked && ae(t);
      }
      _dataCheck() {
        let t = this.getDataset(), e = t.data || (t.data = []), s2 = this._data;
        if (O3(e))
          this._data = wa(e);
        else if (s2 !== e) {
          if (s2) {
            di(s2, this);
            let n3 = this._cachedMeta;
            ae(n3), n3._parsed = [];
          }
          e && Object.isExtensible(e) && Fs(e, this), this._syncList = [], this._data = e;
        }
      }
      addElements() {
        let t = this._cachedMeta;
        this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
      }
      buildOrUpdateElements(t) {
        let e = this._cachedMeta, s2 = this.getDataset(), n3 = false;
        this._dataCheck();
        let o3 = e._stacked;
        e._stacked = an(e.vScale, e), e.stack !== s2.stack && (n3 = true, ae(e), e.stack = s2.stack), this._resyncElements(t), (n3 || o3 !== e._stacked) && ln(this, e._parsed);
      }
      configure() {
        let t = this.chart.config, e = t.datasetScopeKeys(this._type), s2 = t.getOptionScopes(this.getDataset(), e, true);
        this.options = t.createResolver(s2, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
      }
      parse(t, e) {
        let { _cachedMeta: s2, _data: n3 } = this, { iScale: o3, _stacked: a2 } = s2, r = o3.axis, l4 = t === 0 && e === n3.length ? true : s2._sorted, c3 = t > 0 && s2._parsed[t - 1], h5, d5, u3;
        if (this._parsing === false)
          s2._parsed = n3, s2._sorted = true, u3 = n3;
        else {
          I3(n3[t]) ? u3 = this.parseArrayData(s2, n3, t, e) : O3(n3[t]) ? u3 = this.parseObjectData(s2, n3, t, e) : u3 = this.parsePrimitiveData(s2, n3, t, e);
          let f4 = () => d5[r] === null || c3 && d5[r] < c3[r];
          for (h5 = 0; h5 < e; ++h5)
            s2._parsed[h5 + t] = d5 = u3[h5], l4 && (f4() && (l4 = false), c3 = d5);
          s2._sorted = l4;
        }
        a2 && ln(this, u3);
      }
      parsePrimitiveData(t, e, s2, n3) {
        let { iScale: o3, vScale: a2 } = t, r = o3.axis, l4 = a2.axis, c3 = o3.getLabels(), h5 = o3 === a2, d5 = new Array(n3), u3, f4, g4;
        for (u3 = 0, f4 = n3; u3 < f4; ++u3)
          g4 = u3 + s2, d5[u3] = { [r]: h5 || o3.parse(c3[g4], g4), [l4]: a2.parse(e[g4], g4) };
        return d5;
      }
      parseArrayData(t, e, s2, n3) {
        let { xScale: o3, yScale: a2 } = t, r = new Array(n3), l4, c3, h5, d5;
        for (l4 = 0, c3 = n3; l4 < c3; ++l4)
          h5 = l4 + s2, d5 = e[h5], r[l4] = { x: o3.parse(d5[0], h5), y: a2.parse(d5[1], h5) };
        return r;
      }
      parseObjectData(t, e, s2, n3) {
        let { xScale: o3, yScale: a2 } = t, { xAxisKey: r = "x", yAxisKey: l4 = "y" } = this._parsing, c3 = new Array(n3), h5, d5, u3, f4;
        for (h5 = 0, d5 = n3; h5 < d5; ++h5)
          u3 = h5 + s2, f4 = e[u3], c3[h5] = { x: o3.parse(gt(f4, r), u3), y: a2.parse(gt(f4, l4), u3) };
        return c3;
      }
      getParsed(t) {
        return this._cachedMeta._parsed[t];
      }
      getDataElement(t) {
        return this._cachedMeta.data[t];
      }
      applyStack(t, e, s2) {
        let n3 = this.chart, o3 = this._cachedMeta, a2 = e[t.axis], r = { keys: so(n3, true), values: e._stacks[t.axis]._visualValues };
        return on(r, a2, o3.index, { mode: s2 });
      }
      updateRangeFromParsed(t, e, s2, n3) {
        let o3 = s2[e.axis], a2 = o3 === null ? NaN : o3, r = n3 && s2._stacks[e.axis];
        n3 && r && (n3.values = r, a2 = on(n3, o3, this._cachedMeta.index)), t.min = Math.min(t.min, a2), t.max = Math.max(t.max, a2);
      }
      getMinMax(t, e) {
        let s2 = this._cachedMeta, n3 = s2._parsed, o3 = s2._sorted && t === s2.iScale, a2 = n3.length, r = this._getOtherScale(t), l4 = La(e, s2, this.chart), c3 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h5, max: d5 } = Da(r), u3, f4;
        function g4() {
          f4 = n3[u3];
          let p6 = f4[r.axis];
          return !V3(f4[t.axis]) || h5 > p6 || d5 < p6;
        }
        for (u3 = 0; u3 < a2 && !(!g4() && (this.updateRangeFromParsed(c3, t, f4, l4), o3)); ++u3)
          ;
        if (o3) {
          for (u3 = a2 - 1; u3 >= 0; --u3)
            if (!g4()) {
              this.updateRangeFromParsed(c3, t, f4, l4);
              break;
            }
        }
        return c3;
      }
      getAllParsedValues(t) {
        let e = this._cachedMeta._parsed, s2 = [], n3, o3, a2;
        for (n3 = 0, o3 = e.length; n3 < o3; ++n3)
          a2 = e[n3][t.axis], V3(a2) && s2.push(a2);
        return s2;
      }
      getMaxOverflow() {
        return false;
      }
      getLabelAndValue(t) {
        let e = this._cachedMeta, s2 = e.iScale, n3 = e.vScale, o3 = this.getParsed(t);
        return { label: s2 ? "" + s2.getLabelForValue(o3[s2.axis]) : "", value: n3 ? "" + n3.getLabelForValue(o3[n3.axis]) : "" };
      }
      _update(t) {
        let e = this._cachedMeta;
        this.update(t || "default"), e._clip = Sa(P3(this.options.clip, ka(e.xScale, e.yScale, this.getMaxOverflow())));
      }
      update(t) {
      }
      draw() {
        let t = this._ctx, e = this.chart, s2 = this._cachedMeta, n3 = s2.data || [], o3 = e.chartArea, a2 = [], r = this._drawStart || 0, l4 = this._drawCount || n3.length - r, c3 = this.options.drawActiveElementsOnTop, h5;
        for (s2.dataset && s2.dataset.draw(t, o3, r, l4), h5 = r; h5 < r + l4; ++h5) {
          let d5 = n3[h5];
          d5.hidden || (d5.active && c3 ? a2.push(d5) : d5.draw(t, o3));
        }
        for (h5 = 0; h5 < a2.length; ++h5)
          a2[h5].draw(t, o3);
      }
      getStyle(t, e) {
        let s2 = e ? "active" : "default";
        return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s2) : this.resolveDataElementOptions(t || 0, s2);
      }
      getContext(t, e, s2) {
        let n3 = this.getDataset(), o3;
        if (t >= 0 && t < this._cachedMeta.data.length) {
          let a2 = this._cachedMeta.data[t];
          o3 = a2.$context || (a2.$context = Aa(this.getContext(), t, a2)), o3.parsed = this.getParsed(t), o3.raw = n3.data[t], o3.index = o3.dataIndex = t;
        } else
          o3 = this.$context || (this.$context = Oa(this.chart.getContext(), this.index)), o3.dataset = n3, o3.index = o3.datasetIndex = this.index;
        return o3.active = !!e, o3.mode = s2, o3;
      }
      resolveDatasetElementOptions(t) {
        return this._resolveElementOptions(this.datasetElementType.id, t);
      }
      resolveDataElementOptions(t, e) {
        return this._resolveElementOptions(this.dataElementType.id, e, t);
      }
      _resolveElementOptions(t, e = "default", s2) {
        let n3 = e === "active", o3 = this._cachedDataOpts, a2 = t + "-" + e, r = o3[a2], l4 = this.enableOptionSharing && Nt(s2);
        if (r)
          return cn(r, l4);
        let c3 = this.chart.config, h5 = c3.datasetElementScopeKeys(this._type, t), d5 = n3 ? [`${t}Hover`, "hover", t, ""] : [t, ""], u3 = c3.getOptionScopes(this.getDataset(), h5), f4 = Object.keys(W3.elements[t]), g4 = () => this.getContext(s2, n3, e), p6 = c3.resolveNamedOptions(u3, f4, g4, d5);
        return p6.$shared && (p6.$shared = l4, o3[a2] = Object.freeze(cn(p6, l4))), p6;
      }
      _resolveAnimations(t, e, s2) {
        let n3 = this.chart, o3 = this._cachedDataOpts, a2 = `animation-${e}`, r = o3[a2];
        if (r)
          return r;
        let l4;
        if (n3.options.animation !== false) {
          let h5 = this.chart.config, d5 = h5.datasetAnimationScopeKeys(this._type, e), u3 = h5.getOptionScopes(this.getDataset(), d5);
          l4 = h5.createResolver(u3, this.getContext(t, s2, e));
        }
        let c3 = new Xe(n3, l4 && l4.animations);
        return l4 && l4._cacheable && (o3[a2] = Object.freeze(c3)), c3;
      }
      getSharedOptions(t) {
        if (t.$shared)
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
      }
      includeOptions(t, e) {
        return !e || Ri(t) || this.chart._animationsDisabled;
      }
      _getSharedOptions(t, e) {
        let s2 = this.resolveDataElementOptions(t, e), n3 = this._sharedOptions, o3 = this.getSharedOptions(s2), a2 = this.includeOptions(e, o3) || o3 !== n3;
        return this.updateSharedOptions(o3, e, s2), { sharedOptions: o3, includeOptions: a2 };
      }
      updateElement(t, e, s2, n3) {
        Ri(n3) ? Object.assign(t, s2) : this._resolveAnimations(e, n3).update(t, s2);
      }
      updateSharedOptions(t, e, s2) {
        t && !Ri(e) && this._resolveAnimations(void 0, e).update(t, s2);
      }
      _setStyle(t, e, s2, n3) {
        t.active = n3;
        let o3 = this.getStyle(e, n3);
        this._resolveAnimations(e, s2, n3).update(t, { options: !n3 && this.getSharedOptions(o3) || o3 });
      }
      removeHoverStyle(t, e, s2) {
        this._setStyle(t, s2, "active", false);
      }
      setHoverStyle(t, e, s2) {
        this._setStyle(t, s2, "active", true);
      }
      _removeDatasetHoverStyle() {
        let t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", false);
      }
      _setDatasetHoverStyle() {
        let t = this._cachedMeta.dataset;
        t && this._setStyle(t, void 0, "active", true);
      }
      _resyncElements(t) {
        let e = this._data, s2 = this._cachedMeta.data;
        for (let [r, l4, c3] of this._syncList)
          this[r](l4, c3);
        this._syncList = [];
        let n3 = s2.length, o3 = e.length, a2 = Math.min(o3, n3);
        a2 && this.parse(0, a2), o3 > n3 ? this._insertElements(n3, o3 - n3, t) : o3 < n3 && this._removeElements(o3, n3 - o3);
      }
      _insertElements(t, e, s2 = true) {
        let n3 = this._cachedMeta, o3 = n3.data, a2 = t + e, r, l4 = (c3) => {
          for (c3.length += e, r = c3.length - 1; r >= a2; r--)
            c3[r] = c3[r - e];
        };
        for (l4(o3), r = t; r < a2; ++r)
          o3[r] = new this.dataElementType();
        this._parsing && l4(n3._parsed), this.parse(t, e), s2 && this.updateElements(o3, t, e, "reset");
      }
      updateElements(t, e, s2, n3) {
      }
      _removeElements(t, e) {
        let s2 = this._cachedMeta;
        if (this._parsing) {
          let n3 = s2._parsed.splice(t, e);
          s2._stacked && ae(s2, n3);
        }
        s2.data.splice(t, e);
      }
      _sync(t) {
        if (this._parsing)
          this._syncList.push(t);
        else {
          let [e, s2, n3] = t;
          this[e](s2, n3);
        }
        this.chart._dataChanges.push([this.index, ...t]);
      }
      _onDataPush() {
        let t = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - t, t]);
      }
      _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
      }
      _onDataShift() {
        this._sync(["_removeElements", 0, 1]);
      }
      _onDataSplice(t, e) {
        e && this._sync(["_removeElements", t, e]);
        let s2 = arguments.length - 2;
        s2 && this._sync(["_insertElements", t, s2]);
      }
      _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length]);
      }
    };
    ji = class extends dt {
      static id = "bar";
      static defaults = { datasetElementType: false, dataElementType: "bar", categoryPercentage: 0.8, barPercentage: 0.9, grouped: true, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } };
      static overrides = { scales: { _index_: { type: "category", offset: true, grid: { offset: true } }, _value_: { type: "linear", beginAtZero: true } } };
      parsePrimitiveData(t, e, s2, n3) {
        return hn(t, e, s2, n3);
      }
      parseArrayData(t, e, s2, n3) {
        return hn(t, e, s2, n3);
      }
      parseObjectData(t, e, s2, n3) {
        let { iScale: o3, vScale: a2 } = t, { xAxisKey: r = "x", yAxisKey: l4 = "y" } = this._parsing, c3 = o3.axis === "x" ? r : l4, h5 = a2.axis === "x" ? r : l4, d5 = [], u3, f4, g4, p6;
        for (u3 = s2, f4 = s2 + n3; u3 < f4; ++u3)
          p6 = e[u3], g4 = {}, g4[o3.axis] = o3.parse(gt(p6, c3), u3), d5.push(no(gt(p6, h5), g4, a2, u3));
        return d5;
      }
      updateRangeFromParsed(t, e, s2, n3) {
        super.updateRangeFromParsed(t, e, s2, n3);
        let o3 = s2._custom;
        o3 && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o3.min), t.max = Math.max(t.max, o3.max));
      }
      getMaxOverflow() {
        return 0;
      }
      getLabelAndValue(t) {
        let e = this._cachedMeta, { iScale: s2, vScale: n3 } = e, o3 = this.getParsed(t), a2 = o3._custom, r = Ei(a2) ? "[" + a2.start + ", " + a2.end + "]" : "" + n3.getLabelForValue(o3[n3.axis]);
        return { label: "" + s2.getLabelForValue(o3[s2.axis]), value: r };
      }
      initialize() {
        this.enableOptionSharing = true, super.initialize();
        let t = this._cachedMeta;
        t.stack = this.getDataset().stack;
      }
      update(t) {
        let e = this._cachedMeta;
        this.updateElements(e.data, 0, e.data.length, t);
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", { index: a2, _cachedMeta: { vScale: r } } = this, l4 = r.getBasePixel(), c3 = r.isHorizontal(), h5 = this._getRuler(), { sharedOptions: d5, includeOptions: u3 } = this._getSharedOptions(e, n3);
        for (let f4 = e; f4 < e + s2; f4++) {
          let g4 = this.getParsed(f4), p6 = o3 || L3(g4[r.axis]) ? { base: l4, head: l4 } : this._calculateBarValuePixels(f4), m6 = this._calculateBarIndexPixels(f4, h5), b5 = (g4._stacks || {})[r.axis], _5 = { horizontal: c3, base: p6.base, enableBorderRadius: !b5 || Ei(g4._custom) || a2 === b5._top || a2 === b5._bottom, x: c3 ? p6.head : m6.center, y: c3 ? m6.center : p6.head, height: c3 ? m6.size : Math.abs(p6.size), width: c3 ? Math.abs(p6.size) : m6.size };
          u3 && (_5.options = d5 || this.resolveDataElementOptions(f4, t[f4].active ? "active" : n3));
          let v5 = _5.options || t[f4].options;
          Va(_5, v5, b5, a2), Na(_5, v5, h5.ratio), this.updateElement(t[f4], f4, _5, n3);
        }
      }
      _getStacks(t, e) {
        let { iScale: s2 } = this._cachedMeta, n3 = s2.getMatchingVisibleMetas(this._type).filter((l4) => l4.controller.options.grouped), o3 = s2.options.stacked, a2 = [], r = (l4) => {
          let c3 = l4.controller.getParsed(e), h5 = c3 && c3[l4.vScale.axis];
          if (L3(h5) || isNaN(h5))
            return true;
        };
        for (let l4 of n3)
          if (!(e !== void 0 && r(l4)) && ((o3 === false || a2.indexOf(l4.stack) === -1 || o3 === void 0 && l4.stack === void 0) && a2.push(l4.stack), l4.index === t))
            break;
        return a2.length || a2.push(void 0), a2;
      }
      _getStackCount(t) {
        return this._getStacks(void 0, t).length;
      }
      _getStackIndex(t, e, s2) {
        let n3 = this._getStacks(t, s2), o3 = e !== void 0 ? n3.indexOf(e) : -1;
        return o3 === -1 ? n3.length - 1 : o3;
      }
      _getRuler() {
        let t = this.options, e = this._cachedMeta, s2 = e.iScale, n3 = [], o3, a2;
        for (o3 = 0, a2 = e.data.length; o3 < a2; ++o3)
          n3.push(s2.getPixelForValue(this.getParsed(o3)[s2.axis], o3));
        let r = t.barThickness;
        return { min: r || Ra(e), pixels: n3, start: s2._startPixel, end: s2._endPixel, stackCount: this._getStackCount(), scale: s2, grouped: t.grouped, ratio: r ? 1 : t.categoryPercentage * t.barPercentage };
      }
      _calculateBarValuePixels(t) {
        let { _cachedMeta: { vScale: e, _stacked: s2, index: n3 }, options: { base: o3, minBarLength: a2 } } = this, r = o3 || 0, l4 = this.getParsed(t), c3 = l4._custom, h5 = Ei(c3), d5 = l4[e.axis], u3 = 0, f4 = s2 ? this.applyStack(e, l4, s2) : d5, g4, p6;
        f4 !== d5 && (u3 = f4 - d5, f4 = d5), h5 && (d5 = c3.barStart, f4 = c3.barEnd - c3.barStart, d5 !== 0 && st(d5) !== st(c3.barEnd) && (u3 = 0), u3 += d5);
        let m6 = !L3(o3) && !h5 ? o3 : u3, b5 = e.getPixelForValue(m6);
        if (this.chart.getDataVisibility(t) ? g4 = e.getPixelForValue(u3 + f4) : g4 = b5, p6 = g4 - b5, Math.abs(p6) < a2) {
          p6 = Fa(p6, e, r) * a2, d5 === r && (b5 -= p6 / 2);
          let _5 = e.getPixelForDecimal(0), v5 = e.getPixelForDecimal(1), y5 = Math.min(_5, v5), x5 = Math.max(_5, v5);
          b5 = Math.max(Math.min(b5, x5), y5), g4 = b5 + p6, s2 && !h5 && (l4._stacks[e.axis]._visualValues[n3] = e.getValueForPixel(g4) - e.getValueForPixel(b5));
        }
        if (b5 === e.getPixelForValue(r)) {
          let _5 = st(p6) * e.getLineWidthForValue(r) / 2;
          b5 += _5, p6 -= _5;
        }
        return { size: p6, base: b5, head: g4, center: g4 + p6 / 2 };
      }
      _calculateBarIndexPixels(t, e) {
        let s2 = e.scale, n3 = this.options, o3 = n3.skipNull, a2 = P3(n3.maxBarThickness, 1 / 0), r, l4;
        if (e.grouped) {
          let c3 = o3 ? this._getStackCount(t) : e.stackCount, h5 = n3.barThickness === "flex" ? Ia(t, e, n3, c3) : Ea(t, e, n3, c3), d5 = this._getStackIndex(this.index, this._cachedMeta.stack, o3 ? t : void 0);
          r = h5.start + h5.chunk * d5 + h5.chunk / 2, l4 = Math.min(a2, h5.chunk * h5.ratio);
        } else
          r = s2.getPixelForValue(this.getParsed(t)[s2.axis], t), l4 = Math.min(a2, e.min * e.ratio);
        return { base: r - l4 / 2, head: r + l4 / 2, center: r, size: l4 };
      }
      draw() {
        let t = this._cachedMeta, e = t.vScale, s2 = t.data, n3 = s2.length, o3 = 0;
        for (; o3 < n3; ++o3)
          this.getParsed(o3)[e.axis] !== null && s2[o3].draw(this._ctx);
      }
    };
    $i = class extends dt {
      static id = "bubble";
      static defaults = { datasetElementType: false, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } };
      static overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } } };
      initialize() {
        this.enableOptionSharing = true, super.initialize();
      }
      parsePrimitiveData(t, e, s2, n3) {
        let o3 = super.parsePrimitiveData(t, e, s2, n3);
        for (let a2 = 0; a2 < o3.length; a2++)
          o3[a2]._custom = this.resolveDataElementOptions(a2 + s2).radius;
        return o3;
      }
      parseArrayData(t, e, s2, n3) {
        let o3 = super.parseArrayData(t, e, s2, n3);
        for (let a2 = 0; a2 < o3.length; a2++) {
          let r = e[s2 + a2];
          o3[a2]._custom = P3(r[2], this.resolveDataElementOptions(a2 + s2).radius);
        }
        return o3;
      }
      parseObjectData(t, e, s2, n3) {
        let o3 = super.parseObjectData(t, e, s2, n3);
        for (let a2 = 0; a2 < o3.length; a2++) {
          let r = e[s2 + a2];
          o3[a2]._custom = P3(r && r.r && +r.r, this.resolveDataElementOptions(a2 + s2).radius);
        }
        return o3;
      }
      getMaxOverflow() {
        let t = this._cachedMeta.data, e = 0;
        for (let s2 = t.length - 1; s2 >= 0; --s2)
          e = Math.max(e, t[s2].size(this.resolveDataElementOptions(s2)) / 2);
        return e > 0 && e;
      }
      getLabelAndValue(t) {
        let e = this._cachedMeta, s2 = this.chart.data.labels || [], { xScale: n3, yScale: o3 } = e, a2 = this.getParsed(t), r = n3.getLabelForValue(a2.x), l4 = o3.getLabelForValue(a2.y), c3 = a2._custom;
        return { label: s2[t] || "", value: "(" + r + ", " + l4 + (c3 ? ", " + c3 : "") + ")" };
      }
      update(t) {
        let e = this._cachedMeta.data;
        this.updateElements(e, 0, e.length, t);
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", { iScale: a2, vScale: r } = this._cachedMeta, { sharedOptions: l4, includeOptions: c3 } = this._getSharedOptions(e, n3), h5 = a2.axis, d5 = r.axis;
        for (let u3 = e; u3 < e + s2; u3++) {
          let f4 = t[u3], g4 = !o3 && this.getParsed(u3), p6 = {}, m6 = p6[h5] = o3 ? a2.getPixelForDecimal(0.5) : a2.getPixelForValue(g4[h5]), b5 = p6[d5] = o3 ? r.getBasePixel() : r.getPixelForValue(g4[d5]);
          p6.skip = isNaN(m6) || isNaN(b5), c3 && (p6.options = l4 || this.resolveDataElementOptions(u3, f4.active ? "active" : n3), o3 && (p6.options.radius = 0)), this.updateElement(f4, u3, p6, n3);
        }
      }
      resolveDataElementOptions(t, e) {
        let s2 = this.getParsed(t), n3 = super.resolveDataElementOptions(t, e);
        n3.$shared && (n3 = Object.assign({}, n3, { $shared: false }));
        let o3 = n3.radius;
        return e !== "active" && (n3.radius = 0), n3.radius += P3(s2 && s2._custom, o3), n3;
      }
    };
    fe = class extends dt {
      static id = "doughnut";
      static defaults = { datasetElementType: false, dataElementType: "arc", animation: { animateRotate: true, animateScale: false }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" };
      static descriptors = { _scriptable: (t) => t !== "spacing", _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") };
      static overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) {
        let e = t.data;
        if (e.labels.length && e.datasets.length) {
          let { labels: { pointStyle: s2, color: n3 } } = t.legend.options;
          return e.labels.map((o3, a2) => {
            let l4 = t.getDatasetMeta(0).controller.getStyle(a2);
            return { text: o3, fillStyle: l4.backgroundColor, strokeStyle: l4.borderColor, fontColor: n3, lineWidth: l4.borderWidth, pointStyle: s2, hidden: !t.getDataVisibility(a2), index: a2 };
          });
        }
        return [];
      } }, onClick(t, e, s2) {
        s2.chart.toggleDataVisibility(e.index), s2.chart.update();
      } } } };
      constructor(t, e) {
        super(t, e), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
      }
      linkScales() {
      }
      parse(t, e) {
        let s2 = this.getDataset().data, n3 = this._cachedMeta;
        if (this._parsing === false)
          n3._parsed = s2;
        else {
          let o3 = (l4) => +s2[l4];
          if (O3(s2[t])) {
            let { key: l4 = "value" } = this._parsing;
            o3 = (c3) => +gt(s2[c3], l4);
          }
          let a2, r;
          for (a2 = t, r = t + e; a2 < r; ++a2)
            n3._parsed[a2] = o3(a2);
        }
      }
      _getRotation() {
        return et(this.options.rotation - 90);
      }
      _getCircumference() {
        return et(this.options.circumference);
      }
      _getRotationExtents() {
        let t = F3, e = -F3;
        for (let s2 = 0; s2 < this.chart.data.datasets.length; ++s2)
          if (this.chart.isDatasetVisible(s2) && this.chart.getDatasetMeta(s2).type === this._type) {
            let n3 = this.chart.getDatasetMeta(s2).controller, o3 = n3._getRotation(), a2 = n3._getCircumference();
            t = Math.min(t, o3), e = Math.max(e, o3 + a2);
          }
        return { rotation: t, circumference: e - t };
      }
      update(t) {
        let e = this.chart, { chartArea: s2 } = e, n3 = this._cachedMeta, o3 = n3.data, a2 = this.getMaxBorderWidth() + this.getMaxOffset(o3) + this.options.spacing, r = Math.max((Math.min(s2.width, s2.height) - a2) / 2, 0), l4 = Math.min(Cs(this.options.cutout, r), 1), c3 = this._getRingWeight(this.index), { circumference: h5, rotation: d5 } = this._getRotationExtents(), { ratioX: u3, ratioY: f4, offsetX: g4, offsetY: p6 } = Ha(d5, h5, l4), m6 = (s2.width - a2) / u3, b5 = (s2.height - a2) / f4, _5 = Math.max(Math.min(m6, b5) / 2, 0), v5 = oi(this.options.radius, _5), y5 = Math.max(v5 * l4, 0), x5 = (v5 - y5) / this._getVisibleDatasetWeightTotal();
        this.offsetX = g4 * v5, this.offsetY = p6 * v5, n3.total = this.calculateTotal(), this.outerRadius = v5 - x5 * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x5 * c3, 0), this.updateElements(o3, 0, o3.length, t);
      }
      _circumference(t, e) {
        let s2 = this.options, n3 = this._cachedMeta, o3 = this._getCircumference();
        return e && s2.animation.animateRotate || !this.chart.getDataVisibility(t) || n3._parsed[t] === null || n3.data[t].hidden ? 0 : this.calculateCircumference(n3._parsed[t] * o3 / F3);
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", a2 = this.chart, r = a2.chartArea, c3 = a2.options.animation, h5 = (r.left + r.right) / 2, d5 = (r.top + r.bottom) / 2, u3 = o3 && c3.animateScale, f4 = u3 ? 0 : this.innerRadius, g4 = u3 ? 0 : this.outerRadius, { sharedOptions: p6, includeOptions: m6 } = this._getSharedOptions(e, n3), b5 = this._getRotation(), _5;
        for (_5 = 0; _5 < e; ++_5)
          b5 += this._circumference(_5, o3);
        for (_5 = e; _5 < e + s2; ++_5) {
          let v5 = this._circumference(_5, o3), y5 = t[_5], x5 = { x: h5 + this.offsetX, y: d5 + this.offsetY, startAngle: b5, endAngle: b5 + v5, circumference: v5, outerRadius: g4, innerRadius: f4 };
          m6 && (x5.options = p6 || this.resolveDataElementOptions(_5, y5.active ? "active" : n3)), b5 += v5, this.updateElement(y5, _5, x5, n3);
        }
      }
      calculateTotal() {
        let t = this._cachedMeta, e = t.data, s2 = 0, n3;
        for (n3 = 0; n3 < e.length; n3++) {
          let o3 = t._parsed[n3];
          o3 !== null && !isNaN(o3) && this.chart.getDataVisibility(n3) && !e[n3].hidden && (s2 += Math.abs(o3));
        }
        return s2;
      }
      calculateCircumference(t) {
        let e = this._cachedMeta.total;
        return e > 0 && !isNaN(t) ? F3 * (Math.abs(t) / e) : 0;
      }
      getLabelAndValue(t) {
        let e = this._cachedMeta, s2 = this.chart, n3 = s2.data.labels || [], o3 = $t(e._parsed[t], s2.options.locale);
        return { label: n3[t] || "", value: o3 };
      }
      getMaxBorderWidth(t) {
        let e = 0, s2 = this.chart, n3, o3, a2, r, l4;
        if (!t) {
          for (n3 = 0, o3 = s2.data.datasets.length; n3 < o3; ++n3)
            if (s2.isDatasetVisible(n3)) {
              a2 = s2.getDatasetMeta(n3), t = a2.data, r = a2.controller;
              break;
            }
        }
        if (!t)
          return 0;
        for (n3 = 0, o3 = t.length; n3 < o3; ++n3)
          l4 = r.resolveDataElementOptions(n3), l4.borderAlign !== "inner" && (e = Math.max(e, l4.borderWidth || 0, l4.hoverBorderWidth || 0));
        return e;
      }
      getMaxOffset(t) {
        let e = 0;
        for (let s2 = 0, n3 = t.length; s2 < n3; ++s2) {
          let o3 = this.resolveDataElementOptions(s2);
          e = Math.max(e, o3.offset || 0, o3.hoverOffset || 0);
        }
        return e;
      }
      _getRingWeightOffset(t) {
        let e = 0;
        for (let s2 = 0; s2 < t; ++s2)
          this.chart.isDatasetVisible(s2) && (e += this._getRingWeight(s2));
        return e;
      }
      _getRingWeight(t) {
        return Math.max(P3(this.chart.data.datasets[t].weight, 1), 0);
      }
      _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
      }
    };
    Ui = class extends dt {
      static id = "line";
      static defaults = { datasetElementType: "line", dataElementType: "point", showLine: true, spanGaps: false };
      static overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } };
      initialize() {
        this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
      }
      update(t) {
        let e = this._cachedMeta, { dataset: s2, data: n3 = [], _dataset: o3 } = e, a2 = this.chart._animationsDisabled, { start: r, count: l4 } = pi(e, n3, a2);
        this._drawStart = r, this._drawCount = l4, mi(e) && (r = 0, l4 = n3.length), s2._chart = this.chart, s2._datasetIndex = this.index, s2._decimated = !!o3._decimated, s2.points = n3;
        let c3 = this.resolveDatasetElementOptions(t);
        this.options.showLine || (c3.borderWidth = 0), c3.segment = this.options.segment, this.updateElement(s2, void 0, { animated: !a2, options: c3 }, t), this.updateElements(n3, r, l4, t);
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", { iScale: a2, vScale: r, _stacked: l4, _dataset: c3 } = this._cachedMeta, { sharedOptions: h5, includeOptions: d5 } = this._getSharedOptions(e, n3), u3 = a2.axis, f4 = r.axis, { spanGaps: g4, segment: p6 } = this.options, m6 = At(g4) ? g4 : Number.POSITIVE_INFINITY, b5 = this.chart._animationsDisabled || o3 || n3 === "none", _5 = e + s2, v5 = t.length, y5 = e > 0 && this.getParsed(e - 1);
        for (let x5 = 0; x5 < v5; ++x5) {
          let M5 = t[x5], k4 = b5 ? M5 : {};
          if (x5 < e || x5 >= _5) {
            k4.skip = true;
            continue;
          }
          let S6 = this.getParsed(x5), w4 = L3(S6[f4]), D5 = k4[u3] = a2.getPixelForValue(S6[u3], x5), C5 = k4[f4] = o3 || w4 ? r.getBasePixel() : r.getPixelForValue(l4 ? this.applyStack(r, S6, l4) : S6[f4], x5);
          k4.skip = isNaN(D5) || isNaN(C5) || w4, k4.stop = x5 > 0 && Math.abs(S6[u3] - y5[u3]) > m6, p6 && (k4.parsed = S6, k4.raw = c3.data[x5]), d5 && (k4.options = h5 || this.resolveDataElementOptions(x5, M5.active ? "active" : n3)), b5 || this.updateElement(M5, x5, k4, n3), y5 = S6;
        }
      }
      getMaxOverflow() {
        let t = this._cachedMeta, e = t.dataset, s2 = e.options && e.options.borderWidth || 0, n3 = t.data || [];
        if (!n3.length)
          return s2;
        let o3 = n3[0].size(this.resolveDataElementOptions(0)), a2 = n3[n3.length - 1].size(this.resolveDataElementOptions(n3.length - 1));
        return Math.max(s2, o3, a2) / 2;
      }
      draw() {
        let t = this._cachedMeta;
        t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
      }
    };
    Ke = class extends dt {
      static id = "polarArea";
      static defaults = { dataElementType: "arc", animation: { animateRotate: true, animateScale: true }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 };
      static overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) {
        let e = t.data;
        if (e.labels.length && e.datasets.length) {
          let { labels: { pointStyle: s2, color: n3 } } = t.legend.options;
          return e.labels.map((o3, a2) => {
            let l4 = t.getDatasetMeta(0).controller.getStyle(a2);
            return { text: o3, fillStyle: l4.backgroundColor, strokeStyle: l4.borderColor, fontColor: n3, lineWidth: l4.borderWidth, pointStyle: s2, hidden: !t.getDataVisibility(a2), index: a2 };
          });
        }
        return [];
      } }, onClick(t, e, s2) {
        s2.chart.toggleDataVisibility(e.index), s2.chart.update();
      } } }, scales: { r: { type: "radialLinear", angleLines: { display: false }, beginAtZero: true, grid: { circular: true }, pointLabels: { display: false }, startAngle: 0 } } };
      constructor(t, e) {
        super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;
      }
      getLabelAndValue(t) {
        let e = this._cachedMeta, s2 = this.chart, n3 = s2.data.labels || [], o3 = $t(e._parsed[t].r, s2.options.locale);
        return { label: n3[t] || "", value: o3 };
      }
      parseObjectData(t, e, s2, n3) {
        return wi.bind(this)(t, e, s2, n3);
      }
      update(t) {
        let e = this._cachedMeta.data;
        this._updateRadius(), this.updateElements(e, 0, e.length, t);
      }
      getMinMax() {
        let t = this._cachedMeta, e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
        return t.data.forEach((s2, n3) => {
          let o3 = this.getParsed(n3).r;
          !isNaN(o3) && this.chart.getDataVisibility(n3) && (o3 < e.min && (e.min = o3), o3 > e.max && (e.max = o3));
        }), e;
      }
      _updateRadius() {
        let t = this.chart, e = t.chartArea, s2 = t.options, n3 = Math.min(e.right - e.left, e.bottom - e.top), o3 = Math.max(n3 / 2, 0), a2 = Math.max(s2.cutoutPercentage ? o3 / 100 * s2.cutoutPercentage : 1, 0), r = (o3 - a2) / t.getVisibleDatasetCount();
        this.outerRadius = o3 - r * this.index, this.innerRadius = this.outerRadius - r;
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", a2 = this.chart, l4 = a2.options.animation, c3 = this._cachedMeta.rScale, h5 = c3.xCenter, d5 = c3.yCenter, u3 = c3.getIndexAngle(0) - 0.5 * z2, f4 = u3, g4, p6 = 360 / this.countVisibleElements();
        for (g4 = 0; g4 < e; ++g4)
          f4 += this._computeAngle(g4, n3, p6);
        for (g4 = e; g4 < e + s2; g4++) {
          let m6 = t[g4], b5 = f4, _5 = f4 + this._computeAngle(g4, n3, p6), v5 = a2.getDataVisibility(g4) ? c3.getDistanceFromCenterForValue(this.getParsed(g4).r) : 0;
          f4 = _5, o3 && (l4.animateScale && (v5 = 0), l4.animateRotate && (b5 = _5 = u3));
          let y5 = { x: h5, y: d5, innerRadius: 0, outerRadius: v5, startAngle: b5, endAngle: _5, options: this.resolveDataElementOptions(g4, m6.active ? "active" : n3) };
          this.updateElement(m6, g4, y5, n3);
        }
      }
      countVisibleElements() {
        let t = this._cachedMeta, e = 0;
        return t.data.forEach((s2, n3) => {
          !isNaN(this.getParsed(n3).r) && this.chart.getDataVisibility(n3) && e++;
        }), e;
      }
      _computeAngle(t, e, s2) {
        return this.chart.getDataVisibility(t) ? et(this.resolveDataElementOptions(t, e).angle || s2) : 0;
      }
    };
    Yi = class extends fe {
      static id = "pie";
      static defaults = { cutout: 0, rotation: 0, circumference: 360, radius: "100%" };
    };
    Xi = class extends dt {
      static id = "radar";
      static defaults = { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: true, elements: { line: { fill: "start" } } };
      static overrides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } };
      getLabelAndValue(t) {
        let e = this._cachedMeta.vScale, s2 = this.getParsed(t);
        return { label: e.getLabels()[t], value: "" + e.getLabelForValue(s2[e.axis]) };
      }
      parseObjectData(t, e, s2, n3) {
        return wi.bind(this)(t, e, s2, n3);
      }
      update(t) {
        let e = this._cachedMeta, s2 = e.dataset, n3 = e.data || [], o3 = e.iScale.getLabels();
        if (s2.points = n3, t !== "resize") {
          let a2 = this.resolveDatasetElementOptions(t);
          this.options.showLine || (a2.borderWidth = 0);
          let r = { _loop: true, _fullLoop: o3.length === n3.length, options: a2 };
          this.updateElement(s2, void 0, r, t);
        }
        this.updateElements(n3, 0, n3.length, t);
      }
      updateElements(t, e, s2, n3) {
        let o3 = this._cachedMeta.rScale, a2 = n3 === "reset";
        for (let r = e; r < e + s2; r++) {
          let l4 = t[r], c3 = this.resolveDataElementOptions(r, l4.active ? "active" : n3), h5 = o3.getPointPositionForValue(r, this.getParsed(r).r), d5 = a2 ? o3.xCenter : h5.x, u3 = a2 ? o3.yCenter : h5.y, f4 = { x: d5, y: u3, angle: h5.angle, skip: isNaN(d5) || isNaN(u3), options: c3 };
          this.updateElement(l4, r, f4, n3);
        }
      }
    };
    Ki = class extends dt {
      static id = "scatter";
      static defaults = { datasetElementType: false, dataElementType: "point", showLine: false, fill: false };
      static overrides = { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } };
      getLabelAndValue(t) {
        let e = this._cachedMeta, s2 = this.chart.data.labels || [], { xScale: n3, yScale: o3 } = e, a2 = this.getParsed(t), r = n3.getLabelForValue(a2.x), l4 = o3.getLabelForValue(a2.y);
        return { label: s2[t] || "", value: "(" + r + ", " + l4 + ")" };
      }
      update(t) {
        let e = this._cachedMeta, { data: s2 = [] } = e, n3 = this.chart._animationsDisabled, { start: o3, count: a2 } = pi(e, s2, n3);
        if (this._drawStart = o3, this._drawCount = a2, mi(e) && (o3 = 0, a2 = s2.length), this.options.showLine) {
          this.datasetElementType || this.addElements();
          let { dataset: r, _dataset: l4 } = e;
          r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!l4._decimated, r.points = s2;
          let c3 = this.resolveDatasetElementOptions(t);
          c3.segment = this.options.segment, this.updateElement(r, void 0, { animated: !n3, options: c3 }, t);
        } else
          this.datasetElementType && (delete e.dataset, this.datasetElementType = false);
        this.updateElements(s2, o3, a2, t);
      }
      addElements() {
        let { showLine: t } = this.options;
        !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
      }
      updateElements(t, e, s2, n3) {
        let o3 = n3 === "reset", { iScale: a2, vScale: r, _stacked: l4, _dataset: c3 } = this._cachedMeta, h5 = this.resolveDataElementOptions(e, n3), d5 = this.getSharedOptions(h5), u3 = this.includeOptions(n3, d5), f4 = a2.axis, g4 = r.axis, { spanGaps: p6, segment: m6 } = this.options, b5 = At(p6) ? p6 : Number.POSITIVE_INFINITY, _5 = this.chart._animationsDisabled || o3 || n3 === "none", v5 = e > 0 && this.getParsed(e - 1);
        for (let y5 = e; y5 < e + s2; ++y5) {
          let x5 = t[y5], M5 = this.getParsed(y5), k4 = _5 ? x5 : {}, S6 = L3(M5[g4]), w4 = k4[f4] = a2.getPixelForValue(M5[f4], y5), D5 = k4[g4] = o3 || S6 ? r.getBasePixel() : r.getPixelForValue(l4 ? this.applyStack(r, M5, l4) : M5[g4], y5);
          k4.skip = isNaN(w4) || isNaN(D5) || S6, k4.stop = y5 > 0 && Math.abs(M5[f4] - v5[f4]) > b5, m6 && (k4.parsed = M5, k4.raw = c3.data[y5]), u3 && (k4.options = d5 || this.resolveDataElementOptions(y5, x5.active ? "active" : n3)), _5 || this.updateElement(x5, y5, k4, n3), v5 = M5;
        }
        this.updateSharedOptions(d5, n3, h5);
      }
      getMaxOverflow() {
        let t = this._cachedMeta, e = t.data || [];
        if (!this.options.showLine) {
          let r = 0;
          for (let l4 = e.length - 1; l4 >= 0; --l4)
            r = Math.max(r, e[l4].size(this.resolveDataElementOptions(l4)) / 2);
          return r > 0 && r;
        }
        let s2 = t.dataset, n3 = s2.options && s2.options.borderWidth || 0;
        if (!e.length)
          return n3;
        let o3 = e[0].size(this.resolveDataElementOptions(0)), a2 = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
        return Math.max(n3, o3, a2) / 2;
      }
    };
    ja = Object.freeze({ __proto__: null, BarController: ji, BubbleController: $i, DoughnutController: fe, LineController: Ui, PieController: Yi, PolarAreaController: Ke, RadarController: Xi, ScatterController: Ki });
    qi = class i2 {
      static override(t) {
        Object.assign(i2.prototype, t);
      }
      options;
      constructor(t) {
        this.options = t || {};
      }
      init() {
      }
      formats() {
        return Tt();
      }
      parse() {
        return Tt();
      }
      format() {
        return Tt();
      }
      add() {
        return Tt();
      }
      diff() {
        return Tt();
      }
      startOf() {
        return Tt();
      }
      endOf() {
        return Tt();
      }
    };
    $a = { _date: qi };
    qa = { evaluateInteractionItems: _e, modes: { index(i4, t, e, s2) {
      let n3 = kt(t, i4), o3 = e.axis || "x", a2 = e.includeInvisible || false, r = e.intersect ? Ii(i4, n3, o3, s2, a2) : zi(i4, n3, o3, false, s2, a2), l4 = [];
      return r.length ? (i4.getSortedVisibleDatasetMetas().forEach((c3) => {
        let h5 = r[0].index, d5 = c3.data[h5];
        d5 && !d5.skip && l4.push({ element: d5, datasetIndex: c3.index, index: h5 });
      }), l4) : [];
    }, dataset(i4, t, e, s2) {
      let n3 = kt(t, i4), o3 = e.axis || "xy", a2 = e.includeInvisible || false, r = e.intersect ? Ii(i4, n3, o3, s2, a2) : zi(i4, n3, o3, false, s2, a2);
      if (r.length > 0) {
        let l4 = r[0].datasetIndex, c3 = i4.getDatasetMeta(l4).data;
        r = [];
        for (let h5 = 0; h5 < c3.length; ++h5)
          r.push({ element: c3[h5], datasetIndex: l4, index: h5 });
      }
      return r;
    }, point(i4, t, e, s2) {
      let n3 = kt(t, i4), o3 = e.axis || "xy", a2 = e.includeInvisible || false;
      return Ii(i4, n3, o3, s2, a2);
    }, nearest(i4, t, e, s2) {
      let n3 = kt(t, i4), o3 = e.axis || "xy", a2 = e.includeInvisible || false;
      return zi(i4, n3, o3, e.intersect, s2, a2);
    }, x(i4, t, e, s2) {
      let n3 = kt(t, i4);
      return fn(i4, n3, "x", e.intersect, s2);
    }, y(i4, t, e, s2) {
      let n3 = kt(t, i4);
      return fn(i4, n3, "y", e.intersect, s2);
    } } };
    oo = ["left", "top", "right", "bottom"];
    q3 = { addBox(i4, t) {
      i4.boxes || (i4.boxes = []), t.fullSize = t.fullSize || false, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
        return [{ z: 0, draw(e) {
          t.draw(e);
        } }];
      }, i4.boxes.push(t);
    }, removeBox(i4, t) {
      let e = i4.boxes ? i4.boxes.indexOf(t) : -1;
      e !== -1 && i4.boxes.splice(e, 1);
    }, configure(i4, t, e) {
      t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;
    }, update(i4, t, e, s2) {
      if (!i4)
        return;
      let n3 = X3(i4.options.layout.padding), o3 = Math.max(t - n3.width, 0), a2 = Math.max(e - n3.height, 0), r = Za(i4.boxes), l4 = r.vertical, c3 = r.horizontal;
      T3(i4.boxes, (p6) => {
        typeof p6.beforeLayout == "function" && p6.beforeLayout();
      });
      let h5 = l4.reduce((p6, m6) => m6.box.options && m6.box.options.display === false ? p6 : p6 + 1, 0) || 1, d5 = Object.freeze({ outerWidth: t, outerHeight: e, padding: n3, availableWidth: o3, availableHeight: a2, vBoxMaxWidth: o3 / 2 / h5, hBoxMaxHeight: a2 / 2 }), u3 = Object.assign({}, n3);
      ao(u3, X3(s2));
      let f4 = Object.assign({ maxPadding: u3, w: o3, h: a2, x: n3.left, y: n3.top }, n3), g4 = Qa(l4.concat(c3), d5);
      de(r.fullSize, f4, d5, g4), de(l4, f4, d5, g4), de(c3, f4, d5, g4) && de(l4, f4, d5, g4), er(f4), mn(r.leftAndTop, f4, d5, g4), f4.x += f4.w, f4.y += f4.h, mn(r.rightAndBottom, f4, d5, g4), i4.chartArea = { left: f4.left, top: f4.top, right: f4.left + f4.w, bottom: f4.top + f4.h, height: f4.h, width: f4.w }, T3(r.chartArea, (p6) => {
        let m6 = p6.box;
        Object.assign(m6, i4.chartArea), m6.update(f4.w, f4.h, { left: 0, top: 0, right: 0, bottom: 0 });
      });
    } };
    qe = class {
      acquireContext(t, e) {
      }
      releaseContext(t) {
        return false;
      }
      addEventListener(t, e, s2) {
      }
      removeEventListener(t, e, s2) {
      }
      getDevicePixelRatio() {
        return 1;
      }
      getMaximumSize(t, e, s2, n3) {
        return e = Math.max(0, e || t.width), s2 = s2 || t.height, { width: e, height: Math.max(0, n3 ? Math.floor(e / n3) : s2) };
      }
      isAttached(t) {
        return true;
      }
      updateConfig(t) {
      }
    };
    Gi = class extends qe {
      acquireContext(t) {
        return t && t.getContext && t.getContext("2d") || null;
      }
      updateConfig(t) {
        t.options.animation = false;
      }
    };
    Ue = "$chartjs";
    sr = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" };
    bn = (i4) => i4 === null || i4 === "";
    ro = Js ? { passive: true } : false;
    ge = /* @__PURE__ */ new Map();
    _n = 0;
    Ji = class extends qe {
      acquireContext(t, e) {
        let s2 = t && t.getContext && t.getContext("2d");
        return s2 && s2.canvas === t ? (nr(t, e), s2) : null;
      }
      releaseContext(t) {
        let e = t.canvas;
        if (!e[Ue])
          return false;
        let s2 = e[Ue].initial;
        ["height", "width"].forEach((o3) => {
          let a2 = s2[o3];
          L3(a2) ? e.removeAttribute(o3) : e.setAttribute(o3, a2);
        });
        let n3 = s2.style || {};
        return Object.keys(n3).forEach((o3) => {
          e.style[o3] = n3[o3];
        }), e.width = e.width, delete e[Ue], true;
      }
      addEventListener(t, e, s2) {
        this.removeEventListener(t, e);
        let n3 = t.$proxies || (t.$proxies = {}), a2 = { attach: lr, detach: cr, resize: ur }[e] || fr;
        n3[e] = a2(t, e, s2);
      }
      removeEventListener(t, e) {
        let s2 = t.$proxies || (t.$proxies = {}), n3 = s2[e];
        if (!n3)
          return;
        ({ attach: Fi, detach: Fi, resize: Fi }[e] || ar)(t, e, n3), s2[e] = void 0;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getMaximumSize(t, e, s2, n3) {
        return Gs(t, e, s2, n3);
      }
      isAttached(t) {
        let e = ze(t);
        return !!(e && e.isConnected);
      }
    };
    nt = class {
      static defaults = {};
      static defaultRoutes = void 0;
      x;
      y;
      active = false;
      options;
      $animations;
      tooltipPosition(t) {
        let { x: e, y: s2 } = this.getProps(["x", "y"], t);
        return { x: e, y: s2 };
      }
      hasValue() {
        return At(this.x) && At(this.y);
      }
      getProps(t, e) {
        let s2 = this.$animations;
        if (!e || !s2)
          return this;
        let n3 = {};
        return t.forEach((o3) => {
          n3[o3] = s2[o3] && s2[o3].active() ? s2[o3]._to : this[o3];
        }), n3;
      }
    };
    vr = (i4) => i4 === "left" ? "right" : i4 === "right" ? "left" : i4;
    xn = (i4, t, e) => t === "top" || t === "left" ? i4[t] + e : i4[t] - e;
    yn = (i4, t) => Math.min(t || i4, i4);
    Et = class i3 extends nt {
      constructor(t) {
        super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
      }
      init(t) {
        this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
      }
      parse(t, e) {
        return t;
      }
      getUserBounds() {
        let { _userMin: t, _userMax: e, _suggestedMin: s2, _suggestedMax: n3 } = this;
        return t = J3(t, Number.POSITIVE_INFINITY), e = J3(e, Number.NEGATIVE_INFINITY), s2 = J3(s2, Number.POSITIVE_INFINITY), n3 = J3(n3, Number.NEGATIVE_INFINITY), { min: J3(t, s2), max: J3(e, n3), minDefined: V3(t), maxDefined: V3(e) };
      }
      getMinMax(t) {
        let { min: e, max: s2, minDefined: n3, maxDefined: o3 } = this.getUserBounds(), a2;
        if (n3 && o3)
          return { min: e, max: s2 };
        let r = this.getMatchingVisibleMetas();
        for (let l4 = 0, c3 = r.length; l4 < c3; ++l4)
          a2 = r[l4].controller.getMinMax(this, t), n3 || (e = Math.min(e, a2.min)), o3 || (s2 = Math.max(s2, a2.max));
        return e = o3 && e > s2 ? s2 : e, s2 = n3 && e > s2 ? e : s2, { min: J3(e, J3(s2, e)), max: J3(s2, J3(e, s2)) };
      }
      getPadding() {
        return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 };
      }
      getTicks() {
        return this.ticks;
      }
      getLabels() {
        let t = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
      }
      getLabelItems(t = this.chart.chartArea) {
        return this._labelItems || (this._labelItems = this._computeLabelItems(t));
      }
      beforeLayout() {
        this._cache = {}, this._dataLimitsCached = false;
      }
      beforeUpdate() {
        E2(this.options.beforeUpdate, [this]);
      }
      update(t, e, s2) {
        let { beginAtZero: n3, grace: o3, ticks: a2 } = this.options, r = a2.sampleSize;
        this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s2 = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, s2), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s2.left + s2.right : this.height + s2.top + s2.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = $s(this, o3, n3), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
        let l4 = r < this.ticks.length;
        this._convertTicksToLabels(l4 ? vn(this.ticks, r) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a2.display && (a2.autoSkip || a2.source === "auto") && (this.ticks = pr(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l4 && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
      }
      configure() {
        let t = this.options.reverse, e, s2;
        this.isHorizontal() ? (e = this.left, s2 = this.right) : (e = this.top, s2 = this.bottom, t = !t), this._startPixel = e, this._endPixel = s2, this._reversePixels = t, this._length = s2 - e, this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
        E2(this.options.afterUpdate, [this]);
      }
      beforeSetDimensions() {
        E2(this.options.beforeSetDimensions, [this]);
      }
      setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
      }
      afterSetDimensions() {
        E2(this.options.afterSetDimensions, [this]);
      }
      _callHooks(t) {
        this.chart.notifyPlugins(t, this.getContext()), E2(this.options[t], [this]);
      }
      beforeDataLimits() {
        this._callHooks("beforeDataLimits");
      }
      determineDataLimits() {
      }
      afterDataLimits() {
        this._callHooks("afterDataLimits");
      }
      beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
      }
      buildTicks() {
        return [];
      }
      afterBuildTicks() {
        this._callHooks("afterBuildTicks");
      }
      beforeTickToLabelConversion() {
        E2(this.options.beforeTickToLabelConversion, [this]);
      }
      generateTickLabels(t) {
        let e = this.options.ticks, s2, n3, o3;
        for (s2 = 0, n3 = t.length; s2 < n3; s2++)
          o3 = t[s2], o3.label = E2(e.callback, [o3.value, s2, t], this);
      }
      afterTickToLabelConversion() {
        E2(this.options.afterTickToLabelConversion, [this]);
      }
      beforeCalculateLabelRotation() {
        E2(this.options.beforeCalculateLabelRotation, [this]);
      }
      calculateLabelRotation() {
        let t = this.options, e = t.ticks, s2 = yn(this.ticks.length, t.ticks.maxTicksLimit), n3 = e.minRotation || 0, o3 = e.maxRotation, a2 = n3, r, l4, c3;
        if (!this._isVisible() || !e.display || n3 >= o3 || s2 <= 1 || !this.isHorizontal()) {
          this.labelRotation = n3;
          return;
        }
        let h5 = this._getLabelSizes(), d5 = h5.widest.width, u3 = h5.highest.height, f4 = $3(this.chart.width - d5, 0, this.maxWidth);
        r = t.offset ? this.maxWidth / s2 : f4 / (s2 - 1), d5 + 6 > r && (r = f4 / (s2 - (t.offset ? 0.5 : 1)), l4 = this.maxHeight - ce(t.grid) - e.padding - Mn(t.title, this.chart.options.font), c3 = Math.sqrt(d5 * d5 + u3 * u3), a2 = Ce(Math.min(Math.asin($3((h5.highest.height + 6) / r, -1, 1)), Math.asin($3(l4 / c3, -1, 1)) - Math.asin($3(u3 / c3, -1, 1)))), a2 = Math.max(n3, Math.min(o3, a2))), this.labelRotation = a2;
      }
      afterCalculateLabelRotation() {
        E2(this.options.afterCalculateLabelRotation, [this]);
      }
      afterAutoSkip() {
      }
      beforeFit() {
        E2(this.options.beforeFit, [this]);
      }
      fit() {
        let t = { width: 0, height: 0 }, { chart: e, options: { ticks: s2, title: n3, grid: o3 } } = this, a2 = this._isVisible(), r = this.isHorizontal();
        if (a2) {
          let l4 = Mn(n3, e.options.font);
          if (r ? (t.width = this.maxWidth, t.height = ce(o3) + l4) : (t.height = this.maxHeight, t.width = ce(o3) + l4), s2.display && this.ticks.length) {
            let { first: c3, last: h5, widest: d5, highest: u3 } = this._getLabelSizes(), f4 = s2.padding * 2, g4 = et(this.labelRotation), p6 = Math.cos(g4), m6 = Math.sin(g4);
            if (r) {
              let b5 = s2.mirror ? 0 : m6 * d5.width + p6 * u3.height;
              t.height = Math.min(this.maxHeight, t.height + b5 + f4);
            } else {
              let b5 = s2.mirror ? 0 : p6 * d5.width + m6 * u3.height;
              t.width = Math.min(this.maxWidth, t.width + b5 + f4);
            }
            this._calculatePadding(c3, h5, m6, p6);
          }
        }
        this._handleMargins(), r ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);
      }
      _calculatePadding(t, e, s2, n3) {
        let { ticks: { align: o3, padding: a2 }, position: r } = this.options, l4 = this.labelRotation !== 0, c3 = r !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
          let h5 = this.getPixelForTick(0) - this.left, d5 = this.right - this.getPixelForTick(this.ticks.length - 1), u3 = 0, f4 = 0;
          l4 ? c3 ? (u3 = n3 * t.width, f4 = s2 * e.height) : (u3 = s2 * t.height, f4 = n3 * e.width) : o3 === "start" ? f4 = e.width : o3 === "end" ? u3 = t.width : o3 !== "inner" && (u3 = t.width / 2, f4 = e.width / 2), this.paddingLeft = Math.max((u3 - h5 + a2) * this.width / (this.width - h5), 0), this.paddingRight = Math.max((f4 - d5 + a2) * this.width / (this.width - d5), 0);
        } else {
          let h5 = e.height / 2, d5 = t.height / 2;
          o3 === "start" ? (h5 = 0, d5 = t.height) : o3 === "end" && (h5 = e.height, d5 = 0), this.paddingTop = h5 + a2, this.paddingBottom = d5 + a2;
        }
      }
      _handleMargins() {
        this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
      }
      afterFit() {
        E2(this.options.afterFit, [this]);
      }
      isHorizontal() {
        let { axis: t, position: e } = this.options;
        return e === "top" || e === "bottom" || t === "x";
      }
      isFullSize() {
        return this.options.fullSize;
      }
      _convertTicksToLabels(t) {
        this.beforeTickToLabelConversion(), this.generateTickLabels(t);
        let e, s2;
        for (e = 0, s2 = t.length; e < s2; e++)
          L3(t[e].label) && (t.splice(e, 1), s2--, e--);
        this.afterTickToLabelConversion();
      }
      _getLabelSizes() {
        let t = this._labelSizes;
        if (!t) {
          let e = this.options.ticks.sampleSize, s2 = this.ticks;
          e < s2.length && (s2 = vn(s2, e)), this._labelSizes = t = this._computeLabelSizes(s2, s2.length, this.options.ticks.maxTicksLimit);
        }
        return t;
      }
      _computeLabelSizes(t, e, s2) {
        let { ctx: n3, _longestTextCache: o3 } = this, a2 = [], r = [], l4 = Math.floor(e / yn(e, s2)), c3 = 0, h5 = 0, d5, u3, f4, g4, p6, m6, b5, _5, v5, y5, x5;
        for (d5 = 0; d5 < e; d5 += l4) {
          if (g4 = t[d5].label, p6 = this._resolveTickFontOptions(d5), n3.font = m6 = p6.string, b5 = o3[m6] = o3[m6] || { data: {}, gc: [] }, _5 = p6.lineHeight, v5 = y5 = 0, !L3(g4) && !I3(g4))
            v5 = ee2(n3, b5.data, b5.gc, v5, g4), y5 = _5;
          else if (I3(g4))
            for (u3 = 0, f4 = g4.length; u3 < f4; ++u3)
              x5 = g4[u3], !L3(x5) && !I3(x5) && (v5 = ee2(n3, b5.data, b5.gc, v5, x5), y5 += _5);
          a2.push(v5), r.push(y5), c3 = Math.max(v5, c3), h5 = Math.max(y5, h5);
        }
        kr(o3, e);
        let M5 = a2.indexOf(c3), k4 = r.indexOf(h5), S6 = (w4) => ({ width: a2[w4] || 0, height: r[w4] || 0 });
        return { first: S6(0), last: S6(e - 1), widest: S6(M5), highest: S6(k4), widths: a2, heights: r };
      }
      getLabelForValue(t) {
        return t;
      }
      getPixelForValue(t, e) {
        return NaN;
      }
      getValueForPixel(t) {
      }
      getPixelForTick(t) {
        let e = this.ticks;
        return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
      }
      getPixelForDecimal(t) {
        this._reversePixels && (t = 1 - t);
        let e = this._startPixel + t * this._length;
        return Rs(this._alignToPixels ? yt(this.chart, e, 0) : e);
      }
      getDecimalForPixel(t) {
        let e = (t - this._startPixel) / this._length;
        return this._reversePixels ? 1 - e : e;
      }
      getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
      }
      getBaseValue() {
        let { min: t, max: e } = this;
        return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
      }
      getContext(t) {
        let e = this.ticks || [];
        if (t >= 0 && t < e.length) {
          let s2 = e[t];
          return s2.$context || (s2.$context = wr(this.getContext(), t, s2));
        }
        return this.$context || (this.$context = Sr(this.chart.getContext(), this));
      }
      _tickSize() {
        let t = this.options.ticks, e = et(this.labelRotation), s2 = Math.abs(Math.cos(e)), n3 = Math.abs(Math.sin(e)), o3 = this._getLabelSizes(), a2 = t.autoSkipPadding || 0, r = o3 ? o3.widest.width + a2 : 0, l4 = o3 ? o3.highest.height + a2 : 0;
        return this.isHorizontal() ? l4 * s2 > r * n3 ? r / s2 : l4 / n3 : l4 * n3 < r * s2 ? l4 / s2 : r / n3;
      }
      _isVisible() {
        let t = this.options.display;
        return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
      }
      _computeGridLineItems(t) {
        let e = this.axis, s2 = this.chart, n3 = this.options, { grid: o3, position: a2, border: r } = n3, l4 = o3.offset, c3 = this.isHorizontal(), d5 = this.ticks.length + (l4 ? 1 : 0), u3 = ce(o3), f4 = [], g4 = r.setContext(this.getContext()), p6 = g4.display ? g4.width : 0, m6 = p6 / 2, b5 = function(B4) {
          return yt(s2, B4, p6);
        }, _5, v5, y5, x5, M5, k4, S6, w4, D5, C5, A5, U4;
        if (a2 === "top")
          _5 = b5(this.bottom), k4 = this.bottom - u3, w4 = _5 - m6, C5 = b5(t.top) + m6, U4 = t.bottom;
        else if (a2 === "bottom")
          _5 = b5(this.top), C5 = t.top, U4 = b5(t.bottom) - m6, k4 = _5 + m6, w4 = this.top + u3;
        else if (a2 === "left")
          _5 = b5(this.right), M5 = this.right - u3, S6 = _5 - m6, D5 = b5(t.left) + m6, A5 = t.right;
        else if (a2 === "right")
          _5 = b5(this.left), D5 = t.left, A5 = b5(t.right) - m6, M5 = _5 + m6, S6 = this.left + u3;
        else if (e === "x") {
          if (a2 === "center")
            _5 = b5((t.top + t.bottom) / 2 + 0.5);
          else if (O3(a2)) {
            let B4 = Object.keys(a2)[0], H4 = a2[B4];
            _5 = b5(this.chart.scales[B4].getPixelForValue(H4));
          }
          C5 = t.top, U4 = t.bottom, k4 = _5 + m6, w4 = k4 + u3;
        } else if (e === "y") {
          if (a2 === "center")
            _5 = b5((t.left + t.right) / 2);
          else if (O3(a2)) {
            let B4 = Object.keys(a2)[0], H4 = a2[B4];
            _5 = b5(this.chart.scales[B4].getPixelForValue(H4));
          }
          M5 = _5 - m6, S6 = M5 - u3, D5 = t.left, A5 = t.right;
        }
        let tt = P3(n3.ticks.maxTicksLimit, d5), R4 = Math.max(1, Math.ceil(d5 / tt));
        for (v5 = 0; v5 < d5; v5 += R4) {
          let B4 = this.getContext(v5), H4 = o3.setContext(B4), it = r.setContext(B4), K3 = H4.lineWidth, It = H4.color, xe2 = it.dash || [], zt = it.dashOffset, Qt = H4.tickWidth, wt = H4.tickColor, Zt = H4.tickBorderDash || [], Pt = H4.tickBorderDashOffset;
          y5 = Mr(this, v5, l4), y5 !== void 0 && (x5 = yt(s2, y5, K3), c3 ? M5 = S6 = D5 = A5 = x5 : k4 = w4 = C5 = U4 = x5, f4.push({ tx1: M5, ty1: k4, tx2: S6, ty2: w4, x1: D5, y1: C5, x2: A5, y2: U4, width: K3, color: It, borderDash: xe2, borderDashOffset: zt, tickWidth: Qt, tickColor: wt, tickBorderDash: Zt, tickBorderDashOffset: Pt }));
        }
        return this._ticksLength = d5, this._borderValue = _5, f4;
      }
      _computeLabelItems(t) {
        let e = this.axis, s2 = this.options, { position: n3, ticks: o3 } = s2, a2 = this.isHorizontal(), r = this.ticks, { align: l4, crossAlign: c3, padding: h5, mirror: d5 } = o3, u3 = ce(s2.grid), f4 = u3 + h5, g4 = d5 ? -h5 : f4, p6 = -et(this.labelRotation), m6 = [], b5, _5, v5, y5, x5, M5, k4, S6, w4, D5, C5, A5, U4 = "middle";
        if (n3 === "top")
          M5 = this.bottom - g4, k4 = this._getXAxisLabelAlignment();
        else if (n3 === "bottom")
          M5 = this.top + g4, k4 = this._getXAxisLabelAlignment();
        else if (n3 === "left") {
          let R4 = this._getYAxisLabelAlignment(u3);
          k4 = R4.textAlign, x5 = R4.x;
        } else if (n3 === "right") {
          let R4 = this._getYAxisLabelAlignment(u3);
          k4 = R4.textAlign, x5 = R4.x;
        } else if (e === "x") {
          if (n3 === "center")
            M5 = (t.top + t.bottom) / 2 + f4;
          else if (O3(n3)) {
            let R4 = Object.keys(n3)[0], B4 = n3[R4];
            M5 = this.chart.scales[R4].getPixelForValue(B4) + f4;
          }
          k4 = this._getXAxisLabelAlignment();
        } else if (e === "y") {
          if (n3 === "center")
            x5 = (t.left + t.right) / 2 - f4;
          else if (O3(n3)) {
            let R4 = Object.keys(n3)[0], B4 = n3[R4];
            x5 = this.chart.scales[R4].getPixelForValue(B4);
          }
          k4 = this._getYAxisLabelAlignment(u3).textAlign;
        }
        e === "y" && (l4 === "start" ? U4 = "top" : l4 === "end" && (U4 = "bottom"));
        let tt = this._getLabelSizes();
        for (b5 = 0, _5 = r.length; b5 < _5; ++b5) {
          v5 = r[b5], y5 = v5.label;
          let R4 = o3.setContext(this.getContext(b5));
          S6 = this.getPixelForTick(b5) + o3.labelOffset, w4 = this._resolveTickFontOptions(b5), D5 = w4.lineHeight, C5 = I3(y5) ? y5.length : 1;
          let B4 = C5 / 2, H4 = R4.color, it = R4.textStrokeColor, K3 = R4.textStrokeWidth, It = k4;
          a2 ? (x5 = S6, k4 === "inner" && (b5 === _5 - 1 ? It = this.options.reverse ? "left" : "right" : b5 === 0 ? It = this.options.reverse ? "right" : "left" : It = "center"), n3 === "top" ? c3 === "near" || p6 !== 0 ? A5 = -C5 * D5 + D5 / 2 : c3 === "center" ? A5 = -tt.highest.height / 2 - B4 * D5 + D5 : A5 = -tt.highest.height + D5 / 2 : c3 === "near" || p6 !== 0 ? A5 = D5 / 2 : c3 === "center" ? A5 = tt.highest.height / 2 - B4 * D5 : A5 = tt.highest.height - C5 * D5, d5 && (A5 *= -1), p6 !== 0 && !R4.showLabelBackdrop && (x5 += D5 / 2 * Math.sin(p6))) : (M5 = S6, A5 = (1 - C5) * D5 / 2);
          let xe2;
          if (R4.showLabelBackdrop) {
            let zt = X3(R4.backdropPadding), Qt = tt.heights[b5], wt = tt.widths[b5], Zt = A5 - zt.top, Pt = 0 - zt.left;
            switch (U4) {
              case "middle":
                Zt -= Qt / 2;
                break;
              case "bottom":
                Zt -= Qt;
                break;
            }
            switch (k4) {
              case "center":
                Pt -= wt / 2;
                break;
              case "right":
                Pt -= wt;
                break;
              case "inner":
                b5 === _5 - 1 ? Pt -= wt : b5 > 0 && (Pt -= wt / 2);
                break;
            }
            xe2 = { left: Pt, top: Zt, width: wt + zt.width, height: Qt + zt.height, color: R4.backdropColor };
          }
          m6.push({ label: y5, font: w4, textOffset: A5, options: { rotation: p6, color: H4, strokeColor: it, strokeWidth: K3, textAlign: It, textBaseline: U4, translation: [x5, M5], backdrop: xe2 } });
        }
        return m6;
      }
      _getXAxisLabelAlignment() {
        let { position: t, ticks: e } = this.options;
        if (-et(this.labelRotation))
          return t === "top" ? "left" : "right";
        let n3 = "center";
        return e.align === "start" ? n3 = "left" : e.align === "end" ? n3 = "right" : e.align === "inner" && (n3 = "inner"), n3;
      }
      _getYAxisLabelAlignment(t) {
        let { position: e, ticks: { crossAlign: s2, mirror: n3, padding: o3 } } = this.options, a2 = this._getLabelSizes(), r = t + o3, l4 = a2.widest.width, c3, h5;
        return e === "left" ? n3 ? (h5 = this.right + o3, s2 === "near" ? c3 = "left" : s2 === "center" ? (c3 = "center", h5 += l4 / 2) : (c3 = "right", h5 += l4)) : (h5 = this.right - r, s2 === "near" ? c3 = "right" : s2 === "center" ? (c3 = "center", h5 -= l4 / 2) : (c3 = "left", h5 = this.left)) : e === "right" ? n3 ? (h5 = this.left + o3, s2 === "near" ? c3 = "right" : s2 === "center" ? (c3 = "center", h5 -= l4 / 2) : (c3 = "left", h5 -= l4)) : (h5 = this.left + r, s2 === "near" ? c3 = "left" : s2 === "center" ? (c3 = "center", h5 += l4 / 2) : (c3 = "right", h5 = this.right)) : c3 = "right", { textAlign: c3, x: h5 };
      }
      _computeLabelArea() {
        if (this.options.ticks.mirror)
          return;
        let t = this.chart, e = this.options.position;
        if (e === "left" || e === "right")
          return { top: 0, left: this.left, bottom: t.height, right: this.right };
        if (e === "top" || e === "bottom")
          return { top: this.top, left: 0, bottom: this.bottom, right: t.width };
      }
      drawBackground() {
        let { ctx: t, options: { backgroundColor: e }, left: s2, top: n3, width: o3, height: a2 } = this;
        e && (t.save(), t.fillStyle = e, t.fillRect(s2, n3, o3, a2), t.restore());
      }
      getLineWidthForValue(t) {
        let e = this.options.grid;
        if (!this._isVisible() || !e.display)
          return 0;
        let n3 = this.ticks.findIndex((o3) => o3.value === t);
        return n3 >= 0 ? e.setContext(this.getContext(n3)).lineWidth : 0;
      }
      drawGrid(t) {
        let e = this.options.grid, s2 = this.ctx, n3 = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)), o3, a2, r = (l4, c3, h5) => {
          !h5.width || !h5.color || (s2.save(), s2.lineWidth = h5.width, s2.strokeStyle = h5.color, s2.setLineDash(h5.borderDash || []), s2.lineDashOffset = h5.borderDashOffset, s2.beginPath(), s2.moveTo(l4.x, l4.y), s2.lineTo(c3.x, c3.y), s2.stroke(), s2.restore());
        };
        if (e.display)
          for (o3 = 0, a2 = n3.length; o3 < a2; ++o3) {
            let l4 = n3[o3];
            e.drawOnChartArea && r({ x: l4.x1, y: l4.y1 }, { x: l4.x2, y: l4.y2 }, l4), e.drawTicks && r({ x: l4.tx1, y: l4.ty1 }, { x: l4.tx2, y: l4.ty2 }, { color: l4.tickColor, width: l4.tickWidth, borderDash: l4.tickBorderDash, borderDashOffset: l4.tickBorderDashOffset });
          }
      }
      drawBorder() {
        let { chart: t, ctx: e, options: { border: s2, grid: n3 } } = this, o3 = s2.setContext(this.getContext()), a2 = s2.display ? o3.width : 0;
        if (!a2)
          return;
        let r = n3.setContext(this.getContext(0)).lineWidth, l4 = this._borderValue, c3, h5, d5, u3;
        this.isHorizontal() ? (c3 = yt(t, this.left, a2) - a2 / 2, h5 = yt(t, this.right, r) + r / 2, d5 = u3 = l4) : (d5 = yt(t, this.top, a2) - a2 / 2, u3 = yt(t, this.bottom, r) + r / 2, c3 = h5 = l4), e.save(), e.lineWidth = o3.width, e.strokeStyle = o3.color, e.beginPath(), e.moveTo(c3, d5), e.lineTo(h5, u3), e.stroke(), e.restore();
      }
      drawLabels(t) {
        if (!this.options.ticks.display)
          return;
        let s2 = this.ctx, n3 = this._computeLabelArea();
        n3 && ne2(s2, n3);
        let o3 = this.getLabelItems(t);
        for (let a2 of o3) {
          let r = a2.options, l4 = a2.font, c3 = a2.label, h5 = a2.textOffset;
          vt(s2, c3, 0, h5, l4, r);
        }
        n3 && oe(s2);
      }
      drawTitle() {
        let { ctx: t, options: { position: e, title: s2, reverse: n3 } } = this;
        if (!s2.display)
          return;
        let o3 = j3(s2.font), a2 = X3(s2.padding), r = s2.align, l4 = o3.lineHeight / 2;
        e === "bottom" || e === "center" || O3(e) ? (l4 += a2.bottom, I3(s2.text) && (l4 += o3.lineHeight * (s2.text.length - 1))) : l4 += a2.top;
        let { titleX: c3, titleY: h5, maxWidth: d5, rotation: u3 } = Dr(this, l4, e, r);
        vt(t, s2.text, 0, 0, o3, { color: s2.color, maxWidth: d5, rotation: u3, textAlign: Pr(r, e, n3), textBaseline: "middle", translation: [c3, h5] });
      }
      draw(t) {
        this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
      }
      _layers() {
        let t = this.options, e = t.ticks && t.ticks.z || 0, s2 = P3(t.grid && t.grid.z, -1), n3 = P3(t.border && t.border.z, 0);
        return !this._isVisible() || this.draw !== i3.prototype.draw ? [{ z: e, draw: (o3) => {
          this.draw(o3);
        } }] : [{ z: s2, draw: (o3) => {
          this.drawBackground(), this.drawGrid(o3), this.drawTitle();
        } }, { z: n3, draw: () => {
          this.drawBorder();
        } }, { z: e, draw: (o3) => {
          this.drawLabels(o3);
        } }];
      }
      getMatchingVisibleMetas(t) {
        let e = this.chart.getSortedVisibleDatasetMetas(), s2 = this.axis + "AxisID", n3 = [], o3, a2;
        for (o3 = 0, a2 = e.length; o3 < a2; ++o3) {
          let r = e[o3];
          r[s2] === this.id && (!t || r.type === t) && n3.push(r);
        }
        return n3;
      }
      _resolveTickFontOptions(t) {
        let e = this.options.ticks.setContext(this.getContext(t));
        return j3(e.font);
      }
      _maxDigits() {
        let t = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / t;
      }
    };
    Kt = class {
      constructor(t, e, s2) {
        this.type = t, this.scope = e, this.override = s2, this.items = /* @__PURE__ */ Object.create(null);
      }
      isForType(t) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
      }
      register(t) {
        let e = Object.getPrototypeOf(t), s2;
        Ar(e) && (s2 = this.register(e));
        let n3 = this.items, o3 = t.id, a2 = this.scope + "." + o3;
        if (!o3)
          throw new Error("class does not have id: " + t);
        return o3 in n3 || (n3[o3] = t, Cr(t, a2, s2), this.override && W3.override(t.id, t.overrides)), a2;
      }
      get(t) {
        return this.items[t];
      }
      unregister(t) {
        let e = this.items, s2 = t.id, n3 = this.scope;
        s2 in e && delete e[s2], n3 && s2 in W3[n3] && (delete W3[n3][s2], this.override && delete xt[s2]);
      }
    };
    Qi = class {
      constructor() {
        this.controllers = new Kt(dt, "datasets", true), this.elements = new Kt(nt, "elements"), this.plugins = new Kt(Object, "plugins"), this.scales = new Kt(Et, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
      }
      add(...t) {
        this._each("register", t);
      }
      remove(...t) {
        this._each("unregister", t);
      }
      addControllers(...t) {
        this._each("register", t, this.controllers);
      }
      addElements(...t) {
        this._each("register", t, this.elements);
      }
      addPlugins(...t) {
        this._each("register", t, this.plugins);
      }
      addScales(...t) {
        this._each("register", t, this.scales);
      }
      getController(t) {
        return this._get(t, this.controllers, "controller");
      }
      getElement(t) {
        return this._get(t, this.elements, "element");
      }
      getPlugin(t) {
        return this._get(t, this.plugins, "plugin");
      }
      getScale(t) {
        return this._get(t, this.scales, "scale");
      }
      removeControllers(...t) {
        this._each("unregister", t, this.controllers);
      }
      removeElements(...t) {
        this._each("unregister", t, this.elements);
      }
      removePlugins(...t) {
        this._each("unregister", t, this.plugins);
      }
      removeScales(...t) {
        this._each("unregister", t, this.scales);
      }
      _each(t, e, s2) {
        [...e].forEach((n3) => {
          let o3 = s2 || this._getRegistryForType(n3);
          s2 || o3.isForType(n3) || o3 === this.plugins && n3.id ? this._exec(t, o3, n3) : T3(n3, (a2) => {
            let r = s2 || this._getRegistryForType(a2);
            this._exec(t, r, a2);
          });
        });
      }
      _exec(t, e, s2) {
        let n3 = De(t);
        E2(s2["before" + n3], [], s2), e[t](s2), E2(s2["after" + n3], [], s2);
      }
      _getRegistryForType(t) {
        for (let e = 0; e < this._typedRegistries.length; e++) {
          let s2 = this._typedRegistries[e];
          if (s2.isForType(t))
            return s2;
        }
        return this.plugins;
      }
      _get(t, e, s2) {
        let n3 = e.get(t);
        if (n3 === void 0)
          throw new Error('"' + t + '" is not a registered ' + s2 + ".");
        return n3;
      }
    };
    ht = new Qi();
    Zi = class {
      constructor() {
        this._init = [];
      }
      notify(t, e, s2, n3) {
        e === "beforeInit" && (this._init = this._createDescriptors(t, true), this._notify(this._init, t, "install"));
        let o3 = n3 ? this._descriptors(t).filter(n3) : this._descriptors(t), a2 = this._notify(o3, t, e, s2);
        return e === "afterDestroy" && (this._notify(o3, t, "stop"), this._notify(this._init, t, "uninstall")), a2;
      }
      _notify(t, e, s2, n3) {
        n3 = n3 || {};
        for (let o3 of t) {
          let a2 = o3.plugin, r = a2[s2], l4 = [e, n3, o3.options];
          if (E2(r, l4, a2) === false && n3.cancelable)
            return false;
        }
        return true;
      }
      invalidate() {
        L3(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
      }
      _descriptors(t) {
        if (this._cache)
          return this._cache;
        let e = this._cache = this._createDescriptors(t);
        return this._notifyStateChanges(t), e;
      }
      _createDescriptors(t, e) {
        let s2 = t && t.config, n3 = P3(s2.options && s2.options.plugins, {}), o3 = Lr(s2);
        return n3 === false && !e ? [] : Rr(t, o3, n3, e);
      }
      _notifyStateChanges(t) {
        let e = this._oldCache || [], s2 = this._cache, n3 = (o3, a2) => o3.filter((r) => !a2.some((l4) => r.plugin.id === l4.plugin.id));
        this._notify(n3(e, s2), t, "stop"), this._notify(n3(s2, e), t, "start");
      }
    };
    wn = /* @__PURE__ */ new Map();
    uo = /* @__PURE__ */ new Set();
    he = (i4, t, e) => {
      let s2 = gt(t, e);
      s2 !== void 0 && i4.add(s2);
    };
    is = class {
      constructor(t) {
        this._config = Wr(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
      }
      get platform() {
        return this._config.platform;
      }
      get type() {
        return this._config.type;
      }
      set type(t) {
        this._config.type = t;
      }
      get data() {
        return this._config.data;
      }
      set data(t) {
        this._config.data = ho(t);
      }
      get options() {
        return this._config.options;
      }
      set options(t) {
        this._config.options = t;
      }
      get plugins() {
        return this._config.plugins;
      }
      update() {
        let t = this._config;
        this.clearCache(), co(t);
      }
      clearCache() {
        this._scopeCache.clear(), this._resolverCache.clear();
      }
      datasetScopeKeys(t) {
        return We(t, () => [[`datasets.${t}`, ""]]);
      }
      datasetAnimationScopeKeys(t, e) {
        return We(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]);
      }
      datasetElementScopeKeys(t, e) {
        return We(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]);
      }
      pluginScopeKeys(t) {
        let e = t.id, s2 = this.type;
        return We(`${s2}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]]);
      }
      _cachedScopes(t, e) {
        let s2 = this._scopeCache, n3 = s2.get(t);
        return (!n3 || e) && (n3 = /* @__PURE__ */ new Map(), s2.set(t, n3)), n3;
      }
      getOptionScopes(t, e, s2) {
        let { options: n3, type: o3 } = this, a2 = this._cachedScopes(t, s2), r = a2.get(e);
        if (r)
          return r;
        let l4 = /* @__PURE__ */ new Set();
        e.forEach((h5) => {
          t && (l4.add(t), h5.forEach((d5) => he(l4, t, d5))), h5.forEach((d5) => he(l4, n3, d5)), h5.forEach((d5) => he(l4, xt[o3] || {}, d5)), h5.forEach((d5) => he(l4, W3, d5)), h5.forEach((d5) => he(l4, Le, d5));
        });
        let c3 = Array.from(l4);
        return c3.length === 0 && c3.push(/* @__PURE__ */ Object.create(null)), uo.has(e) && a2.set(e, c3), c3;
      }
      chartOptionScopes() {
        let { options: t, type: e } = this;
        return [t, xt[e] || {}, W3.datasets[e] || {}, { type: e }, W3, Le];
      }
      resolveNamedOptions(t, e, s2, n3 = [""]) {
        let o3 = { $shared: true }, { resolver: a2, subPrefixes: r } = Pn(this._resolverCache, t, n3), l4 = a2;
        if (Hr(a2, e)) {
          o3.$shared = false, s2 = ut(s2) ? s2() : s2;
          let c3 = this.createResolver(t, s2, r);
          l4 = Ot(a2, s2, c3);
        }
        for (let c3 of e)
          o3[c3] = l4[c3];
        return o3;
      }
      createResolver(t, e, s2 = [""], n3) {
        let { resolver: o3 } = Pn(this._resolverCache, t, s2);
        return O3(e) ? Ot(o3, e, void 0, n3) : o3;
      }
    };
    Nr = (i4) => O3(i4) && Object.getOwnPropertyNames(i4).some((t) => ut(i4[t]));
    jr = "4.4.2";
    $r = ["top", "bottom", "left", "right", "chartArea"];
    Ye = {};
    An = (i4) => {
      let t = fo(i4);
      return Object.values(Ye).filter((e) => e.canvas === t).pop();
    };
    qt = class {
      static defaults = W3;
      static instances = Ye;
      static overrides = xt;
      static registry = ht;
      static version = jr;
      static getChart = An;
      static register(...t) {
        ht.add(...t), Ln();
      }
      static unregister(...t) {
        ht.remove(...t), Ln();
      }
      constructor(t, e) {
        let s2 = this.config = new is(e), n3 = fo(t), o3 = An(n3);
        if (o3)
          throw new Error("Canvas is already in use. Chart with ID '" + o3.id + "' must be destroyed before the canvas with ID '" + o3.canvas.id + "' can be reused.");
        let a2 = s2.createResolver(s2.chartOptionScopes(), this.getContext());
        this.platform = new (s2.platform || gr(n3))(), this.platform.updateConfig(s2);
        let r = this.platform.acquireContext(n3, a2.aspectRatio), l4 = r && r.canvas, c3 = l4 && l4.height, h5 = l4 && l4.width;
        if (this.id = Ds(), this.ctx = r, this.canvas = l4, this.width = h5, this.height = c3, this._options = a2, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new Zi(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Bs((d5) => this.update(d5), a2.resizeDelay || 0), this._dataChanges = [], Ye[this.id] = this, !r || !l4) {
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }
        mt.listen(this, "complete", On), mt.listen(this, "progress", Ur), this._initialize(), this.attached && this.update();
      }
      get aspectRatio() {
        let { options: { aspectRatio: t, maintainAspectRatio: e }, width: s2, height: n3, _aspectRatio: o3 } = this;
        return L3(t) ? e && o3 ? o3 : n3 ? s2 / n3 : null : t;
      }
      get data() {
        return this.config.data;
      }
      set data(t) {
        this.config.data = t;
      }
      get options() {
        return this._options;
      }
      set options(t) {
        this.config.options = t;
      }
      get registry() {
        return ht;
      }
      _initialize() {
        return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : Pi(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
      }
      clear() {
        return xi(this.canvas, this.ctx), this;
      }
      stop() {
        return mt.stop(this), this;
      }
      resize(t, e) {
        mt.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e);
      }
      _resize(t, e) {
        let s2 = this.options, n3 = this.canvas, o3 = s2.maintainAspectRatio && this.aspectRatio, a2 = this.platform.getMaximumSize(n3, t, e, o3), r = s2.devicePixelRatio || this.platform.getDevicePixelRatio(), l4 = this.width ? "resize" : "attach";
        this.width = a2.width, this.height = a2.height, this._aspectRatio = this.aspectRatio, Pi(this, r, true) && (this.notifyPlugins("resize", { size: a2 }), E2(s2.onResize, [this, a2], this), this.attached && this._doResize(l4) && this.render());
      }
      ensureScalesHaveIDs() {
        let e = this.options.scales || {};
        T3(e, (s2, n3) => {
          s2.id = n3;
        });
      }
      buildOrUpdateScales() {
        let t = this.options, e = t.scales, s2 = this.scales, n3 = Object.keys(s2).reduce((a2, r) => (a2[r] = false, a2), {}), o3 = [];
        e && (o3 = o3.concat(Object.keys(e).map((a2) => {
          let r = e[a2], l4 = es(a2, r), c3 = l4 === "r", h5 = l4 === "x";
          return { options: r, dposition: c3 ? "chartArea" : h5 ? "bottom" : "left", dtype: c3 ? "radialLinear" : h5 ? "category" : "linear" };
        }))), T3(o3, (a2) => {
          let r = a2.options, l4 = r.id, c3 = es(l4, r), h5 = P3(r.type, a2.dtype);
          (r.position === void 0 || Dn(r.position, c3) !== Dn(a2.dposition)) && (r.position = a2.dposition), n3[l4] = true;
          let d5 = null;
          if (l4 in s2 && s2[l4].type === h5)
            d5 = s2[l4];
          else {
            let u3 = ht.getScale(h5);
            d5 = new u3({ id: l4, type: h5, ctx: this.ctx, chart: this }), s2[d5.id] = d5;
          }
          d5.init(r, t);
        }), T3(n3, (a2, r) => {
          a2 || delete s2[r];
        }), T3(s2, (a2) => {
          q3.configure(this, a2, a2.options), q3.addBox(this, a2);
        });
      }
      _updateMetasets() {
        let t = this._metasets, e = this.data.datasets.length, s2 = t.length;
        if (t.sort((n3, o3) => n3.index - o3.index), s2 > e) {
          for (let n3 = e; n3 < s2; ++n3)
            this._destroyDatasetMeta(n3);
          t.splice(e, s2 - e);
        }
        this._sortedMetasets = t.slice(0).sort(Cn("order", "index"));
      }
      _removeUnreferencedMetasets() {
        let { _metasets: t, data: { datasets: e } } = this;
        t.length > e.length && delete this._stacks, t.forEach((s2, n3) => {
          e.filter((o3) => o3 === s2._dataset).length === 0 && this._destroyDatasetMeta(n3);
        });
      }
      buildOrUpdateControllers() {
        let t = [], e = this.data.datasets, s2, n3;
        for (this._removeUnreferencedMetasets(), s2 = 0, n3 = e.length; s2 < n3; s2++) {
          let o3 = e[s2], a2 = this.getDatasetMeta(s2), r = o3.type || this.config.type;
          if (a2.type && a2.type !== r && (this._destroyDatasetMeta(s2), a2 = this.getDatasetMeta(s2)), a2.type = r, a2.indexAxis = o3.indexAxis || ts(r, this.options), a2.order = o3.order || 0, a2.index = s2, a2.label = "" + o3.label, a2.visible = this.isDatasetVisible(s2), a2.controller)
            a2.controller.updateIndex(s2), a2.controller.linkScales();
          else {
            let l4 = ht.getController(r), { datasetElementType: c3, dataElementType: h5 } = W3.datasets[r];
            Object.assign(l4, { dataElementType: ht.getElement(h5), datasetElementType: c3 && ht.getElement(c3) }), a2.controller = new l4(this, s2), t.push(a2.controller);
          }
        }
        return this._updateMetasets(), t;
      }
      _resetElements() {
        T3(this.data.datasets, (t, e) => {
          this.getDatasetMeta(e).controller.reset();
        }, this);
      }
      reset() {
        this._resetElements(), this.notifyPlugins("reset");
      }
      update(t) {
        let e = this.config;
        e.update();
        let s2 = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), n3 = this._animationsDisabled = !s2.animation;
        if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: t, cancelable: true }) === false)
          return;
        let o3 = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let a2 = 0;
        for (let c3 = 0, h5 = this.data.datasets.length; c3 < h5; c3++) {
          let { controller: d5 } = this.getDatasetMeta(c3), u3 = !n3 && o3.indexOf(d5) === -1;
          d5.buildOrUpdateElements(u3), a2 = Math.max(+d5.getMaxOverflow(), a2);
        }
        a2 = this._minPadding = s2.layout.autoPadding ? a2 : 0, this._updateLayout(a2), n3 || T3(o3, (c3) => {
          c3.reset();
        }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(Cn("z", "_idx"));
        let { _active: r, _lastEvent: l4 } = this;
        l4 ? this._eventHandler(l4, true) : r.length && this._updateHoverStyles(r, r, true), this.render();
      }
      _updateScales() {
        T3(this.scales, (t) => {
          q3.removeBox(this, t);
        }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
      }
      _checkEventBindings() {
        let t = this.options, e = new Set(Object.keys(this._listeners)), s2 = new Set(t.events);
        (!ai(e, s2) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
      }
      _updateHiddenIndices() {
        let { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];
        for (let { method: s2, start: n3, count: o3 } of e) {
          let a2 = s2 === "_removeElements" ? -o3 : o3;
          Yr(t, n3, a2);
        }
      }
      _getUniformDataChanges() {
        let t = this._dataChanges;
        if (!t || !t.length)
          return;
        this._dataChanges = [];
        let e = this.data.datasets.length, s2 = (o3) => new Set(t.filter((a2) => a2[0] === o3).map((a2, r) => r + "," + a2.splice(1).join(","))), n3 = s2(0);
        for (let o3 = 1; o3 < e; o3++)
          if (!ai(n3, s2(o3)))
            return;
        return Array.from(n3).map((o3) => o3.split(",")).map((o3) => ({ method: o3[1], start: +o3[2], count: +o3[3] }));
      }
      _updateLayout(t) {
        if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false)
          return;
        q3.update(this, this.width, this.height, t);
        let e = this.chartArea, s2 = e.width <= 0 || e.height <= 0;
        this._layers = [], T3(this.boxes, (n3) => {
          s2 && n3.position === "chartArea" || (n3.configure && n3.configure(), this._layers.push(...n3._layers()));
        }, this), this._layers.forEach((n3, o3) => {
          n3._idx = o3;
        }), this.notifyPlugins("afterLayout");
      }
      _updateDatasets(t) {
        if (this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: true }) !== false) {
          for (let e = 0, s2 = this.data.datasets.length; e < s2; ++e)
            this.getDatasetMeta(e).controller.configure();
          for (let e = 0, s2 = this.data.datasets.length; e < s2; ++e)
            this._updateDataset(e, ut(t) ? t({ datasetIndex: e }) : t);
          this.notifyPlugins("afterDatasetsUpdate", { mode: t });
        }
      }
      _updateDataset(t, e) {
        let s2 = this.getDatasetMeta(t), n3 = { meta: s2, index: t, mode: e, cancelable: true };
        this.notifyPlugins("beforeDatasetUpdate", n3) !== false && (s2.controller._update(e), n3.cancelable = false, this.notifyPlugins("afterDatasetUpdate", n3));
      }
      render() {
        this.notifyPlugins("beforeRender", { cancelable: true }) !== false && (mt.has(this) ? this.attached && !mt.running(this) && mt.start(this) : (this.draw(), On({ chart: this })));
      }
      draw() {
        let t;
        if (this._resizeBeforeDraw) {
          let { width: s2, height: n3 } = this._resizeBeforeDraw;
          this._resize(s2, n3), this._resizeBeforeDraw = null;
        }
        if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: true }) === false)
          return;
        let e = this._layers;
        for (t = 0; t < e.length && e[t].z <= 0; ++t)
          e[t].draw(this.chartArea);
        for (this._drawDatasets(); t < e.length; ++t)
          e[t].draw(this.chartArea);
        this.notifyPlugins("afterDraw");
      }
      _getSortedDatasetMetas(t) {
        let e = this._sortedMetasets, s2 = [], n3, o3;
        for (n3 = 0, o3 = e.length; n3 < o3; ++n3) {
          let a2 = e[n3];
          (!t || a2.visible) && s2.push(a2);
        }
        return s2;
      }
      getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
      }
      _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false)
          return;
        let t = this.getSortedVisibleDatasetMetas();
        for (let e = t.length - 1; e >= 0; --e)
          this._drawDataset(t[e]);
        this.notifyPlugins("afterDatasetsDraw");
      }
      _drawDataset(t) {
        let e = this.ctx, s2 = t._clip, n3 = !s2.disabled, o3 = Kr(t, this.chartArea), a2 = { meta: t, index: t.index, cancelable: true };
        this.notifyPlugins("beforeDatasetDraw", a2) !== false && (n3 && ne2(e, { left: s2.left === false ? 0 : o3.left - s2.left, right: s2.right === false ? this.width : o3.right + s2.right, top: s2.top === false ? 0 : o3.top - s2.top, bottom: s2.bottom === false ? this.height : o3.bottom + s2.bottom }), t.controller.draw(), n3 && oe(e), a2.cancelable = false, this.notifyPlugins("afterDatasetDraw", a2));
      }
      isPointInArea(t) {
        return at(t, this.chartArea, this._minPadding);
      }
      getElementsAtEventForMode(t, e, s2, n3) {
        let o3 = qa.modes[e];
        return typeof o3 == "function" ? o3(this, t, s2, n3) : [];
      }
      getDatasetMeta(t) {
        let e = this.data.datasets[t], s2 = this._metasets, n3 = s2.filter((o3) => o3 && o3._dataset === e).pop();
        return n3 || (n3 = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: false }, s2.push(n3)), n3;
      }
      getContext() {
        return this.$context || (this.$context = pt(null, { chart: this, type: "chart" }));
      }
      getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(t) {
        let e = this.data.datasets[t];
        if (!e)
          return false;
        let s2 = this.getDatasetMeta(t);
        return typeof s2.hidden == "boolean" ? !s2.hidden : !e.hidden;
      }
      setDatasetVisibility(t, e) {
        let s2 = this.getDatasetMeta(t);
        s2.hidden = !e;
      }
      toggleDataVisibility(t) {
        this._hiddenIndices[t] = !this._hiddenIndices[t];
      }
      getDataVisibility(t) {
        return !this._hiddenIndices[t];
      }
      _updateVisibility(t, e, s2) {
        let n3 = s2 ? "show" : "hide", o3 = this.getDatasetMeta(t), a2 = o3.controller._resolveAnimations(void 0, n3);
        Nt(e) ? (o3.data[e].hidden = !s2, this.update()) : (this.setDatasetVisibility(t, s2), a2.update(o3, { visible: s2 }), this.update((r) => r.datasetIndex === t ? n3 : void 0));
      }
      hide(t, e) {
        this._updateVisibility(t, e, false);
      }
      show(t, e) {
        this._updateVisibility(t, e, true);
      }
      _destroyDatasetMeta(t) {
        let e = this._metasets[t];
        e && e.controller && e.controller._destroy(), delete this._metasets[t];
      }
      _stop() {
        let t, e;
        for (this.stop(), mt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)
          this._destroyDatasetMeta(t);
      }
      destroy() {
        this.notifyPlugins("beforeDestroy");
        let { canvas: t, ctx: e } = this;
        this._stop(), this.config.clearCache(), t && (this.unbindEvents(), xi(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Ye[this.id], this.notifyPlugins("afterDestroy");
      }
      toBase64Image(...t) {
        return this.canvas.toDataURL(...t);
      }
      bindEvents() {
        this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
      }
      bindUserEvents() {
        let t = this._listeners, e = this.platform, s2 = (o3, a2) => {
          e.addEventListener(this, o3, a2), t[o3] = a2;
        }, n3 = (o3, a2, r) => {
          o3.offsetX = a2, o3.offsetY = r, this._eventHandler(o3);
        };
        T3(this.options.events, (o3) => s2(o3, n3));
      }
      bindResponsiveEvents() {
        this._responsiveListeners || (this._responsiveListeners = {});
        let t = this._responsiveListeners, e = this.platform, s2 = (l4, c3) => {
          e.addEventListener(this, l4, c3), t[l4] = c3;
        }, n3 = (l4, c3) => {
          t[l4] && (e.removeEventListener(this, l4, c3), delete t[l4]);
        }, o3 = (l4, c3) => {
          this.canvas && this.resize(l4, c3);
        }, a2, r = () => {
          n3("attach", r), this.attached = true, this.resize(), s2("resize", o3), s2("detach", a2);
        };
        a2 = () => {
          this.attached = false, n3("resize", o3), this._stop(), this._resize(0, 0), s2("attach", r);
        }, e.isAttached(this.canvas) ? r() : a2();
      }
      unbindEvents() {
        T3(this._listeners, (t, e) => {
          this.platform.removeEventListener(this, e, t);
        }), this._listeners = {}, T3(this._responsiveListeners, (t, e) => {
          this.platform.removeEventListener(this, e, t);
        }), this._responsiveListeners = void 0;
      }
      updateHoverStyle(t, e, s2) {
        let n3 = s2 ? "set" : "remove", o3, a2, r, l4;
        for (e === "dataset" && (o3 = this.getDatasetMeta(t[0].datasetIndex), o3.controller["_" + n3 + "DatasetHoverStyle"]()), r = 0, l4 = t.length; r < l4; ++r) {
          a2 = t[r];
          let c3 = a2 && this.getDatasetMeta(a2.datasetIndex).controller;
          c3 && c3[n3 + "HoverStyle"](a2.element, a2.datasetIndex, a2.index);
        }
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(t) {
        let e = this._active || [], s2 = t.map(({ datasetIndex: o3, index: a2 }) => {
          let r = this.getDatasetMeta(o3);
          if (!r)
            throw new Error("No dataset found at index " + o3);
          return { datasetIndex: o3, element: r.data[a2], index: a2 };
        });
        !ie(s2, e) && (this._active = s2, this._lastEvent = null, this._updateHoverStyles(s2, e));
      }
      notifyPlugins(t, e, s2) {
        return this._plugins.notify(this, t, e, s2);
      }
      isPluginEnabled(t) {
        return this._plugins._cache.filter((e) => e.plugin.id === t).length === 1;
      }
      _updateHoverStyles(t, e, s2) {
        let n3 = this.options.hover, o3 = (l4, c3) => l4.filter((h5) => !c3.some((d5) => h5.datasetIndex === d5.datasetIndex && h5.index === d5.index)), a2 = o3(e, t), r = s2 ? t : o3(t, e);
        a2.length && this.updateHoverStyle(a2, n3.mode, false), r.length && n3.mode && this.updateHoverStyle(r, n3.mode, true);
      }
      _eventHandler(t, e) {
        let s2 = { event: t, replay: e, cancelable: true, inChartArea: this.isPointInArea(t) }, n3 = (a2) => (a2.options.events || this.options.events).includes(t.native.type);
        if (this.notifyPlugins("beforeEvent", s2, n3) === false)
          return;
        let o3 = this._handleEvent(t, e, s2.inChartArea);
        return s2.cancelable = false, this.notifyPlugins("afterEvent", s2, n3), (o3 || s2.changed) && this.render(), this;
      }
      _handleEvent(t, e, s2) {
        let { _active: n3 = [], options: o3 } = this, a2 = e, r = this._getActiveElements(t, n3, s2, a2), l4 = As(t), c3 = Xr(t, this._lastEvent, s2, l4);
        s2 && (this._lastEvent = null, E2(o3.onHover, [t, r, this], this), l4 && E2(o3.onClick, [t, r, this], this));
        let h5 = !ie(r, n3);
        return (h5 || e) && (this._active = r, this._updateHoverStyles(r, n3, e)), this._lastEvent = c3, h5;
      }
      _getActiveElements(t, e, s2, n3) {
        if (t.type === "mouseout")
          return [];
        if (!s2)
          return e;
        let o3 = this.options.hover;
        return this.getElementsAtEventForMode(t, o3.mode, o3, n3);
      }
    };
    ss = class extends nt {
      static id = "arc";
      static defaults = { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: true };
      static defaultRoutes = { backgroundColor: "backgroundColor" };
      static descriptors = { _scriptable: true, _indexable: (t) => t !== "borderDash" };
      circumference;
      endAngle;
      fullCircles;
      innerRadius;
      outerRadius;
      pixelMargin;
      startAngle;
      constructor(t) {
        super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
      }
      inRange(t, e, s2) {
        let n3 = this.getProps(["x", "y"], s2), { angle: o3, distance: a2 } = hi(n3, { x: t, y: e }), { startAngle: r, endAngle: l4, innerRadius: c3, outerRadius: h5, circumference: d5 } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], s2), u3 = (this.options.spacing + this.options.borderWidth) / 2, g4 = P3(d5, l4 - r) >= F3 || jt(o3, r, l4), p6 = lt(a2, c3 + u3, h5 + u3);
        return g4 && p6;
      }
      getCenterPoint(t) {
        let { x: e, y: s2, startAngle: n3, endAngle: o3, innerRadius: a2, outerRadius: r } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), { offset: l4, spacing: c3 } = this.options, h5 = (n3 + o3) / 2, d5 = (a2 + r + c3 + l4) / 2;
        return { x: e + Math.cos(h5) * d5, y: s2 + Math.sin(h5) * d5 };
      }
      tooltipPosition(t) {
        return this.getCenterPoint(t);
      }
      draw(t) {
        let { options: e, circumference: s2 } = this, n3 = (e.offset || 0) / 4, o3 = (e.spacing || 0) / 2, a2 = e.circular;
        if (this.pixelMargin = e.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = s2 > F3 ? Math.floor(s2 / F3) : 0, s2 === 0 || this.innerRadius < 0 || this.outerRadius < 0)
          return;
        t.save();
        let r = (this.startAngle + this.endAngle) / 2;
        t.translate(Math.cos(r) * n3, Math.sin(r) * n3);
        let l4 = 1 - Math.sin(Math.min(z2, s2 || 0)), c3 = n3 * l4;
        t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, Qr(t, this, c3, o3, a2), Zr(t, this, c3, o3, a2), t.restore();
      }
    };
    rl = typeof Path2D == "function";
    Gt = class extends nt {
      static id = "line";
      static defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: true, cubicInterpolationMode: "default", fill: false, spanGaps: false, stepped: false, tension: 0 };
      static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };
      static descriptors = { _scriptable: true, _indexable: (t) => t !== "borderDash" && t !== "fill" };
      constructor(t) {
        super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, t && Object.assign(this, t);
      }
      updateControlPoints(t, e) {
        let s2 = this.options;
        if ((s2.tension || s2.cubicInterpolationMode === "monotone") && !s2.stepped && !this._pointsUpdated) {
          let n3 = s2.spanGaps ? this._loop : this._fullLoop;
          qs(this._points, s2, t, n3, e), this._pointsUpdated = true;
        }
      }
      set points(t) {
        this._points = t, delete this._segments, delete this._path, this._pointsUpdated = false;
      }
      get points() {
        return this._points;
      }
      get segments() {
        return this._segments || (this._segments = en(this, this.options.segment));
      }
      first() {
        let t = this.segments, e = this.points;
        return t.length && e[t[0].start];
      }
      last() {
        let t = this.segments, e = this.points, s2 = t.length;
        return s2 && e[t[s2 - 1].end];
      }
      interpolate(t, e) {
        let s2 = this.options, n3 = t[e], o3 = this.points, a2 = Li(this, { property: e, start: n3, end: n3 });
        if (!a2.length)
          return;
        let r = [], l4 = nl(s2), c3, h5;
        for (c3 = 0, h5 = a2.length; c3 < h5; ++c3) {
          let { start: d5, end: u3 } = a2[c3], f4 = o3[d5], g4 = o3[u3];
          if (f4 === g4) {
            r.push(f4);
            continue;
          }
          let p6 = Math.abs((n3 - f4[e]) / (g4[e] - f4[e])), m6 = l4(f4, g4, p6, s2.stepped);
          m6[e] = t[e], r.push(m6);
        }
        return r.length === 1 ? r[0] : r;
      }
      pathSegment(t, e, s2) {
        return ns(this)(t, this, e, s2);
      }
      path(t, e, s2) {
        let n3 = this.segments, o3 = ns(this), a2 = this._loop;
        e = e || 0, s2 = s2 || this.points.length - e;
        for (let r of n3)
          a2 &= o3(t, this, r, { start: e, end: e + s2 - 1 });
        return !!a2;
      }
      draw(t, e, s2, n3) {
        let o3 = this.options || {};
        (this.points || []).length && o3.borderWidth && (t.save(), ll(t, this, s2, n3), t.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
      }
    };
    os = class extends nt {
      static id = "point";
      parsed;
      skip;
      stop;
      static defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 };
      static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };
      constructor(t) {
        super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
      }
      inRange(t, e, s2) {
        let n3 = this.options, { x: o3, y: a2 } = this.getProps(["x", "y"], s2);
        return Math.pow(t - o3, 2) + Math.pow(e - a2, 2) < Math.pow(n3.hitRadius + n3.radius, 2);
      }
      inXRange(t, e) {
        return Tn(this, t, "x", e);
      }
      inYRange(t, e) {
        return Tn(this, t, "y", e);
      }
      getCenterPoint(t) {
        let { x: e, y: s2 } = this.getProps(["x", "y"], t);
        return { x: e, y: s2 };
      }
      size(t) {
        t = t || this.options || {};
        let e = t.radius || 0;
        e = Math.max(e, e && t.hoverRadius || 0);
        let s2 = e && t.borderWidth || 0;
        return (e + s2) * 2;
      }
      draw(t, e) {
        let s2 = this.options;
        this.skip || s2.radius < 0.1 || !at(this, e, this.size(s2) / 2) || (t.strokeStyle = s2.borderColor, t.lineWidth = s2.borderWidth, t.fillStyle = s2.backgroundColor, Te(t, s2, this.x, this.y));
      }
      getRange() {
        let t = this.options || {};
        return t.radius + t.hitRadius;
      }
    };
    as = class extends nt {
      static id = "bar";
      static defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 };
      static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" };
      constructor(t) {
        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
      }
      draw(t) {
        let { inflateAmount: e, options: { borderColor: s2, backgroundColor: n3 } } = this, { inner: o3, outer: a2 } = dl(this), r = ul(a2.radius) ? Ut : fl;
        t.save(), (a2.w !== o3.w || a2.h !== o3.h) && (t.beginPath(), r(t, Vi(a2, e, o3)), t.clip(), r(t, Vi(o3, -e, a2)), t.fillStyle = s2, t.fill("evenodd")), t.beginPath(), r(t, Vi(o3, e)), t.fillStyle = n3, t.fill(), t.restore();
      }
      inRange(t, e, s2) {
        return Bi(this, t, e, s2);
      }
      inXRange(t, e) {
        return Bi(this, t, null, e);
      }
      inYRange(t, e) {
        return Bi(this, null, t, e);
      }
      getCenterPoint(t) {
        let { x: e, y: s2, base: n3, horizontal: o3 } = this.getProps(["x", "y", "base", "horizontal"], t);
        return { x: o3 ? (e + n3) / 2 : e, y: o3 ? s2 : (s2 + n3) / 2 };
      }
      getRange(t) {
        return t === "x" ? this.width / 2 : this.height / 2;
      }
    };
    gl = Object.freeze({ __proto__: null, ArcElement: ss, BarElement: as, LineElement: Gt, PointElement: os });
    rs = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"];
    Rn = rs.map((i4) => i4.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
    yl = { id: "colors", defaults: { enabled: true, forceOverride: false }, beforeLayout(i4, t, e) {
      if (!e.enabled)
        return;
      let { data: { datasets: s2 }, options: n3 } = i4.config, { elements: o3 } = n3;
      if (!e.forceOverride && (En(s2) || xl(n3) || o3 && En(o3)))
        return;
      let a2 = _l(i4);
      s2.forEach(a2);
    } };
    Sl = { id: "decimation", defaults: { algorithm: "min-max", enabled: false }, beforeElementsUpdate: (i4, t, e) => {
      if (!e.enabled) {
        In(i4);
        return;
      }
      let s2 = i4.width;
      i4.data.datasets.forEach((n3, o3) => {
        let { _data: a2, indexAxis: r } = n3, l4 = i4.getDatasetMeta(o3), c3 = a2 || n3.data;
        if (Yt([r, i4.options.indexAxis]) === "y" || !l4.controller.supportsDecimation)
          return;
        let h5 = i4.scales[l4.xAxisID];
        if (h5.type !== "linear" && h5.type !== "time" || i4.options.parsing)
          return;
        let { start: d5, count: u3 } = kl(l4, c3), f4 = e.threshold || 4 * s2;
        if (u3 <= f4) {
          xo(n3);
          return;
        }
        L3(a2) && (n3._data = c3, delete n3.data, Object.defineProperty(n3, "data", { configurable: true, enumerable: true, get: function() {
          return this._decimated;
        }, set: function(p6) {
          this._data = p6;
        } }));
        let g4;
        switch (e.algorithm) {
          case "lttb":
            g4 = vl(c3, d5, u3, s2, e);
            break;
          case "min-max":
            g4 = Ml(c3, d5, u3, s2);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);
        }
        n3._decimated = g4;
      });
    }, destroy(i4) {
      In(i4);
    } };
    Qe = class {
      constructor(t) {
        this.x = t.x, this.y = t.y, this.radius = t.radius;
      }
      pathSegment(t, e, s2) {
        let { x: n3, y: o3, radius: a2 } = this;
        return e = e || { start: 0, end: F3 }, t.arc(n3, o3, a2, e.end, e.start, true), !s2.bounds;
      }
      interpolate(t) {
        let { x: e, y: s2, radius: n3 } = this, o3 = t.angle;
        return { x: e + Math.cos(o3) * n3, y: s2 + Math.sin(o3) * n3, angle: o3 };
      }
    };
    $l = { id: "filler", afterDatasetsUpdate(i4, t, e) {
      let s2 = (i4.data.datasets || []).length, n3 = [], o3, a2, r, l4;
      for (a2 = 0; a2 < s2; ++a2)
        o3 = i4.getDatasetMeta(a2), r = o3.dataset, l4 = null, r && r.options && r instanceof Gt && (l4 = { visible: i4.isDatasetVisible(a2), index: a2, fill: Cl(r, a2, s2), chart: i4, axis: o3.controller.options.indexAxis, scale: o3.vScale, line: r }), o3.$filler = l4, n3.push(l4);
      for (a2 = 0; a2 < s2; ++a2)
        l4 = n3[a2], !(!l4 || l4.fill === false) && (l4.fill = Dl(n3, a2, e.propagate));
    }, beforeDraw(i4, t, e) {
      let s2 = e.drawTime === "beforeDraw", n3 = i4.getSortedVisibleDatasetMetas(), o3 = i4.chartArea;
      for (let a2 = n3.length - 1; a2 >= 0; --a2) {
        let r = n3[a2].$filler;
        r && (r.line.updateControlPoints(o3, r.axis), s2 && r.fill && Wi(i4.ctx, r, o3));
      }
    }, beforeDatasetsDraw(i4, t, e) {
      if (e.drawTime !== "beforeDatasetsDraw")
        return;
      let s2 = i4.getSortedVisibleDatasetMetas();
      for (let n3 = s2.length - 1; n3 >= 0; --n3) {
        let o3 = s2[n3].$filler;
        Fn(o3) && Wi(i4.ctx, o3, i4.chartArea);
      }
    }, beforeDatasetDraw(i4, t, e) {
      let s2 = t.meta.$filler;
      !Fn(s2) || e.drawTime !== "beforeDatasetDraw" || Wi(i4.ctx, s2, i4.chartArea);
    }, defaults: { propagate: true, drawTime: "beforeDatasetDraw" } };
    Nn = (i4, t) => {
      let { boxHeight: e = t, boxWidth: s2 = t } = i4;
      return i4.usePointStyle && (e = Math.min(e, t), s2 = i4.pointStyleWidth || Math.min(s2, t)), { boxWidth: s2, boxHeight: e, itemHeight: Math.max(t, e) };
    };
    Ul = (i4, t) => i4 !== null && t !== null && i4.datasetIndex === t.datasetIndex && i4.index === t.index;
    Ze = class extends nt {
      constructor(t) {
        super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
      }
      update(t, e, s2) {
        this.maxWidth = t, this.maxHeight = e, this._margins = s2, this.setDimensions(), this.buildLabels(), this.fit();
      }
      setDimensions() {
        this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
      }
      buildLabels() {
        let t = this.options.labels || {}, e = E2(t.generateLabels, [this.chart], this) || [];
        t.filter && (e = e.filter((s2) => t.filter(s2, this.chart.data))), t.sort && (e = e.sort((s2, n3) => t.sort(s2, n3, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;
      }
      fit() {
        let { options: t, ctx: e } = this;
        if (!t.display) {
          this.width = this.height = 0;
          return;
        }
        let s2 = t.labels, n3 = j3(s2.font), o3 = n3.size, a2 = this._computeTitleHeight(), { boxWidth: r, itemHeight: l4 } = Nn(s2, o3), c3, h5;
        e.font = n3.string, this.isHorizontal() ? (c3 = this.maxWidth, h5 = this._fitRows(a2, o3, r, l4) + 10) : (h5 = this.maxHeight, c3 = this._fitCols(a2, n3, r, l4) + 10), this.width = Math.min(c3, t.maxWidth || this.maxWidth), this.height = Math.min(h5, t.maxHeight || this.maxHeight);
      }
      _fitRows(t, e, s2, n3) {
        let { ctx: o3, maxWidth: a2, options: { labels: { padding: r } } } = this, l4 = this.legendHitBoxes = [], c3 = this.lineWidths = [0], h5 = n3 + r, d5 = t;
        o3.textAlign = "left", o3.textBaseline = "middle";
        let u3 = -1, f4 = -h5;
        return this.legendItems.forEach((g4, p6) => {
          let m6 = s2 + e / 2 + o3.measureText(g4.text).width;
          (p6 === 0 || c3[c3.length - 1] + m6 + 2 * r > a2) && (d5 += h5, c3[c3.length - (p6 > 0 ? 0 : 1)] = 0, f4 += h5, u3++), l4[p6] = { left: 0, top: f4, row: u3, width: m6, height: n3 }, c3[c3.length - 1] += m6 + r;
        }), d5;
      }
      _fitCols(t, e, s2, n3) {
        let { ctx: o3, maxHeight: a2, options: { labels: { padding: r } } } = this, l4 = this.legendHitBoxes = [], c3 = this.columnSizes = [], h5 = a2 - t, d5 = r, u3 = 0, f4 = 0, g4 = 0, p6 = 0;
        return this.legendItems.forEach((m6, b5) => {
          let { itemWidth: _5, itemHeight: v5 } = Yl(s2, e, o3, m6, n3);
          b5 > 0 && f4 + v5 + 2 * r > h5 && (d5 += u3 + r, c3.push({ width: u3, height: f4 }), g4 += u3 + r, p6++, u3 = f4 = 0), l4[b5] = { left: g4, top: f4, col: p6, width: _5, height: v5 }, u3 = Math.max(u3, _5), f4 += v5 + r;
        }), d5 += u3, c3.push({ width: u3, height: f4 }), d5;
      }
      adjustHitBoxes() {
        if (!this.options.display)
          return;
        let t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: s2, labels: { padding: n3 }, rtl: o3 } } = this, a2 = Lt(o3, this.left, this.width);
        if (this.isHorizontal()) {
          let r = 0, l4 = Y3(s2, this.left + n3, this.right - this.lineWidths[r]);
          for (let c3 of e)
            r !== c3.row && (r = c3.row, l4 = Y3(s2, this.left + n3, this.right - this.lineWidths[r])), c3.top += this.top + t + n3, c3.left = a2.leftForLtr(a2.x(l4), c3.width), l4 += c3.width + n3;
        } else {
          let r = 0, l4 = Y3(s2, this.top + t + n3, this.bottom - this.columnSizes[r].height);
          for (let c3 of e)
            c3.col !== r && (r = c3.col, l4 = Y3(s2, this.top + t + n3, this.bottom - this.columnSizes[r].height)), c3.top = l4, c3.left += this.left + n3, c3.left = a2.leftForLtr(a2.x(c3.left), c3.width), l4 += c3.height + n3;
        }
      }
      isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom";
      }
      draw() {
        if (this.options.display) {
          let t = this.ctx;
          ne2(t, this), this._draw(), oe(t);
        }
      }
      _draw() {
        let { options: t, columnSizes: e, lineWidths: s2, ctx: n3 } = this, { align: o3, labels: a2 } = t, r = W3.color, l4 = Lt(t.rtl, this.left, this.width), c3 = j3(a2.font), { padding: h5 } = a2, d5 = c3.size, u3 = d5 / 2, f4;
        this.drawTitle(), n3.textAlign = l4.textAlign("left"), n3.textBaseline = "middle", n3.lineWidth = 0.5, n3.font = c3.string;
        let { boxWidth: g4, boxHeight: p6, itemHeight: m6 } = Nn(a2, d5), b5 = function(M5, k4, S6) {
          if (isNaN(g4) || g4 <= 0 || isNaN(p6) || p6 < 0)
            return;
          n3.save();
          let w4 = P3(S6.lineWidth, 1);
          if (n3.fillStyle = P3(S6.fillStyle, r), n3.lineCap = P3(S6.lineCap, "butt"), n3.lineDashOffset = P3(S6.lineDashOffset, 0), n3.lineJoin = P3(S6.lineJoin, "miter"), n3.lineWidth = w4, n3.strokeStyle = P3(S6.strokeStyle, r), n3.setLineDash(P3(S6.lineDash, [])), a2.usePointStyle) {
            let D5 = { radius: p6 * Math.SQRT2 / 2, pointStyle: S6.pointStyle, rotation: S6.rotation, borderWidth: w4 }, C5 = l4.xPlus(M5, g4 / 2), A5 = k4 + u3;
            yi(n3, D5, C5, A5, a2.pointStyleWidth && g4);
          } else {
            let D5 = k4 + Math.max((d5 - p6) / 2, 0), C5 = l4.leftForLtr(M5, g4), A5 = Mt(S6.borderRadius);
            n3.beginPath(), Object.values(A5).some((U4) => U4 !== 0) ? Ut(n3, { x: C5, y: D5, w: g4, h: p6, radius: A5 }) : n3.rect(C5, D5, g4, p6), n3.fill(), w4 !== 0 && n3.stroke();
          }
          n3.restore();
        }, _5 = function(M5, k4, S6) {
          vt(n3, S6.text, M5, k4 + m6 / 2, c3, { strikethrough: S6.hidden, textAlign: l4.textAlign(S6.textAlign) });
        }, v5 = this.isHorizontal(), y5 = this._computeTitleHeight();
        v5 ? f4 = { x: Y3(o3, this.left + h5, this.right - s2[0]), y: this.top + h5 + y5, line: 0 } : f4 = { x: this.left + h5, y: Y3(o3, this.top + y5 + h5, this.bottom - e[0].height), line: 0 }, Ci(this.ctx, t.textDirection);
        let x5 = m6 + h5;
        this.legendItems.forEach((M5, k4) => {
          n3.strokeStyle = M5.fontColor, n3.fillStyle = M5.fontColor;
          let S6 = n3.measureText(M5.text).width, w4 = l4.textAlign(M5.textAlign || (M5.textAlign = a2.textAlign)), D5 = g4 + u3 + S6, C5 = f4.x, A5 = f4.y;
          l4.setWidth(this.width), v5 ? k4 > 0 && C5 + D5 + h5 > this.right && (A5 = f4.y += x5, f4.line++, C5 = f4.x = Y3(o3, this.left + h5, this.right - s2[f4.line])) : k4 > 0 && A5 + x5 > this.bottom && (C5 = f4.x = C5 + e[f4.line].width + h5, f4.line++, A5 = f4.y = Y3(o3, this.top + y5 + h5, this.bottom - e[f4.line].height));
          let U4 = l4.x(C5);
          if (b5(U4, A5, M5), C5 = Vs(w4, C5 + g4 + u3, v5 ? C5 + D5 : this.right, t.rtl), _5(l4.x(C5), A5, M5), v5)
            f4.x += D5 + h5;
          else if (typeof M5.text != "string") {
            let tt = c3.lineHeight;
            f4.y += vo(M5, tt) + h5;
          } else
            f4.y += x5;
        }), Oi(this.ctx, t.textDirection);
      }
      drawTitle() {
        let t = this.options, e = t.title, s2 = j3(e.font), n3 = X3(e.padding);
        if (!e.display)
          return;
        let o3 = Lt(t.rtl, this.left, this.width), a2 = this.ctx, r = e.position, l4 = s2.size / 2, c3 = n3.top + l4, h5, d5 = this.left, u3 = this.width;
        if (this.isHorizontal())
          u3 = Math.max(...this.lineWidths), h5 = this.top + c3, d5 = Y3(t.align, d5, this.right - u3);
        else {
          let g4 = this.columnSizes.reduce((p6, m6) => Math.max(p6, m6.height), 0);
          h5 = c3 + Y3(t.align, this.top, this.bottom - g4 - t.labels.padding - this._computeTitleHeight());
        }
        let f4 = Y3(r, d5, d5 + u3);
        a2.textAlign = o3.textAlign(Ae(r)), a2.textBaseline = "middle", a2.strokeStyle = e.color, a2.fillStyle = e.color, a2.font = s2.string, vt(a2, e.text, f4, h5, s2);
      }
      _computeTitleHeight() {
        let t = this.options.title, e = j3(t.font), s2 = X3(t.padding);
        return t.display ? e.lineHeight + s2.height : 0;
      }
      _getLegendItemAt(t, e) {
        let s2, n3, o3;
        if (lt(t, this.left, this.right) && lt(e, this.top, this.bottom)) {
          for (o3 = this.legendHitBoxes, s2 = 0; s2 < o3.length; ++s2)
            if (n3 = o3[s2], lt(t, n3.left, n3.left + n3.width) && lt(e, n3.top, n3.top + n3.height))
              return this.legendItems[s2];
        }
        return null;
      }
      handleEvent(t) {
        let e = this.options;
        if (!ql(t.type, e))
          return;
        let s2 = this._getLegendItemAt(t.x, t.y);
        if (t.type === "mousemove" || t.type === "mouseout") {
          let n3 = this._hoveredItem, o3 = Ul(n3, s2);
          n3 && !o3 && E2(e.onLeave, [t, n3, this], this), this._hoveredItem = s2, s2 && !o3 && E2(e.onHover, [t, s2, this], this);
        } else
          s2 && E2(e.onClick, [t, s2, this], this);
      }
    };
    Gl = { id: "legend", _element: Ze, start(i4, t, e) {
      let s2 = i4.legend = new Ze({ ctx: i4.ctx, options: e, chart: i4 });
      q3.configure(i4, s2, e), q3.addBox(i4, s2);
    }, stop(i4) {
      q3.removeBox(i4, i4.legend), delete i4.legend;
    }, beforeUpdate(i4, t, e) {
      let s2 = i4.legend;
      q3.configure(i4, s2, e), s2.options = e;
    }, afterUpdate(i4) {
      let t = i4.legend;
      t.buildLabels(), t.adjustHitBoxes();
    }, afterEvent(i4, t) {
      t.replay || i4.legend.handleEvent(t.event);
    }, defaults: { display: true, position: "top", align: "center", fullSize: true, reverse: false, weight: 1e3, onClick(i4, t, e) {
      let s2 = t.datasetIndex, n3 = e.chart;
      n3.isDatasetVisible(s2) ? (n3.hide(s2), t.hidden = true) : (n3.show(s2), t.hidden = false);
    }, onHover: null, onLeave: null, labels: { color: (i4) => i4.chart.options.color, boxWidth: 40, padding: 10, generateLabels(i4) {
      let t = i4.data.datasets, { labels: { usePointStyle: e, pointStyle: s2, textAlign: n3, color: o3, useBorderRadius: a2, borderRadius: r } } = i4.legend.options;
      return i4._getSortedDatasetMetas().map((l4) => {
        let c3 = l4.controller.getStyle(e ? 0 : void 0), h5 = X3(c3.borderWidth);
        return { text: t[l4.index].label, fillStyle: c3.backgroundColor, fontColor: o3, hidden: !l4.visible, lineCap: c3.borderCapStyle, lineDash: c3.borderDash, lineDashOffset: c3.borderDashOffset, lineJoin: c3.borderJoinStyle, lineWidth: (h5.width + h5.height) / 4, strokeStyle: c3.borderColor, pointStyle: s2 || c3.pointStyle, rotation: c3.rotation, textAlign: n3 || c3.textAlign, borderRadius: a2 && (r || c3.borderRadius), datasetIndex: l4.index };
      }, this);
    } }, title: { color: (i4) => i4.chart.options.color, display: false, position: "center", text: "" } }, descriptors: { _scriptable: (i4) => !i4.startsWith("on"), labels: { _scriptable: (i4) => !["generateLabels", "filter", "sort"].includes(i4) } } };
    pe = class extends nt {
      constructor(t) {
        super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
      }
      update(t, e) {
        let s2 = this.options;
        if (this.left = 0, this.top = 0, !s2.display) {
          this.width = this.height = this.right = this.bottom = 0;
          return;
        }
        this.width = this.right = t, this.height = this.bottom = e;
        let n3 = I3(s2.text) ? s2.text.length : 1;
        this._padding = X3(s2.padding);
        let o3 = n3 * j3(s2.font).lineHeight + this._padding.height;
        this.isHorizontal() ? this.height = o3 : this.width = o3;
      }
      isHorizontal() {
        let t = this.options.position;
        return t === "top" || t === "bottom";
      }
      _drawArgs(t) {
        let { top: e, left: s2, bottom: n3, right: o3, options: a2 } = this, r = a2.align, l4 = 0, c3, h5, d5;
        return this.isHorizontal() ? (h5 = Y3(r, s2, o3), d5 = e + t, c3 = o3 - s2) : (a2.position === "left" ? (h5 = s2 + t, d5 = Y3(r, n3, e), l4 = z2 * -0.5) : (h5 = o3 - t, d5 = Y3(r, e, n3), l4 = z2 * 0.5), c3 = n3 - e), { titleX: h5, titleY: d5, maxWidth: c3, rotation: l4 };
      }
      draw() {
        let t = this.ctx, e = this.options;
        if (!e.display)
          return;
        let s2 = j3(e.font), o3 = s2.lineHeight / 2 + this._padding.top, { titleX: a2, titleY: r, maxWidth: l4, rotation: c3 } = this._drawArgs(o3);
        vt(t, e.text, 0, 0, s2, { color: e.color, maxWidth: l4, rotation: c3, textAlign: Ae(e.align), textBaseline: "middle", translation: [a2, r] });
      }
    };
    Ql = { id: "title", _element: pe, start(i4, t, e) {
      Jl(i4, e);
    }, stop(i4) {
      let t = i4.titleBlock;
      q3.removeBox(i4, t), delete i4.titleBlock;
    }, beforeUpdate(i4, t, e) {
      let s2 = i4.titleBlock;
      q3.configure(i4, s2, e), s2.options = e;
    }, defaults: { align: "center", display: false, font: { weight: "bold" }, fullSize: true, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: true, _indexable: false } };
    He = /* @__PURE__ */ new WeakMap();
    Zl = { id: "subtitle", start(i4, t, e) {
      let s2 = new pe({ ctx: i4.ctx, options: e, chart: i4 });
      q3.configure(i4, s2, e), q3.addBox(i4, s2), He.set(i4, s2);
    }, stop(i4) {
      q3.removeBox(i4, He.get(i4)), He.delete(i4);
    }, beforeUpdate(i4, t, e) {
      let s2 = He.get(i4);
      q3.configure(i4, s2, e), s2.options = e;
    }, defaults: { align: "center", display: false, font: { weight: "normal" }, fullSize: true, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: true, _indexable: false } };
    ue = { average(i4) {
      if (!i4.length)
        return false;
      let t, e, s2 = /* @__PURE__ */ new Set(), n3 = 0, o3 = 0;
      for (t = 0, e = i4.length; t < e; ++t) {
        let r = i4[t].element;
        if (r && r.hasValue()) {
          let l4 = r.tooltipPosition();
          s2.add(l4.x), n3 += l4.y, ++o3;
        }
      }
      return { x: [...s2].reduce((r, l4) => r + l4) / s2.size, y: n3 / o3 };
    }, nearest(i4, t) {
      if (!i4.length)
        return false;
      let e = t.x, s2 = t.y, n3 = Number.POSITIVE_INFINITY, o3, a2, r;
      for (o3 = 0, a2 = i4.length; o3 < a2; ++o3) {
        let l4 = i4[o3].element;
        if (l4 && l4.hasValue()) {
          let c3 = l4.getCenterPoint(), h5 = we(t, c3);
          h5 < n3 && (n3 = h5, r = l4);
        }
      }
      if (r) {
        let l4 = r.tooltipPosition();
        e = l4.x, s2 = l4.y;
      }
      return { x: e, y: s2 };
    } };
    Mo = { beforeTitle: rt, title(i4) {
      if (i4.length > 0) {
        let t = i4[0], e = t.chart.data.labels, s2 = e ? e.length : 0;
        if (this && this.options && this.options.mode === "dataset")
          return t.dataset.label || "";
        if (t.label)
          return t.label;
        if (s2 > 0 && t.dataIndex < s2)
          return e[t.dataIndex];
      }
      return "";
    }, afterTitle: rt, beforeBody: rt, beforeLabel: rt, label(i4) {
      if (this && this.options && this.options.mode === "dataset")
        return i4.label + ": " + i4.formattedValue || i4.formattedValue;
      let t = i4.dataset.label || "";
      t && (t += ": ");
      let e = i4.formattedValue;
      return L3(e) || (t += e), t;
    }, labelColor(i4) {
      let e = i4.chart.getDatasetMeta(i4.datasetIndex).controller.getStyle(i4.dataIndex);
      return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 };
    }, labelTextColor() {
      return this.options.bodyColor;
    }, labelPointStyle(i4) {
      let e = i4.chart.getDatasetMeta(i4.datasetIndex).controller.getStyle(i4.dataIndex);
      return { pointStyle: e.pointStyle, rotation: e.rotation };
    }, afterLabel: rt, afterBody: rt, beforeFooter: rt, footer: rt, afterFooter: rt };
    ti = class extends nt {
      static positioners = ue;
      constructor(t) {
        super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
      }
      initialize(t) {
        this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
      }
      _resolveAnimations() {
        let t = this._cachedAnimations;
        if (t)
          return t;
        let e = this.chart, s2 = this.options.setContext(this.getContext()), n3 = s2.enabled && e.options.animation && s2.animations, o3 = new Xe(this.chart, n3);
        return n3._cacheable && (this._cachedAnimations = Object.freeze(o3)), o3;
      }
      getContext() {
        return this.$context || (this.$context = ac(this.chart.getContext(), this, this._tooltipItems));
      }
      getTitle(t, e) {
        let { callbacks: s2 } = e, n3 = Q3(s2, "beforeTitle", this, t), o3 = Q3(s2, "title", this, t), a2 = Q3(s2, "afterTitle", this, t), r = [];
        return r = ct(r, bt(n3)), r = ct(r, bt(o3)), r = ct(r, bt(a2)), r;
      }
      getBeforeBody(t, e) {
        return Un(Q3(e.callbacks, "beforeBody", this, t));
      }
      getBody(t, e) {
        let { callbacks: s2 } = e, n3 = [];
        return T3(t, (o3) => {
          let a2 = { before: [], lines: [], after: [] }, r = Yn(s2, o3);
          ct(a2.before, bt(Q3(r, "beforeLabel", this, o3))), ct(a2.lines, Q3(r, "label", this, o3)), ct(a2.after, bt(Q3(r, "afterLabel", this, o3))), n3.push(a2);
        }), n3;
      }
      getAfterBody(t, e) {
        return Un(Q3(e.callbacks, "afterBody", this, t));
      }
      getFooter(t, e) {
        let { callbacks: s2 } = e, n3 = Q3(s2, "beforeFooter", this, t), o3 = Q3(s2, "footer", this, t), a2 = Q3(s2, "afterFooter", this, t), r = [];
        return r = ct(r, bt(n3)), r = ct(r, bt(o3)), r = ct(r, bt(a2)), r;
      }
      _createItems(t) {
        let e = this._active, s2 = this.chart.data, n3 = [], o3 = [], a2 = [], r = [], l4, c3;
        for (l4 = 0, c3 = e.length; l4 < c3; ++l4)
          r.push(tc(this.chart, e[l4]));
        return t.filter && (r = r.filter((h5, d5, u3) => t.filter(h5, d5, u3, s2))), t.itemSort && (r = r.sort((h5, d5) => t.itemSort(h5, d5, s2))), T3(r, (h5) => {
          let d5 = Yn(t.callbacks, h5);
          n3.push(Q3(d5, "labelColor", this, h5)), o3.push(Q3(d5, "labelPointStyle", this, h5)), a2.push(Q3(d5, "labelTextColor", this, h5));
        }), this.labelColors = n3, this.labelPointStyles = o3, this.labelTextColors = a2, this.dataPoints = r, r;
      }
      update(t, e) {
        let s2 = this.options.setContext(this.getContext()), n3 = this._active, o3, a2 = [];
        if (!n3.length)
          this.opacity !== 0 && (o3 = { opacity: 0 });
        else {
          let r = ue[s2.position].call(this, n3, this._eventPosition);
          a2 = this._createItems(s2), this.title = this.getTitle(a2, s2), this.beforeBody = this.getBeforeBody(a2, s2), this.body = this.getBody(a2, s2), this.afterBody = this.getAfterBody(a2, s2), this.footer = this.getFooter(a2, s2);
          let l4 = this._size = Hn(this, s2), c3 = Object.assign({}, r, l4), h5 = jn(this.chart, s2, c3), d5 = $n(s2, c3, h5, this.chart);
          this.xAlign = h5.xAlign, this.yAlign = h5.yAlign, o3 = { opacity: 1, x: d5.x, y: d5.y, width: l4.width, height: l4.height, caretX: r.x, caretY: r.y };
        }
        this._tooltipItems = a2, this.$context = void 0, o3 && this._resolveAnimations().update(this, o3), t && s2.external && s2.external.call(this, { chart: this.chart, tooltip: this, replay: e });
      }
      drawCaret(t, e, s2, n3) {
        let o3 = this.getCaretPosition(t, s2, n3);
        e.lineTo(o3.x1, o3.y1), e.lineTo(o3.x2, o3.y2), e.lineTo(o3.x3, o3.y3);
      }
      getCaretPosition(t, e, s2) {
        let { xAlign: n3, yAlign: o3 } = this, { caretSize: a2, cornerRadius: r } = s2, { topLeft: l4, topRight: c3, bottomLeft: h5, bottomRight: d5 } = Mt(r), { x: u3, y: f4 } = t, { width: g4, height: p6 } = e, m6, b5, _5, v5, y5, x5;
        return o3 === "center" ? (y5 = f4 + p6 / 2, n3 === "left" ? (m6 = u3, b5 = m6 - a2, v5 = y5 + a2, x5 = y5 - a2) : (m6 = u3 + g4, b5 = m6 + a2, v5 = y5 - a2, x5 = y5 + a2), _5 = m6) : (n3 === "left" ? b5 = u3 + Math.max(l4, h5) + a2 : n3 === "right" ? b5 = u3 + g4 - Math.max(c3, d5) - a2 : b5 = this.caretX, o3 === "top" ? (v5 = f4, y5 = v5 - a2, m6 = b5 - a2, _5 = b5 + a2) : (v5 = f4 + p6, y5 = v5 + a2, m6 = b5 + a2, _5 = b5 - a2), x5 = v5), { x1: m6, x2: b5, x3: _5, y1: v5, y2: y5, y3: x5 };
      }
      drawTitle(t, e, s2) {
        let n3 = this.title, o3 = n3.length, a2, r, l4;
        if (o3) {
          let c3 = Lt(s2.rtl, this.x, this.width);
          for (t.x = je(this, s2.titleAlign, s2), e.textAlign = c3.textAlign(s2.titleAlign), e.textBaseline = "middle", a2 = j3(s2.titleFont), r = s2.titleSpacing, e.fillStyle = s2.titleColor, e.font = a2.string, l4 = 0; l4 < o3; ++l4)
            e.fillText(n3[l4], c3.x(t.x), t.y + a2.lineHeight / 2), t.y += a2.lineHeight + r, l4 + 1 === o3 && (t.y += s2.titleMarginBottom - r);
        }
      }
      _drawColorBox(t, e, s2, n3, o3) {
        let a2 = this.labelColors[s2], r = this.labelPointStyles[s2], { boxHeight: l4, boxWidth: c3 } = o3, h5 = j3(o3.bodyFont), d5 = je(this, "left", o3), u3 = n3.x(d5), f4 = l4 < h5.lineHeight ? (h5.lineHeight - l4) / 2 : 0, g4 = e.y + f4;
        if (o3.usePointStyle) {
          let p6 = { radius: Math.min(c3, l4) / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: 1 }, m6 = n3.leftForLtr(u3, c3) + c3 / 2, b5 = g4 + l4 / 2;
          t.strokeStyle = o3.multiKeyBackground, t.fillStyle = o3.multiKeyBackground, Te(t, p6, m6, b5), t.strokeStyle = a2.borderColor, t.fillStyle = a2.backgroundColor, Te(t, p6, m6, b5);
        } else {
          t.lineWidth = O3(a2.borderWidth) ? Math.max(...Object.values(a2.borderWidth)) : a2.borderWidth || 1, t.strokeStyle = a2.borderColor, t.setLineDash(a2.borderDash || []), t.lineDashOffset = a2.borderDashOffset || 0;
          let p6 = n3.leftForLtr(u3, c3), m6 = n3.leftForLtr(n3.xPlus(u3, 1), c3 - 2), b5 = Mt(a2.borderRadius);
          Object.values(b5).some((_5) => _5 !== 0) ? (t.beginPath(), t.fillStyle = o3.multiKeyBackground, Ut(t, { x: p6, y: g4, w: c3, h: l4, radius: b5 }), t.fill(), t.stroke(), t.fillStyle = a2.backgroundColor, t.beginPath(), Ut(t, { x: m6, y: g4 + 1, w: c3 - 2, h: l4 - 2, radius: b5 }), t.fill()) : (t.fillStyle = o3.multiKeyBackground, t.fillRect(p6, g4, c3, l4), t.strokeRect(p6, g4, c3, l4), t.fillStyle = a2.backgroundColor, t.fillRect(m6, g4 + 1, c3 - 2, l4 - 2));
        }
        t.fillStyle = this.labelTextColors[s2];
      }
      drawBody(t, e, s2) {
        let { body: n3 } = this, { bodySpacing: o3, bodyAlign: a2, displayColors: r, boxHeight: l4, boxWidth: c3, boxPadding: h5 } = s2, d5 = j3(s2.bodyFont), u3 = d5.lineHeight, f4 = 0, g4 = Lt(s2.rtl, this.x, this.width), p6 = function(S6) {
          e.fillText(S6, g4.x(t.x + f4), t.y + u3 / 2), t.y += u3 + o3;
        }, m6 = g4.textAlign(a2), b5, _5, v5, y5, x5, M5, k4;
        for (e.textAlign = a2, e.textBaseline = "middle", e.font = d5.string, t.x = je(this, m6, s2), e.fillStyle = s2.bodyColor, T3(this.beforeBody, p6), f4 = r && m6 !== "right" ? a2 === "center" ? c3 / 2 + h5 : c3 + 2 + h5 : 0, y5 = 0, M5 = n3.length; y5 < M5; ++y5) {
          for (b5 = n3[y5], _5 = this.labelTextColors[y5], e.fillStyle = _5, T3(b5.before, p6), v5 = b5.lines, r && v5.length && (this._drawColorBox(e, t, y5, g4, s2), u3 = Math.max(d5.lineHeight, l4)), x5 = 0, k4 = v5.length; x5 < k4; ++x5)
            p6(v5[x5]), u3 = d5.lineHeight;
          T3(b5.after, p6);
        }
        f4 = 0, u3 = d5.lineHeight, T3(this.afterBody, p6), t.y -= o3;
      }
      drawFooter(t, e, s2) {
        let n3 = this.footer, o3 = n3.length, a2, r;
        if (o3) {
          let l4 = Lt(s2.rtl, this.x, this.width);
          for (t.x = je(this, s2.footerAlign, s2), t.y += s2.footerMarginTop, e.textAlign = l4.textAlign(s2.footerAlign), e.textBaseline = "middle", a2 = j3(s2.footerFont), e.fillStyle = s2.footerColor, e.font = a2.string, r = 0; r < o3; ++r)
            e.fillText(n3[r], l4.x(t.x), t.y + a2.lineHeight / 2), t.y += a2.lineHeight + s2.footerSpacing;
        }
      }
      drawBackground(t, e, s2, n3) {
        let { xAlign: o3, yAlign: a2 } = this, { x: r, y: l4 } = t, { width: c3, height: h5 } = s2, { topLeft: d5, topRight: u3, bottomLeft: f4, bottomRight: g4 } = Mt(n3.cornerRadius);
        e.fillStyle = n3.backgroundColor, e.strokeStyle = n3.borderColor, e.lineWidth = n3.borderWidth, e.beginPath(), e.moveTo(r + d5, l4), a2 === "top" && this.drawCaret(t, e, s2, n3), e.lineTo(r + c3 - u3, l4), e.quadraticCurveTo(r + c3, l4, r + c3, l4 + u3), a2 === "center" && o3 === "right" && this.drawCaret(t, e, s2, n3), e.lineTo(r + c3, l4 + h5 - g4), e.quadraticCurveTo(r + c3, l4 + h5, r + c3 - g4, l4 + h5), a2 === "bottom" && this.drawCaret(t, e, s2, n3), e.lineTo(r + f4, l4 + h5), e.quadraticCurveTo(r, l4 + h5, r, l4 + h5 - f4), a2 === "center" && o3 === "left" && this.drawCaret(t, e, s2, n3), e.lineTo(r, l4 + d5), e.quadraticCurveTo(r, l4, r + d5, l4), e.closePath(), e.fill(), n3.borderWidth > 0 && e.stroke();
      }
      _updateAnimationTarget(t) {
        let e = this.chart, s2 = this.$animations, n3 = s2 && s2.x, o3 = s2 && s2.y;
        if (n3 || o3) {
          let a2 = ue[t.position].call(this, this._active, this._eventPosition);
          if (!a2)
            return;
          let r = this._size = Hn(this, t), l4 = Object.assign({}, a2, this._size), c3 = jn(e, t, l4), h5 = $n(t, l4, c3, e);
          (n3._to !== h5.x || o3._to !== h5.y) && (this.xAlign = c3.xAlign, this.yAlign = c3.yAlign, this.width = r.width, this.height = r.height, this.caretX = a2.x, this.caretY = a2.y, this._resolveAnimations().update(this, h5));
        }
      }
      _willRender() {
        return !!this.opacity;
      }
      draw(t) {
        let e = this.options.setContext(this.getContext()), s2 = this.opacity;
        if (!s2)
          return;
        this._updateAnimationTarget(e);
        let n3 = { width: this.width, height: this.height }, o3 = { x: this.x, y: this.y };
        s2 = Math.abs(s2) < 1e-3 ? 0 : s2;
        let a2 = X3(e.padding), r = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        e.enabled && r && (t.save(), t.globalAlpha = s2, this.drawBackground(o3, t, n3, e), Ci(t, e.textDirection), o3.y += a2.top, this.drawTitle(o3, t, e), this.drawBody(o3, t, e), this.drawFooter(o3, t, e), Oi(t, e.textDirection), t.restore());
      }
      getActiveElements() {
        return this._active || [];
      }
      setActiveElements(t, e) {
        let s2 = this._active, n3 = t.map(({ datasetIndex: r, index: l4 }) => {
          let c3 = this.chart.getDatasetMeta(r);
          if (!c3)
            throw new Error("Cannot find a dataset at index " + r);
          return { datasetIndex: r, element: c3.data[l4], index: l4 };
        }), o3 = !ie(s2, n3), a2 = this._positionChanged(n3, e);
        (o3 || a2) && (this._active = n3, this._eventPosition = e, this._ignoreReplayEvents = true, this.update(true));
      }
      handleEvent(t, e, s2 = true) {
        if (e && this._ignoreReplayEvents)
          return false;
        this._ignoreReplayEvents = false;
        let n3 = this.options, o3 = this._active || [], a2 = this._getActiveElements(t, o3, e, s2), r = this._positionChanged(a2, t), l4 = e || !ie(a2, o3) || r;
        return l4 && (this._active = a2, (n3.enabled || n3.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(true, e))), l4;
      }
      _getActiveElements(t, e, s2, n3) {
        let o3 = this.options;
        if (t.type === "mouseout")
          return [];
        if (!n3)
          return e.filter((r) => this.chart.data.datasets[r.datasetIndex] && this.chart.getDatasetMeta(r.datasetIndex).controller.getParsed(r.index) !== void 0);
        let a2 = this.chart.getElementsAtEventForMode(t, o3.mode, o3, s2);
        return o3.reverse && a2.reverse(), a2;
      }
      _positionChanged(t, e) {
        let { caretX: s2, caretY: n3, options: o3 } = this, a2 = ue[o3.position].call(this, t, e);
        return a2 !== false && (s2 !== a2.x || n3 !== a2.y);
      }
    };
    rc = { id: "tooltip", _element: ti, positioners: ue, afterInit(i4, t, e) {
      e && (i4.tooltip = new ti({ chart: i4, options: e }));
    }, beforeUpdate(i4, t, e) {
      i4.tooltip && i4.tooltip.initialize(e);
    }, reset(i4, t, e) {
      i4.tooltip && i4.tooltip.initialize(e);
    }, afterDraw(i4) {
      let t = i4.tooltip;
      if (t && t._willRender()) {
        let e = { tooltip: t };
        if (i4.notifyPlugins("beforeTooltipDraw", { ...e, cancelable: true }) === false)
          return;
        t.draw(i4.ctx), i4.notifyPlugins("afterTooltipDraw", e);
      }
    }, afterEvent(i4, t) {
      if (i4.tooltip) {
        let e = t.replay;
        i4.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = true);
      }
    }, defaults: { enabled: true, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (i4, t) => t.bodyFont.size, boxWidth: (i4, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: true, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: Mo }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: (i4) => i4 !== "filter" && i4 !== "itemSort" && i4 !== "external", _indexable: false, callbacks: { _scriptable: false, _indexable: false }, animation: { _fallback: false }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] };
    lc = Object.freeze({ __proto__: null, Colors: yl, Decimation: Sl, Filler: $l, Legend: Gl, SubTitle: Zl, Title: Ql, Tooltip: rc });
    cc = (i4, t, e, s2) => (typeof t == "string" ? (e = i4.push(t) - 1, s2.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e);
    dc = (i4, t) => i4 === null ? null : $3(Math.round(i4), 0, t);
    cs = class extends Et {
      static id = "category";
      static defaults = { ticks: { callback: Xn } };
      constructor(t) {
        super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
      }
      init(t) {
        let e = this._addedLabels;
        if (e.length) {
          let s2 = this.getLabels();
          for (let { index: n3, label: o3 } of e)
            s2[n3] === o3 && s2.splice(n3, 1);
          this._addedLabels = [];
        }
        super.init(t);
      }
      parse(t, e) {
        if (L3(t))
          return null;
        let s2 = this.getLabels();
        return e = isFinite(e) && s2[e] === t ? e : hc(s2, t, P3(e, t), this._addedLabels), dc(e, s2.length - 1);
      }
      determineDataLimits() {
        let { minDefined: t, maxDefined: e } = this.getUserBounds(), { min: s2, max: n3 } = this.getMinMax(true);
        this.options.bounds === "ticks" && (t || (s2 = 0), e || (n3 = this.getLabels().length - 1)), this.min = s2, this.max = n3;
      }
      buildTicks() {
        let t = this.min, e = this.max, s2 = this.options.offset, n3 = [], o3 = this.getLabels();
        o3 = t === 0 && e === o3.length - 1 ? o3 : o3.slice(t, e + 1), this._valueRange = Math.max(o3.length - (s2 ? 0 : 1), 1), this._startValue = this.min - (s2 ? 0.5 : 0);
        for (let a2 = t; a2 <= e; a2++)
          n3.push({ value: a2 });
        return n3;
      }
      getLabelForValue(t) {
        return Xn.call(this, t);
      }
      configure() {
        super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
      }
      getPixelForValue(t) {
        return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
      }
      getPixelForTick(t) {
        let e = this.ticks;
        return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
      }
      getValueForPixel(t) {
        return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
      }
      getBasePixel() {
        return this.bottom;
      }
    };
    Jt = class extends Et {
      constructor(t) {
        super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
      }
      parse(t, e) {
        return L3(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
      }
      handleTickRangeOptions() {
        let { beginAtZero: t } = this.options, { minDefined: e, maxDefined: s2 } = this.getUserBounds(), { min: n3, max: o3 } = this, a2 = (l4) => n3 = e ? n3 : l4, r = (l4) => o3 = s2 ? o3 : l4;
        if (t) {
          let l4 = st(n3), c3 = st(o3);
          l4 < 0 && c3 < 0 ? r(0) : l4 > 0 && c3 > 0 && a2(0);
        }
        if (n3 === o3) {
          let l4 = o3 === 0 ? 1 : Math.abs(o3 * 0.05);
          r(o3 + l4), t || a2(n3 - l4);
        }
        this.min = n3, this.max = o3;
      }
      getTickLimit() {
        let t = this.options.ticks, { maxTicksLimit: e, stepSize: s2 } = t, n3;
        return s2 ? (n3 = Math.ceil(this.max / s2) - Math.floor(this.min / s2) + 1, n3 > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s2} would result generating up to ${n3} ticks. Limiting to 1000.`), n3 = 1e3)) : (n3 = this.computeTickLimit(), e = e || 11), e && (n3 = Math.min(e, n3)), n3;
      }
      computeTickLimit() {
        return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
        let t = this.options, e = t.ticks, s2 = this.getTickLimit();
        s2 = Math.max(2, s2);
        let n3 = { maxTicks: s2, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: e.includeBounds !== false }, o3 = this._range || this, a2 = uc(n3, o3);
        return t.bounds === "ticks" && li(a2, this, "value"), t.reverse ? (a2.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a2;
      }
      configure() {
        let t = this.ticks, e = this.min, s2 = this.max;
        if (super.configure(), this.options.offset && t.length) {
          let n3 = (s2 - e) / Math.max(t.length - 1, 1) / 2;
          e -= n3, s2 += n3;
        }
        this._startValue = e, this._endValue = s2, this._valueRange = s2 - e;
      }
      getLabelForValue(t) {
        return $t(t, this.chart.options.locale, this.options.ticks.format);
      }
    };
    hs = class extends Jt {
      static id = "linear";
      static defaults = { ticks: { callback: se.formatters.numeric } };
      determineDataLimits() {
        let { min: t, max: e } = this.getMinMax(true);
        this.min = V3(t) ? t : 0, this.max = V3(e) ? e : 1, this.handleTickRangeOptions();
      }
      computeTickLimit() {
        let t = this.isHorizontal(), e = t ? this.width : this.height, s2 = et(this.options.ticks.minRotation), n3 = (t ? Math.sin(s2) : Math.cos(s2)) || 1e-3, o3 = this._resolveTickFontOptions(0);
        return Math.ceil(e / Math.min(40, o3.lineHeight / n3));
      }
      getPixelForValue(t) {
        return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
      }
      getValueForPixel(t) {
        return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
      }
    };
    me = (i4) => Math.floor(ft(i4));
    Rt = (i4, t) => Math.pow(10, me(i4) + t);
    ds = class extends Et {
      static id = "logarithmic";
      static defaults = { ticks: { callback: se.formatters.logarithmic, major: { enabled: true } } };
      constructor(t) {
        super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
      }
      parse(t, e) {
        let s2 = Jt.prototype.parse.apply(this, [t, e]);
        if (s2 === 0) {
          this._zero = true;
          return;
        }
        return V3(s2) && s2 > 0 ? s2 : null;
      }
      determineDataLimits() {
        let { min: t, max: e } = this.getMinMax(true);
        this.min = V3(t) ? Math.max(0, t) : null, this.max = V3(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = true), this._zero && this.min !== this._suggestedMin && !V3(this._userMin) && (this.min = t === Rt(this.min, 0) ? Rt(this.min, -1) : Rt(this.min, 0)), this.handleTickRangeOptions();
      }
      handleTickRangeOptions() {
        let { minDefined: t, maxDefined: e } = this.getUserBounds(), s2 = this.min, n3 = this.max, o3 = (r) => s2 = t ? s2 : r, a2 = (r) => n3 = e ? n3 : r;
        s2 === n3 && (s2 <= 0 ? (o3(1), a2(10)) : (o3(Rt(s2, -1)), a2(Rt(n3, 1)))), s2 <= 0 && o3(Rt(n3, -1)), n3 <= 0 && a2(Rt(s2, 1)), this.min = s2, this.max = n3;
      }
      buildTicks() {
        let t = this.options, e = { min: this._userMin, max: this._userMax }, s2 = gc(e, this);
        return t.bounds === "ticks" && li(s2, this, "value"), t.reverse ? (s2.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s2;
      }
      getLabelForValue(t) {
        return t === void 0 ? "0" : $t(t, this.chart.options.locale, this.options.ticks.format);
      }
      configure() {
        let t = this.min;
        super.configure(), this._startValue = ft(t), this._valueRange = ft(this.max) - ft(t);
      }
      getPixelForValue(t) {
        return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (ft(t) - this._startValue) / this._valueRange);
      }
      getValueForPixel(t) {
        let e = this.getDecimalForPixel(t);
        return Math.pow(10, this._startValue + e * this._valueRange);
      }
    };
    fs = class extends Jt {
      static id = "radialLinear";
      static defaults = { display: true, animate: true, position: "chartArea", angleLines: { display: true, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: false }, startAngle: 0, ticks: { showLabelBackdrop: true, callback: se.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: true, font: { size: 10 }, callback(t) {
        return t;
      }, padding: 5, centerPointLabels: false } };
      static defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" };
      static descriptors = { angleLines: { _fallback: "grid" } };
      constructor(t) {
        super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
      }
      setDimensions() {
        let t = this._padding = X3(us(this.options) / 2), e = this.width = this.maxWidth - t.width, s2 = this.height = this.maxHeight - t.height;
        this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s2 / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s2) / 2);
      }
      determineDataLimits() {
        let { min: t, max: e } = this.getMinMax(false);
        this.min = V3(t) && !isNaN(t) ? t : 0, this.max = V3(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();
      }
      computeTickLimit() {
        return Math.ceil(this.drawingArea / us(this.options));
      }
      generateTickLabels(t) {
        Jt.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, s2) => {
          let n3 = E2(this.options.pointLabels.callback, [e, s2], this);
          return n3 || n3 === 0 ? n3 : "";
        }).filter((e, s2) => this.chart.getDataVisibility(s2));
      }
      fit() {
        let t = this.options;
        t.display && t.pointLabels.display ? mc(this) : this.setCenterPoint(0, 0, 0, 0);
      }
      setCenterPoint(t, e, s2, n3) {
        this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s2 - n3) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s2, n3));
      }
      getIndexAngle(t) {
        let e = F3 / (this._pointLabels.length || 1), s2 = this.options.startAngle || 0;
        return G3(t * e + et(s2));
      }
      getDistanceFromCenterForValue(t) {
        if (L3(t))
          return NaN;
        let e = this.drawingArea / (this.max - this.min);
        return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;
      }
      getValueForDistanceFromCenter(t) {
        if (L3(t))
          return NaN;
        let e = t / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - e : this.min + e;
      }
      getPointLabelContext(t) {
        let e = this._pointLabels || [];
        if (t >= 0 && t < e.length) {
          let s2 = e[t];
          return Dc(this.getContext(), t, s2);
        }
      }
      getPointPosition(t, e, s2 = 0) {
        let n3 = this.getIndexAngle(t) - N3 + s2;
        return { x: Math.cos(n3) * e + this.xCenter, y: Math.sin(n3) * e + this.yCenter, angle: n3 };
      }
      getPointPositionForValue(t, e) {
        return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
      }
      getBasePosition(t) {
        return this.getPointPositionForValue(t || 0, this.getBaseValue());
      }
      getPointLabelPosition(t) {
        let { left: e, top: s2, right: n3, bottom: o3 } = this._pointLabelItems[t];
        return { left: e, top: s2, right: n3, bottom: o3 };
      }
      drawBackground() {
        let { backgroundColor: t, grid: { circular: e } } = this.options;
        if (t) {
          let s2 = this.ctx;
          s2.save(), s2.beginPath(), ko(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s2.closePath(), s2.fillStyle = t, s2.fill(), s2.restore();
        }
      }
      drawGrid() {
        let t = this.ctx, e = this.options, { angleLines: s2, grid: n3, border: o3 } = e, a2 = this._pointLabels.length, r, l4, c3;
        if (e.pointLabels.display && wc(this, a2), n3.display && this.ticks.forEach((h5, d5) => {
          if (d5 !== 0 || d5 === 0 && this.min < 0) {
            l4 = this.getDistanceFromCenterForValue(h5.value);
            let u3 = this.getContext(d5), f4 = n3.setContext(u3), g4 = o3.setContext(u3);
            Pc(this, f4, l4, a2, g4);
          }
        }), s2.display) {
          for (t.save(), r = a2 - 1; r >= 0; r--) {
            let h5 = s2.setContext(this.getPointLabelContext(r)), { color: d5, lineWidth: u3 } = h5;
            !u3 || !d5 || (t.lineWidth = u3, t.strokeStyle = d5, t.setLineDash(h5.borderDash), t.lineDashOffset = h5.borderDashOffset, l4 = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), c3 = this.getPointPosition(r, l4), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c3.x, c3.y), t.stroke());
          }
          t.restore();
        }
      }
      drawBorder() {
      }
      drawLabels() {
        let t = this.ctx, e = this.options, s2 = e.ticks;
        if (!s2.display)
          return;
        let n3 = this.getIndexAngle(0), o3, a2;
        t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n3), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((r, l4) => {
          if (l4 === 0 && this.min >= 0 && !e.reverse)
            return;
          let c3 = s2.setContext(this.getContext(l4)), h5 = j3(c3.font);
          if (o3 = this.getDistanceFromCenterForValue(this.ticks[l4].value), c3.showLabelBackdrop) {
            t.font = h5.string, a2 = t.measureText(r.label).width, t.fillStyle = c3.backdropColor;
            let d5 = X3(c3.backdropPadding);
            t.fillRect(-a2 / 2 - d5.left, -o3 - h5.size / 2 - d5.top, a2 + d5.width, h5.size + d5.height);
          }
          vt(t, r.label, 0, -o3, h5, { color: c3.color, strokeColor: c3.textStrokeColor, strokeWidth: c3.textStrokeWidth });
        }), t.restore();
      }
      drawTitle() {
      }
    };
    ei = { millisecond: { common: true, size: 1, steps: 1e3 }, second: { common: true, size: 1e3, steps: 60 }, minute: { common: true, size: 6e4, steps: 60 }, hour: { common: true, size: 36e5, steps: 24 }, day: { common: true, size: 864e5, steps: 30 }, week: { common: false, size: 6048e5, steps: 4 }, month: { common: true, size: 2628e6, steps: 12 }, quarter: { common: false, size: 7884e6, steps: 4 }, year: { common: true, size: 3154e7 } };
    Z3 = Object.keys(ei);
    be = class extends Et {
      static id = "time";
      static defaults = { bounds: "data", adapters: {}, time: { parser: false, unit: false, round: false, isoWeekday: false, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: false, major: { enabled: false } } };
      constructor(t) {
        super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
      }
      init(t, e = {}) {
        let s2 = t.time || (t.time = {}), n3 = this._adapter = new $a._date(t.adapters.date);
        n3.init(e), Wt(s2.displayFormats, n3.formats()), this._parseOpts = { parser: s2.parser, round: s2.round, isoWeekday: s2.isoWeekday }, super.init(t), this._normalized = e.normalized;
      }
      parse(t, e) {
        return t === void 0 ? null : Zn(this, t);
      }
      beforeLayout() {
        super.beforeLayout(), this._cache = { data: [], labels: [], all: [] };
      }
      determineDataLimits() {
        let t = this.options, e = this._adapter, s2 = t.time.unit || "day", { min: n3, max: o3, minDefined: a2, maxDefined: r } = this.getUserBounds();
        function l4(c3) {
          !a2 && !isNaN(c3.min) && (n3 = Math.min(n3, c3.min)), !r && !isNaN(c3.max) && (o3 = Math.max(o3, c3.max));
        }
        (!a2 || !r) && (l4(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l4(this.getMinMax(false))), n3 = V3(n3) && !isNaN(n3) ? n3 : +e.startOf(Date.now(), s2), o3 = V3(o3) && !isNaN(o3) ? o3 : +e.endOf(Date.now(), s2) + 1, this.min = Math.min(n3, o3 - 1), this.max = Math.max(n3 + 1, o3);
      }
      _getLabelBounds() {
        let t = this.getLabelTimestamps(), e = Number.POSITIVE_INFINITY, s2 = Number.NEGATIVE_INFINITY;
        return t.length && (e = t[0], s2 = t[t.length - 1]), { min: e, max: s2 };
      }
      buildTicks() {
        let t = this.options, e = t.time, s2 = t.ticks, n3 = s2.source === "labels" ? this.getLabelTimestamps() : this._generate();
        t.bounds === "ticks" && n3.length && (this.min = this._userMin || n3[0], this.max = this._userMax || n3[n3.length - 1]);
        let o3 = this.min, a2 = this.max, r = Is(n3, o3, a2);
        return this._unit = e.unit || (s2.autoSkip ? to(e.minUnit, this.min, this.max, this._getLabelCapacity(o3)) : Cc(this, r.length, e.minUnit, this.min, this.max)), this._majorUnit = !s2.major.enabled || this._unit === "year" ? void 0 : Oc(this._unit), this.initOffsets(n3), t.reverse && r.reverse(), io(this, r, this._majorUnit);
      }
      afterAutoSkip() {
        this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
      }
      initOffsets(t = []) {
        let e = 0, s2 = 0, n3, o3;
        this.options.offset && t.length && (n3 = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n3 : e = (this.getDecimalForValue(t[1]) - n3) / 2, o3 = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s2 = o3 : s2 = (o3 - this.getDecimalForValue(t[t.length - 2])) / 2);
        let a2 = t.length < 3 ? 0.5 : 0.25;
        e = $3(e, 0, a2), s2 = $3(s2, 0, a2), this._offsets = { start: e, end: s2, factor: 1 / (e + 1 + s2) };
      }
      _generate() {
        let t = this._adapter, e = this.min, s2 = this.max, n3 = this.options, o3 = n3.time, a2 = o3.unit || to(o3.minUnit, e, s2, this._getLabelCapacity(e)), r = P3(n3.ticks.stepSize, 1), l4 = a2 === "week" ? o3.isoWeekday : false, c3 = At(l4) || l4 === true, h5 = {}, d5 = e, u3, f4;
        if (c3 && (d5 = +t.startOf(d5, "isoWeek", l4)), d5 = +t.startOf(d5, c3 ? "day" : a2), t.diff(s2, e, a2) > 1e5 * r)
          throw new Error(e + " and " + s2 + " are too far apart with stepSize of " + r + " " + a2);
        let g4 = n3.ticks.source === "data" && this.getDataTimestamps();
        for (u3 = d5, f4 = 0; u3 < s2; u3 = +t.add(u3, r, a2), f4++)
          eo(h5, u3, g4);
        return (u3 === s2 || n3.bounds === "ticks" || f4 === 1) && eo(h5, u3, g4), Object.keys(h5).sort(Qn).map((p6) => +p6);
      }
      getLabelForValue(t) {
        let e = this._adapter, s2 = this.options.time;
        return s2.tooltipFormat ? e.format(t, s2.tooltipFormat) : e.format(t, s2.displayFormats.datetime);
      }
      format(t, e) {
        let n3 = this.options.time.displayFormats, o3 = this._unit, a2 = e || n3[o3];
        return this._adapter.format(t, a2);
      }
      _tickFormatFunction(t, e, s2, n3) {
        let o3 = this.options, a2 = o3.ticks.callback;
        if (a2)
          return E2(a2, [t, e, s2], this);
        let r = o3.time.displayFormats, l4 = this._unit, c3 = this._majorUnit, h5 = l4 && r[l4], d5 = c3 && r[c3], u3 = s2[e], f4 = c3 && d5 && u3 && u3.major;
        return this._adapter.format(t, n3 || (f4 ? d5 : h5));
      }
      generateTickLabels(t) {
        let e, s2, n3;
        for (e = 0, s2 = t.length; e < s2; ++e)
          n3 = t[e], n3.label = this._tickFormatFunction(n3.value, e, t);
      }
      getDecimalForValue(t) {
        return t === null ? NaN : (t - this.min) / (this.max - this.min);
      }
      getPixelForValue(t) {
        let e = this._offsets, s2 = this.getDecimalForValue(t);
        return this.getPixelForDecimal((e.start + s2) * e.factor);
      }
      getValueForPixel(t) {
        let e = this._offsets, s2 = this.getDecimalForPixel(t) / e.factor - e.end;
        return this.min + s2 * (this.max - this.min);
      }
      _getLabelSize(t) {
        let e = this.options.ticks, s2 = this.ctx.measureText(t).width, n3 = et(this.isHorizontal() ? e.maxRotation : e.minRotation), o3 = Math.cos(n3), a2 = Math.sin(n3), r = this._resolveTickFontOptions(0).size;
        return { w: s2 * o3 + r * a2, h: s2 * a2 + r * o3 };
      }
      _getLabelCapacity(t) {
        let e = this.options.time, s2 = e.displayFormats, n3 = s2[e.unit] || s2.millisecond, o3 = this._tickFormatFunction(t, 0, io(this, [t], this._majorUnit), n3), a2 = this._getLabelSize(o3), r = Math.floor(this.isHorizontal() ? this.width / a2.w : this.height / a2.h) - 1;
        return r > 0 ? r : 1;
      }
      getDataTimestamps() {
        let t = this._cache.data || [], e, s2;
        if (t.length)
          return t;
        let n3 = this.getMatchingVisibleMetas();
        if (this._normalized && n3.length)
          return this._cache.data = n3[0].controller.getAllParsedValues(this);
        for (e = 0, s2 = n3.length; e < s2; ++e)
          t = t.concat(n3[e].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(t);
      }
      getLabelTimestamps() {
        let t = this._cache.labels || [], e, s2;
        if (t.length)
          return t;
        let n3 = this.getLabels();
        for (e = 0, s2 = n3.length; e < s2; ++e)
          t.push(Zn(this, n3[e]));
        return this._cache.labels = this._normalized ? t : this.normalize(t);
      }
      normalize(t) {
        return ui(t.sort(Qn));
      }
    };
    gs = class extends be {
      static id = "timeseries";
      static defaults = be.defaults;
      constructor(t) {
        super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
      }
      initOffsets() {
        let t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);
        this._minPos = $e(e, this.min), this._tableRange = $e(e, this.max) - this._minPos, super.initOffsets(t);
      }
      buildLookupTable(t) {
        let { min: e, max: s2 } = this, n3 = [], o3 = [], a2, r, l4, c3, h5;
        for (a2 = 0, r = t.length; a2 < r; ++a2)
          c3 = t[a2], c3 >= e && c3 <= s2 && n3.push(c3);
        if (n3.length < 2)
          return [{ time: e, pos: 0 }, { time: s2, pos: 1 }];
        for (a2 = 0, r = n3.length; a2 < r; ++a2)
          h5 = n3[a2 + 1], l4 = n3[a2 - 1], c3 = n3[a2], Math.round((h5 + l4) / 2) !== c3 && o3.push({ time: c3, pos: a2 / (r - 1) });
        return o3;
      }
      _generate() {
        let t = this.min, e = this.max, s2 = super.getDataTimestamps();
        return (!s2.includes(t) || !s2.length) && s2.splice(0, 0, t), (!s2.includes(e) || s2.length === 1) && s2.push(e), s2.sort((n3, o3) => n3 - o3);
      }
      _getTimestampsForTable() {
        let t = this._cache.all || [];
        if (t.length)
          return t;
        let e = this.getDataTimestamps(), s2 = this.getLabelTimestamps();
        return e.length && s2.length ? t = this.normalize(e.concat(s2)) : t = e.length ? e : s2, t = this._cache.all = t, t;
      }
      getDecimalForValue(t) {
        return ($e(this._table, t) - this._minPos) / this._tableRange;
      }
      getValueForPixel(t) {
        let e = this._offsets, s2 = this.getDecimalForPixel(t) / e.factor - e.end;
        return $e(this._table, s2 * this._tableRange + this._minPos, true);
      }
    };
    Lc = Object.freeze({ __proto__: null, CategoryScale: cs, LinearScale: hs, LogarithmicScale: ds, RadialLinearScale: fs, TimeScale: be, TimeSeriesScale: gs });
    So = [ja, gl, lc, Lc];
    qt.register(...So);
    Bc = qt;
  }
});

// esbuild_serve:http-import:https://esm.sh/chart.js/auto
var auto_exports = {};
__export(auto_exports, {
  Animation: () => Hi,
  Animations: () => Xe,
  ArcElement: () => ss,
  BarController: () => ji,
  BarElement: () => as,
  BasePlatform: () => qe,
  BasicPlatform: () => Gi,
  BubbleController: () => $i,
  CategoryScale: () => cs,
  Chart: () => qt,
  Colors: () => yl,
  DatasetController: () => dt,
  Decimation: () => Sl,
  DomPlatform: () => Ji,
  DoughnutController: () => fe,
  Element: () => nt,
  Filler: () => $l,
  Interaction: () => qa,
  Legend: () => Gl,
  LineController: () => Ui,
  LineElement: () => Gt,
  LinearScale: () => hs,
  LogarithmicScale: () => ds,
  PieController: () => Yi,
  PointElement: () => os,
  PolarAreaController: () => Ke,
  RadarController: () => Xi,
  RadialLinearScale: () => fs,
  Scale: () => Et,
  ScatterController: () => Ki,
  SubTitle: () => Zl,
  Ticks: () => se,
  TimeScale: () => be,
  TimeSeriesScale: () => gs,
  Title: () => Ql,
  Tooltip: () => rc,
  _adapters: () => $a,
  _detectPlatform: () => gr,
  animator: () => mt,
  controllers: () => ja,
  default: () => Bc,
  defaults: () => W3,
  elements: () => gl,
  layouts: () => q3,
  plugins: () => lc,
  registerables: () => So,
  registry: () => ht,
  scales: () => Lc
});
var init_auto2 = __esm({
  "esbuild_serve:http-import:https://esm.sh/chart.js/auto"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_color();
    init_auto();
    init_auto();
  }
});

// esbuild_serve:http-import:https://unpkg.com/canvas-confetti@1.9.2/src/confetti.js
var require_confetti = __commonJS({
  "esbuild_serve:http-import:https://unpkg.com/canvas-confetti@1.9.2/src/confetti.js"(exports, module) {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    (function main(global2, module2, isWorker, workerSize) {
      var canUseWorker = !!(global2.Worker && global2.Blob && global2.Promise && global2.OffscreenCanvas && global2.OffscreenCanvasRenderingContext2D && global2.HTMLCanvasElement && global2.HTMLCanvasElement.prototype.transferControlToOffscreen && global2.URL && global2.URL.createObjectURL);
      var canUsePaths = typeof Path2D === "function" && typeof DOMMatrix === "function";
      var canDrawBitmap = function() {
        if (!global2.OffscreenCanvas) {
          return false;
        }
        var canvas = new OffscreenCanvas(1, 1);
        var ctx = canvas.getContext("2d");
        ctx.fillRect(0, 0, 1, 1);
        var bitmap = canvas.transferToImageBitmap();
        try {
          ctx.createPattern(bitmap, "no-repeat");
        } catch (e) {
          return false;
        }
        return true;
      }();
      function noop() {
      }
      function promise(func) {
        var ModulePromise = module2.exports.Promise;
        var Prom = ModulePromise !== void 0 ? ModulePromise : global2.Promise;
        if (typeof Prom === "function") {
          return new Prom(func);
        }
        func(noop, noop);
        return null;
      }
      var bitmapMapper = /* @__PURE__ */ function(skipTransform, map) {
        return {
          transform: function(bitmap) {
            if (skipTransform) {
              return bitmap;
            }
            if (map.has(bitmap)) {
              return map.get(bitmap);
            }
            var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(bitmap, 0, 0);
            map.set(bitmap, canvas);
            return canvas;
          },
          clear: function() {
            map.clear();
          }
        };
      }(canDrawBitmap, /* @__PURE__ */ new Map());
      var raf = function() {
        var TIME = Math.floor(1e3 / 60);
        var frame, cancel;
        var frames = {};
        var lastFrameTime = 0;
        if (typeof requestAnimationFrame === "function" && typeof cancelAnimationFrame === "function") {
          frame = function(cb) {
            var id = Math.random();
            frames[id] = requestAnimationFrame(function onFrame(time2) {
              if (lastFrameTime === time2 || lastFrameTime + TIME - 1 < time2) {
                lastFrameTime = time2;
                delete frames[id];
                cb();
              } else {
                frames[id] = requestAnimationFrame(onFrame);
              }
            });
            return id;
          };
          cancel = function(id) {
            if (frames[id]) {
              cancelAnimationFrame(frames[id]);
            }
          };
        } else {
          frame = function(cb) {
            return setTimeout(cb, TIME);
          };
          cancel = function(timer) {
            return clearTimeout(timer);
          };
        }
        return { frame, cancel };
      }();
      var getWorker = /* @__PURE__ */ function() {
        var worker;
        var prom;
        var resolves = {};
        function decorate(worker2) {
          function execute(options, callback) {
            worker2.postMessage({ options: options || {}, callback });
          }
          worker2.init = function initWorker(canvas) {
            var offscreen = canvas.transferControlToOffscreen();
            worker2.postMessage({ canvas: offscreen }, [offscreen]);
          };
          worker2.fire = function fireWorker(options, size, done) {
            if (prom) {
              execute(options, null);
              return prom;
            }
            var id = Math.random().toString(36).slice(2);
            prom = promise(function(resolve) {
              function workerDone(msg) {
                if (msg.data.callback !== id) {
                  return;
                }
                delete resolves[id];
                worker2.removeEventListener("message", workerDone);
                prom = null;
                bitmapMapper.clear();
                done();
                resolve();
              }
              worker2.addEventListener("message", workerDone);
              execute(options, id);
              resolves[id] = workerDone.bind(null, { data: { callback: id } });
            });
            return prom;
          };
          worker2.reset = function resetWorker() {
            worker2.postMessage({ reset: true });
            for (var id in resolves) {
              resolves[id]();
              delete resolves[id];
            }
          };
        }
        return function() {
          if (worker) {
            return worker;
          }
          if (!isWorker && canUseWorker) {
            var code = [
              "var CONFETTI, SIZE = {}, module = {};",
              "(" + main.toString() + ")(this, module, true, SIZE);",
              "onmessage = function(msg) {",
              "  if (msg.data.options) {",
              "    CONFETTI(msg.data.options).then(function () {",
              "      if (msg.data.callback) {",
              "        postMessage({ callback: msg.data.callback });",
              "      }",
              "    });",
              "  } else if (msg.data.reset) {",
              "    CONFETTI && CONFETTI.reset();",
              "  } else if (msg.data.resize) {",
              "    SIZE.width = msg.data.resize.width;",
              "    SIZE.height = msg.data.resize.height;",
              "  } else if (msg.data.canvas) {",
              "    SIZE.width = msg.data.canvas.width;",
              "    SIZE.height = msg.data.canvas.height;",
              "    CONFETTI = module.exports.create(msg.data.canvas);",
              "  }",
              "}"
            ].join("\n");
            try {
              worker = new Worker(URL.createObjectURL(new Blob([code])));
            } catch (e) {
              typeof console !== void 0 && typeof console.warn === "function" ? console.warn("\u{1F38A} Could not load worker", e) : null;
              return null;
            }
            decorate(worker);
          }
          return worker;
        };
      }();
      var defaults = {
        particleCount: 50,
        angle: 90,
        spread: 45,
        startVelocity: 45,
        decay: 0.9,
        gravity: 1,
        drift: 0,
        ticks: 200,
        x: 0.5,
        y: 0.5,
        shapes: ["square", "circle"],
        zIndex: 100,
        colors: [
          "#26ccff",
          "#a25afd",
          "#ff5e7e",
          "#88ff5a",
          "#fcff42",
          "#ffa62d",
          "#ff36ff"
        ],
        // probably should be true, but back-compat
        disableForReducedMotion: false,
        scalar: 1
      };
      function convert(val, transform) {
        return transform ? transform(val) : val;
      }
      function isOk(val) {
        return !(val === null || val === void 0);
      }
      function prop(options, name, transform) {
        return convert(
          options && isOk(options[name]) ? options[name] : defaults[name],
          transform
        );
      }
      function onlyPositiveInt(number) {
        return number < 0 ? 0 : Math.floor(number);
      }
      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
      }
      function toDecimal(str) {
        return parseInt(str, 16);
      }
      function colorsToRgb(colors) {
        return colors.map(hexToRgb);
      }
      function hexToRgb(str) {
        var val = String(str).replace(/[^0-9a-f]/gi, "");
        if (val.length < 6) {
          val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
        }
        return {
          r: toDecimal(val.substring(0, 2)),
          g: toDecimal(val.substring(2, 4)),
          b: toDecimal(val.substring(4, 6))
        };
      }
      function getOrigin(options) {
        var origin = prop(options, "origin", Object);
        origin.x = prop(origin, "x", Number);
        origin.y = prop(origin, "y", Number);
        return origin;
      }
      function setCanvasWindowSize(canvas) {
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;
      }
      function setCanvasRectSize(canvas) {
        var rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }
      function getCanvas(zIndex) {
        var canvas = document.createElement("canvas");
        canvas.style.position = "fixed";
        canvas.style.top = "0px";
        canvas.style.left = "0px";
        canvas.style.pointerEvents = "none";
        canvas.style.zIndex = zIndex;
        return canvas;
      }
      function ellipse(context, x5, y5, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
        context.save();
        context.translate(x5, y5);
        context.rotate(rotation);
        context.scale(radiusX, radiusY);
        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
        context.restore();
      }
      function randomPhysics(opts) {
        var radAngle = opts.angle * (Math.PI / 180);
        var radSpread = opts.spread * (Math.PI / 180);
        return {
          x: opts.x,
          y: opts.y,
          wobble: Math.random() * 10,
          wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
          velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
          angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
          tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
          color: opts.color,
          shape: opts.shape,
          tick: 0,
          totalTicks: opts.ticks,
          decay: opts.decay,
          drift: opts.drift,
          random: Math.random() + 2,
          tiltSin: 0,
          tiltCos: 0,
          wobbleX: 0,
          wobbleY: 0,
          gravity: opts.gravity * 3,
          ovalScalar: 0.6,
          scalar: opts.scalar,
          flat: opts.flat
        };
      }
      function updateFetti(context, fetti) {
        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
        fetti.velocity *= fetti.decay;
        if (fetti.flat) {
          fetti.wobble = 0;
          fetti.wobbleX = fetti.x + 10 * fetti.scalar;
          fetti.wobbleY = fetti.y + 10 * fetti.scalar;
          fetti.tiltSin = 0;
          fetti.tiltCos = 0;
          fetti.random = 1;
        } else {
          fetti.wobble += fetti.wobbleSpeed;
          fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
          fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);
          fetti.tiltAngle += 0.1;
          fetti.tiltSin = Math.sin(fetti.tiltAngle);
          fetti.tiltCos = Math.cos(fetti.tiltAngle);
          fetti.random = Math.random() + 2;
        }
        var progress = fetti.tick++ / fetti.totalTicks;
        var x1 = fetti.x + fetti.random * fetti.tiltCos;
        var y1 = fetti.y + fetti.random * fetti.tiltSin;
        var x22 = fetti.wobbleX + fetti.random * fetti.tiltCos;
        var y22 = fetti.wobbleY + fetti.random * fetti.tiltSin;
        context.fillStyle = "rgba(" + fetti.color.r + ", " + fetti.color.g + ", " + fetti.color.b + ", " + (1 - progress) + ")";
        context.beginPath();
        if (canUsePaths && fetti.shape.type === "path" && typeof fetti.shape.path === "string" && Array.isArray(fetti.shape.matrix)) {
          context.fill(transformPath2D(
            fetti.shape.path,
            fetti.shape.matrix,
            fetti.x,
            fetti.y,
            Math.abs(x22 - x1) * 0.1,
            Math.abs(y22 - y1) * 0.1,
            Math.PI / 10 * fetti.wobble
          ));
        } else if (fetti.shape.type === "bitmap") {
          var rotation = Math.PI / 10 * fetti.wobble;
          var scaleX = Math.abs(x22 - x1) * 0.1;
          var scaleY = Math.abs(y22 - y1) * 0.1;
          var width = fetti.shape.bitmap.width * fetti.scalar;
          var height = fetti.shape.bitmap.height * fetti.scalar;
          var matrix = new DOMMatrix([
            Math.cos(rotation) * scaleX,
            Math.sin(rotation) * scaleX,
            -Math.sin(rotation) * scaleY,
            Math.cos(rotation) * scaleY,
            fetti.x,
            fetti.y
          ]);
          matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));
          var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), "no-repeat");
          pattern.setTransform(matrix);
          context.globalAlpha = 1 - progress;
          context.fillStyle = pattern;
          context.fillRect(
            fetti.x - width / 2,
            fetti.y - height / 2,
            width,
            height
          );
          context.globalAlpha = 1;
        } else if (fetti.shape === "circle") {
          context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x22 - x1) * fetti.ovalScalar, Math.abs(y22 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x22 - x1) * fetti.ovalScalar, Math.abs(y22 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
        } else if (fetti.shape === "star") {
          var rot = Math.PI / 2 * 3;
          var innerRadius = 4 * fetti.scalar;
          var outerRadius = 8 * fetti.scalar;
          var x5 = fetti.x;
          var y5 = fetti.y;
          var spikes = 5;
          var step = Math.PI / spikes;
          while (spikes--) {
            x5 = fetti.x + Math.cos(rot) * outerRadius;
            y5 = fetti.y + Math.sin(rot) * outerRadius;
            context.lineTo(x5, y5);
            rot += step;
            x5 = fetti.x + Math.cos(rot) * innerRadius;
            y5 = fetti.y + Math.sin(rot) * innerRadius;
            context.lineTo(x5, y5);
            rot += step;
          }
        } else {
          context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
          context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
          context.lineTo(Math.floor(x22), Math.floor(y22));
          context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
        }
        context.closePath();
        context.fill();
        return fetti.tick < fetti.totalTicks;
      }
      function animate(canvas, fettis, resizer, size, done) {
        var animatingFettis = fettis.slice();
        var context = canvas.getContext("2d");
        var animationFrame;
        var destroy;
        var prom = promise(function(resolve) {
          function onDone() {
            animationFrame = destroy = null;
            context.clearRect(0, 0, size.width, size.height);
            bitmapMapper.clear();
            done();
            resolve();
          }
          function update() {
            if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
              size.width = canvas.width = workerSize.width;
              size.height = canvas.height = workerSize.height;
            }
            if (!size.width && !size.height) {
              resizer(canvas);
              size.width = canvas.width;
              size.height = canvas.height;
            }
            context.clearRect(0, 0, size.width, size.height);
            animatingFettis = animatingFettis.filter(function(fetti) {
              return updateFetti(context, fetti);
            });
            if (animatingFettis.length) {
              animationFrame = raf.frame(update);
            } else {
              onDone();
            }
          }
          animationFrame = raf.frame(update);
          destroy = onDone;
        });
        return {
          addFettis: function(fettis2) {
            animatingFettis = animatingFettis.concat(fettis2);
            return prom;
          },
          canvas,
          promise: prom,
          reset: function() {
            if (animationFrame) {
              raf.cancel(animationFrame);
            }
            if (destroy) {
              destroy();
            }
          }
        };
      }
      function confettiCannon(canvas, globalOpts) {
        var isLibCanvas = !canvas;
        var allowResize = !!prop(globalOpts || {}, "resize");
        var hasResizeEventRegistered = false;
        var globalDisableForReducedMotion = prop(globalOpts, "disableForReducedMotion", Boolean);
        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, "useWorker");
        var worker = shouldUseWorker ? getWorker() : null;
        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;
        var preferLessMotion = typeof matchMedia === "function" && matchMedia("(prefers-reduced-motion)").matches;
        var animationObj;
        function fireLocal(options, size, done) {
          var particleCount = prop(options, "particleCount", onlyPositiveInt);
          var angle = prop(options, "angle", Number);
          var spread = prop(options, "spread", Number);
          var startVelocity = prop(options, "startVelocity", Number);
          var decay = prop(options, "decay", Number);
          var gravity = prop(options, "gravity", Number);
          var drift = prop(options, "drift", Number);
          var colors = prop(options, "colors", colorsToRgb);
          var ticks = prop(options, "ticks", Number);
          var shapes = prop(options, "shapes");
          var scalar = prop(options, "scalar");
          var flat = !!prop(options, "flat");
          var origin = getOrigin(options);
          var temp = particleCount;
          var fettis = [];
          var startX = canvas.width * origin.x;
          var startY = canvas.height * origin.y;
          while (temp--) {
            fettis.push(
              randomPhysics({
                x: startX,
                y: startY,
                angle,
                spread,
                startVelocity,
                color: colors[temp % colors.length],
                shape: shapes[randomInt(0, shapes.length)],
                ticks,
                decay,
                gravity,
                drift,
                scalar,
                flat
              })
            );
          }
          if (animationObj) {
            return animationObj.addFettis(fettis);
          }
          animationObj = animate(canvas, fettis, resizer, size, done);
          return animationObj.promise;
        }
        function fire(options) {
          var disableForReducedMotion = globalDisableForReducedMotion || prop(options, "disableForReducedMotion", Boolean);
          var zIndex = prop(options, "zIndex", Number);
          if (disableForReducedMotion && preferLessMotion) {
            return promise(function(resolve) {
              resolve();
            });
          }
          if (isLibCanvas && animationObj) {
            canvas = animationObj.canvas;
          } else if (isLibCanvas && !canvas) {
            canvas = getCanvas(zIndex);
            document.body.appendChild(canvas);
          }
          if (allowResize && !initialized) {
            resizer(canvas);
          }
          var size = {
            width: canvas.width,
            height: canvas.height
          };
          if (worker && !initialized) {
            worker.init(canvas);
          }
          initialized = true;
          if (worker) {
            canvas.__confetti_initialized = true;
          }
          function onResize() {
            if (worker) {
              var obj = {
                getBoundingClientRect: function() {
                  if (!isLibCanvas) {
                    return canvas.getBoundingClientRect();
                  }
                }
              };
              resizer(obj);
              worker.postMessage({
                resize: {
                  width: obj.width,
                  height: obj.height
                }
              });
              return;
            }
            size.width = size.height = null;
          }
          function done() {
            animationObj = null;
            if (allowResize) {
              hasResizeEventRegistered = false;
              global2.removeEventListener("resize", onResize);
            }
            if (isLibCanvas && canvas) {
              document.body.removeChild(canvas);
              canvas = null;
              initialized = false;
            }
          }
          if (allowResize && !hasResizeEventRegistered) {
            hasResizeEventRegistered = true;
            global2.addEventListener("resize", onResize, false);
          }
          if (worker) {
            return worker.fire(options, size, done);
          }
          return fireLocal(options, size, done);
        }
        fire.reset = function() {
          if (worker) {
            worker.reset();
          }
          if (animationObj) {
            animationObj.reset();
          }
        };
        return fire;
      }
      var defaultFire;
      function getDefaultFire() {
        if (!defaultFire) {
          defaultFire = confettiCannon(null, { useWorker: true, resize: true });
        }
        return defaultFire;
      }
      function transformPath2D(pathString, pathMatrix, x5, y5, scaleX, scaleY, rotation) {
        var path2d = new Path2D(pathString);
        var t1 = new Path2D();
        t1.addPath(path2d, new DOMMatrix(pathMatrix));
        var t2 = new Path2D();
        t2.addPath(t1, new DOMMatrix([
          Math.cos(rotation) * scaleX,
          Math.sin(rotation) * scaleX,
          -Math.sin(rotation) * scaleY,
          Math.cos(rotation) * scaleY,
          x5,
          y5
        ]));
        return t2;
      }
      function shapeFromPath(pathData) {
        if (!canUsePaths) {
          throw new Error("path confetti are not supported in this browser");
        }
        var path2, matrix;
        if (typeof pathData === "string") {
          path2 = pathData;
        } else {
          path2 = pathData.path;
          matrix = pathData.matrix;
        }
        var path2d = new Path2D(path2);
        var tempCanvas = document.createElement("canvas");
        var tempCtx = tempCanvas.getContext("2d");
        if (!matrix) {
          var maxSize = 1e3;
          var minX = maxSize;
          var minY = maxSize;
          var maxX = 0;
          var maxY = 0;
          var width, height;
          for (var x5 = 0; x5 < maxSize; x5 += 2) {
            for (var y5 = 0; y5 < maxSize; y5 += 2) {
              if (tempCtx.isPointInPath(path2d, x5, y5, "nonzero")) {
                minX = Math.min(minX, x5);
                minY = Math.min(minY, y5);
                maxX = Math.max(maxX, x5);
                maxY = Math.max(maxY, y5);
              }
            }
          }
          width = maxX - minX;
          height = maxY - minY;
          var maxDesiredSize = 10;
          var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);
          matrix = [
            scale,
            0,
            0,
            scale,
            -Math.round(width / 2 + minX) * scale,
            -Math.round(height / 2 + minY) * scale
          ];
        }
        return {
          type: "path",
          path: path2,
          matrix
        };
      }
      function shapeFromText(textData) {
        var text, scalar = 1, color = "#000000", fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
        if (typeof textData === "string") {
          text = textData;
        } else {
          text = textData.text;
          scalar = "scalar" in textData ? textData.scalar : scalar;
          fontFamily = "fontFamily" in textData ? textData.fontFamily : fontFamily;
          color = "color" in textData ? textData.color : color;
        }
        var fontSize = 10 * scalar;
        var font = "" + fontSize + "px " + fontFamily;
        var canvas = new OffscreenCanvas(fontSize, fontSize);
        var ctx = canvas.getContext("2d");
        ctx.font = font;
        var size = ctx.measureText(text);
        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);
        var padding = 2;
        var x5 = size.actualBoundingBoxLeft + padding;
        var y5 = size.actualBoundingBoxAscent + padding;
        width += padding + padding;
        height += padding + padding;
        canvas = new OffscreenCanvas(width, height);
        ctx = canvas.getContext("2d");
        ctx.font = font;
        ctx.fillStyle = color;
        ctx.fillText(text, x5, y5);
        var scale = 1 / scalar;
        return {
          type: "bitmap",
          // TODO these probably need to be transfered for workers
          bitmap: canvas.transferToImageBitmap(),
          matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
        };
      }
      module2.exports = function() {
        return getDefaultFire().apply(this, arguments);
      };
      module2.exports.reset = function() {
        getDefaultFire().reset();
      };
      module2.exports.create = confettiCannon;
      module2.exports.shapeFromPath = shapeFromPath;
      module2.exports.shapeFromText = shapeFromText;
    })(function() {
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      return this || {};
    }(), module, false);
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js
var require_StreamSaver_min = __commonJS({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"(exports, module) {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    ((e, t) => {
      "undefined" != typeof module ? module.exports = t() : "function" == typeof define && "object" == typeof define.amd ? define(t) : exports.streamSaver = t();
    })(0, () => {
      "use strict";
      const e = "object" == typeof window ? window : exports;
      e.HTMLElement || console.warn("streamsaver is meant to run on browsers main thread");
      let t = null, a2 = false;
      const r = e.WebStreamsPolyfill || {}, n3 = e.isSecureContext;
      let o3 = /constructor/i.test(e.HTMLElement) || !!e.safari || !!e.WebKitPoint;
      const s2 = n3 || "MozAppearance" in document.documentElement.style ? "iframe" : "navigate", i4 = { createWriteStream: function(r2, m6, c3) {
        let d5 = { size: null, pathname: null, writableStrategy: void 0, readableStrategy: void 0 }, p6 = 0, u3 = null, f4 = null, g4 = null;
        Number.isFinite(m6) ? ([c3, m6] = [m6, c3], console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"), d5.size = c3, d5.writableStrategy = m6) : m6 && m6.highWaterMark ? (console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"), d5.size = c3, d5.writableStrategy = m6) : d5 = m6 || {};
        if (!o3) {
          t || (t = n3 ? l4(i4.mitm) : function(t2) {
            const a3 = "width=200,height=100", r3 = document.createDocumentFragment(), n4 = { frame: e.open(t2, "popup", a3), loaded: false, isIframe: false, isPopup: true, remove() {
              n4.frame.close();
            }, addEventListener(...e2) {
              r3.addEventListener(...e2);
            }, dispatchEvent(...e2) {
              r3.dispatchEvent(...e2);
            }, removeEventListener(...e2) {
              r3.removeEventListener(...e2);
            }, postMessage(...e2) {
              n4.frame.postMessage(...e2);
            } }, o5 = (t3) => {
              t3.source === n4.frame && (n4.loaded = true, e.removeEventListener("message", o5), n4.dispatchEvent(new Event("load")));
            };
            return e.addEventListener("message", o5), n4;
          }(i4.mitm)), f4 = new MessageChannel(), r2 = encodeURIComponent(r2.replace(/\//g, ":")).replace(/['()]/g, escape).replace(/\*/g, "%2A");
          const o4 = { transferringReadable: a2, pathname: d5.pathname || Math.random().toString().slice(-6) + "/" + r2, headers: { "Content-Type": "application/octet-stream; charset=utf-8", "Content-Disposition": "attachment; filename*=UTF-8''" + r2 } };
          d5.size && (o4.headers["Content-Length"] = d5.size);
          const m7 = [o4, "*", [f4.port2]];
          if (a2) {
            const e2 = "iframe" === s2 ? void 0 : { transform(e3, t3) {
              if (!(e3 instanceof Uint8Array))
                throw new TypeError("Can only write Uint8Arrays");
              p6 += e3.length, t3.enqueue(e3), u3 && (location.href = u3, u3 = null);
            }, flush() {
              u3 && (location.href = u3);
            } };
            g4 = new i4.TransformStream(e2, d5.writableStrategy, d5.readableStrategy);
            const t2 = g4.readable;
            f4.port1.postMessage({ readableStream: t2 }, [t2]);
          }
          f4.port1.onmessage = (e2) => {
            e2.data.download ? "navigate" === s2 ? (t.remove(), t = null, p6 ? location.href = e2.data.download : u3 = e2.data.download) : (t.isPopup && (t.remove(), t = null, "iframe" === s2 && l4(i4.mitm)), l4(e2.data.download)) : e2.data.abort && (h5 = [], f4.port1.postMessage("abort"), f4.port1.onmessage = null, f4.port1.close(), f4.port2.close(), f4 = null);
          }, t.loaded ? t.postMessage(...m7) : t.addEventListener("load", () => {
            t.postMessage(...m7);
          }, { once: true });
        }
        let h5 = [];
        return !o3 && g4 && g4.writable || new i4.WritableStream({ write(e2) {
          if (!(e2 instanceof Uint8Array))
            throw new TypeError("Can only write Uint8Arrays");
          o3 ? h5.push(e2) : (f4.port1.postMessage(e2), p6 += e2.length, u3 && (location.href = u3, u3 = null));
        }, close() {
          if (o3) {
            const e2 = new Blob(h5, { type: "application/octet-stream; charset=utf-8" }), t2 = document.createElement("a");
            t2.href = URL.createObjectURL(e2), t2.download = r2, t2.click();
          } else
            f4.port1.postMessage("end");
        }, abort() {
          h5 = [], f4.port1.postMessage("abort"), f4.port1.onmessage = null, f4.port1.close(), f4.port2.close(), f4 = null;
        } }, d5.writableStrategy);
      }, WritableStream: e.WritableStream || r.WritableStream, supported: true, version: { full: "2.0.5", major: 2, minor: 0, dot: 5 }, mitm: "https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0" };
      function l4(e2) {
        if (!e2)
          throw new Error("meh");
        const t2 = document.createElement("iframe");
        return t2.hidden = true, t2.src = e2, t2.loaded = false, t2.name = "iframe", t2.isIframe = true, t2.postMessage = (...e3) => t2.contentWindow.postMessage(...e3), t2.addEventListener("load", () => {
          t2.loaded = true;
        }, { once: true }), document.body.appendChild(t2), t2;
      }
      try {
        new Response(new ReadableStream()), n3 && !("serviceWorker" in navigator) && (o3 = true);
      } catch (e2) {
        o3 = true;
      }
      return ((e2) => {
        try {
          e2();
        } catch (e3) {
        }
      })(() => {
        const { readable: e2 } = new TransformStream(), t2 = new MessageChannel();
        t2.port1.postMessage(e2, [e2]), t2.port1.close(), t2.port2.close(), a2 = true, Object.defineProperty(i4, "TransformStream", { configurable: false, writable: false, value: TransformStream });
      }), i4;
    });
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/util.js
var errors, config;
var init_util = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/util.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    errors = {
      INVALID: ["seeking position failed.", "InvalidStateError"],
      GONE: ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"],
      MISMATCH: ["The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"],
      MOD_ERR: ["The object can not be modified in this way.", "InvalidModificationError"],
      SYNTAX: (m6) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m6}`, "SyntaxError"],
      SECURITY: ["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.", "SecurityError"],
      DISALLOWED: ["The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError"]
    };
    config = {
      writable: globalThis.WritableStream
    };
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/adapters/sandbox.js
var sandbox_exports = {};
__export(sandbox_exports, {
  FileHandle: () => FileHandle,
  FolderHandle: () => FolderHandle,
  default: () => sandbox_default
});
var DISALLOWED, Sink, FileHandle, FolderHandle, sandbox_default;
var init_sandbox = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/adapters/sandbox.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_util();
    ({ DISALLOWED } = errors);
    Sink = class {
      /**
       * @param {FileWriter} writer
       * @param {FileEntry} fileEntry
       */
      constructor(writer, fileEntry) {
        this.writer = writer;
        this.fileEntry = fileEntry;
      }
      /**
       * @param {BlobPart | Object} chunk
       */
      async write(chunk) {
        if (typeof chunk === "object") {
          if (chunk.type === "write") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                await new Promise((resolve, reject2) => {
                  this.writer.onwriteend = resolve;
                  this.writer.onerror = reject2;
                  this.writer.truncate(chunk.position);
                });
                this.writer.seek(chunk.position);
              }
            }
            if (!("data" in chunk)) {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument", "SyntaxError");
            }
            chunk = chunk.data;
          } else if (chunk.type === "seek") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                throw new DOMException("seeking position failed", "InvalidStateError");
              }
              return;
            } else {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument", "SyntaxError");
            }
          } else if (chunk.type === "truncate") {
            return new Promise((resolve) => {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                this.writer.onwriteend = (evt) => resolve();
                this.writer.truncate(chunk.size);
              } else {
                throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument", "SyntaxError");
              }
            });
          }
        }
        await new Promise((resolve, reject2) => {
          this.writer.onwriteend = resolve;
          this.writer.onerror = reject2;
          this.writer.write(new Blob([chunk]));
        });
      }
      close() {
        return new Promise(this.fileEntry.file.bind(this.fileEntry));
      }
    };
    FileHandle = class {
      /** @param {FileEntry} file */
      constructor(file2, writable = true) {
        this.file = file2;
        this.kind = "file";
        this.writable = writable;
        this.readable = true;
      }
      get name() {
        return this.file.name;
      }
      /**
       * @param {{ file: { toURL: () => string; }; }} other
       */
      isSameEntry(other) {
        return this.file.toURL() === other.file.toURL();
      }
      /** @return {Promise<File>} */
      getFile() {
        return new Promise(this.file.file.bind(this.file));
      }
      /** @return {Promise<Sink>} */
      createWritable(opts) {
        if (!this.writable)
          throw new DOMException(...DISALLOWED);
        return new Promise(
          (resolve, reject2) => this.file.createWriter((fileWriter) => {
            if (opts.keepExistingData === false) {
              fileWriter.onwriteend = (evt) => resolve(new Sink(fileWriter, this.file));
              fileWriter.truncate(0);
            } else {
              resolve(new Sink(fileWriter, this.file));
            }
          }, reject2)
        );
      }
    };
    FolderHandle = class _FolderHandle {
      /** @param {DirectoryEntry} dir */
      constructor(dir, writable = true) {
        this.dir = dir;
        this.writable = writable;
        this.readable = true;
        this.kind = "directory";
        this.name = dir.name;
      }
      /** @param {FolderHandle} other */
      isSameEntry(other) {
        return this.dir.fullPath === other.dir.fullPath;
      }
      /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */
      async *entries() {
        const reader = this.dir.createReader();
        const entries = await new Promise(reader.readEntries.bind(reader));
        for (const x5 of entries) {
          yield [x5.name, x5.isFile ? new FileHandle(x5, this.writable) : new _FolderHandle(x5, this.writable)];
        }
      }
      /**
       * @param {string} name
       * @param {{ create: boolean; }} opts
       * @returns {Promise<FolderHandle>}
       */
      getDirectoryHandle(name, opts) {
        return new Promise((resolve, reject2) => {
          this.dir.getDirectory(name, opts, (dir) => {
            resolve(new _FolderHandle(dir));
          }, reject2);
        });
      }
      /**
       * @param {string} name
       * @param {{ create: boolean; }} opts
       * @returns {Promise<FileHandle>}
       */
      getFileHandle(name, opts) {
        return new Promise(
          (resolve, reject2) => this.dir.getFile(name, opts, (file2) => resolve(new FileHandle(file2)), reject2)
        );
      }
      /**
       * @param {string} name
       * @param {{ recursive: boolean; }} opts
       */
      async removeEntry(name, opts) {
        const entry = await this.getDirectoryHandle(name, { create: false }).catch(
          (err) => err.name === "TypeMismatchError" ? this.getFileHandle(name, { create: false }) : err
        );
        if (entry instanceof Error)
          throw entry;
        return new Promise((resolve, reject2) => {
          if (entry instanceof _FolderHandle) {
            opts.recursive ? entry.dir.removeRecursively(() => resolve(), reject2) : entry.dir.remove(() => resolve(), reject2);
          } else if (entry.file) {
            entry.file.remove(() => resolve(), reject2);
          }
        });
      }
    };
    sandbox_default = (opts = {}) => new Promise(
      (resolve, reject2) => window.webkitRequestFileSystem(
        opts._persistent,
        0,
        (e) => resolve(new FolderHandle(e.root)),
        reject2
      )
    );
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemHandle.js
var kAdapter, FileSystemHandle, FileSystemHandle_default;
var init_FileSystemHandle = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemHandle.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    kAdapter = Symbol("adapter");
    FileSystemHandle = class {
      /** @type {FileSystemHandle} */
      [kAdapter];
      /** @type {string} */
      name;
      /** @type {('file'|'directory')} */
      kind;
      /** @param {FileSystemHandle & {writable}} adapter */
      constructor(adapter) {
        this.kind = adapter.kind;
        this.name = adapter.name;
        this[kAdapter] = adapter;
      }
      /** @param {FileSystemHandlePermissionDescriptor} descriptor */
      async queryPermission(descriptor = {}) {
        const { mode = "read" } = descriptor;
        const handle = this[kAdapter];
        if (handle.queryPermission) {
          return handle.queryPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async requestPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.requestPermission) {
          return handle.requestPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      /**
       * Attempts to remove the entry represented by handle from the underlying file system.
       *
       * @param {object} options
       * @param {boolean} [options.recursive=false]
       */
      async remove(options = {}) {
        await this[kAdapter].remove(options);
      }
      /**
       * @param {FileSystemHandle} other
       */
      async isSameEntry(other) {
        if (this === other)
          return true;
        if (!other || typeof other !== "object" || this.kind !== other.kind || !other[kAdapter])
          return false;
        return this[kAdapter].isSameEntry(other[kAdapter]);
      }
    };
    Object.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    if (globalThis.FileSystemHandle) {
      globalThis.FileSystemHandle.prototype.queryPermission ??= function(descriptor) {
        return "granted";
      };
    }
    FileSystemHandle_default = FileSystemHandle;
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/config.js
var config2, config_default;
var init_config = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/config.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    config2 = {
      ReadableStream: globalThis.ReadableStream,
      WritableStream: globalThis.WritableStream,
      TransformStream: globalThis.TransformStream,
      DOMException: globalThis.DOMException,
      Blob: globalThis.Blob,
      File: globalThis.File
    };
    config_default = config2;
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemWritableFileStream.js
var WritableStream, FileSystemWritableFileStream, FileSystemWritableFileStream_default;
var init_FileSystemWritableFileStream = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemWritableFileStream.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_config();
    ({ WritableStream } = config_default);
    FileSystemWritableFileStream = class _FileSystemWritableFileStream extends WritableStream {
      #writer;
      constructor(writer) {
        super(writer);
        this.#writer = writer;
        Object.setPrototypeOf(this, _FileSystemWritableFileStream.prototype);
        this._closed = false;
      }
      async close() {
        this._closed = true;
        const w4 = this.getWriter();
        const p6 = w4.close();
        w4.releaseLock();
        return p6;
      }
      /** @param {number} position */
      seek(position) {
        return this.write({ type: "seek", position });
      }
      /** @param {number} size */
      truncate(size) {
        return this.write({ type: "truncate", size });
      }
      // The write(data) method steps are:
      write(data) {
        if (this._closed) {
          return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
        }
        const writer = this.getWriter();
        const result = writer.write(data);
        writer.releaseLock();
        return result;
      }
    };
    Object.defineProperty(FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
      value: "FileSystemWritableFileStream",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemWritableFileStream.prototype, {
      close: { enumerable: true },
      seek: { enumerable: true },
      truncate: { enumerable: true },
      write: { enumerable: true }
    });
    if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable && !globalThis.FileSystemWritableFileStream) {
      globalThis.FileSystemWritableFileStream = FileSystemWritableFileStream;
    }
    FileSystemWritableFileStream_default = FileSystemWritableFileStream;
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemFileHandle.js
var FileSystemFileHandle_exports = {};
__export(FileSystemFileHandle_exports, {
  FileSystemFileHandle: () => FileSystemFileHandle,
  default: () => FileSystemFileHandle_default
});
var INVALID2, SYNTAX, GONE, kAdapter2, FileSystemFileHandle, FileSystemFileHandle_default;
var init_FileSystemFileHandle = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemFileHandle.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_FileSystemHandle();
    init_FileSystemWritableFileStream();
    init_util();
    ({ INVALID: INVALID2, SYNTAX, GONE } = errors);
    kAdapter2 = Symbol("adapter");
    FileSystemFileHandle = class extends FileSystemHandle_default {
      /** @type {FileSystemFileHandle} */
      [kAdapter2];
      constructor(adapter) {
        super(adapter);
        this[kAdapter2] = adapter;
      }
      /**
       * @param  {Object} [options={}]
       * @param  {boolean} [options.keepExistingData]
       * @returns {Promise<FileSystemWritableFileStream>}
       */
      async createWritable(options = {}) {
        return new FileSystemWritableFileStream_default(
          await this[kAdapter2].createWritable(options)
        );
      }
      /**
       * @returns {Promise<File>}
       */
      async getFile() {
        return this[kAdapter2].getFile();
      }
    };
    Object.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemFileHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemFileHandle.prototype, {
      createWritable: { enumerable: true },
      getFile: { enumerable: true }
    });
    if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable) {
      const wm = /* @__PURE__ */ new WeakMap();
      let workerUrl;
      const code = () => {
        let fileHandle, handle;
        onmessage = async (evt) => {
          const port = evt.ports[0];
          const cmd = evt.data;
          switch (cmd.type) {
            case "open":
              const file2 = cmd.name;
              let dir = await navigator.storage.getDirectory();
              for (const folder of cmd.path) {
                dir = await dir.getDirectoryHandle(folder);
              }
              fileHandle = await dir.getFileHandle(file2);
              handle = await fileHandle.createSyncAccessHandle();
              break;
            case "write":
              handle.write(cmd.data, { at: cmd.position });
              handle.flush();
              break;
            case "truncate":
              handle.truncate(cmd.size);
              break;
            case "abort":
            case "close":
              handle.close();
              break;
          }
          port.postMessage(0);
        };
      };
      globalThis.FileSystemFileHandle.prototype.createWritable = async function(options) {
        if (!workerUrl) {
          const stringCode = `(${code.toString()})()`;
          const blob2 = new Blob([stringCode], {
            type: "text/javascript"
          });
          workerUrl = URL.createObjectURL(blob2);
        }
        const worker = new Worker(workerUrl, { type: "module" });
        let position = 0;
        const textEncoder = new TextEncoder();
        let size = await this.getFile().then((file2) => file2.size);
        const send = (message) => new Promise((resolve, reject2) => {
          const mc2 = new MessageChannel();
          mc2.port1.onmessage = (evt) => {
            if (evt.data instanceof Error)
              reject2(evt.data);
            else
              resolve(evt.data);
            mc2.port1.close();
            mc2.port2.close();
            mc2.port1.onmessage = null;
          };
          worker.postMessage(message, [mc2.port2]);
        });
        const root = await navigator.storage.getDirectory();
        const parent = await wm.get(this);
        const path2 = await root.resolve(parent);
        if (path2 === null)
          throw new DOMException(...GONE);
        let controller;
        await send({ type: "open", path: path2, name: this.name });
        if (options?.keepExistingData === false) {
          await send({ type: "truncate", size: 0 });
          size = 0;
        }
        const ws2 = new FileSystemWritableFileStream_default({
          start: (ctrl) => {
            controller = ctrl;
          },
          async write(chunk) {
            const isPlainObject = chunk?.constructor === Object;
            if (isPlainObject) {
              chunk = { ...chunk };
            } else {
              chunk = { type: "write", data: chunk, position };
            }
            if (chunk.type === "write") {
              if (!("data" in chunk)) {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("write requires a data argument"));
              }
              chunk.position ??= position;
              if (typeof chunk.data === "string") {
                chunk.data = textEncoder.encode(chunk.data);
              } else if (chunk.data instanceof ArrayBuffer) {
                chunk.data = new Uint8Array(chunk.data);
              } else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) {
                chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);
              } else if (!(chunk.data instanceof Uint8Array)) {
                const ab = await new Response(chunk.data).arrayBuffer();
                chunk.data = new Uint8Array(ab);
              }
              if (Number.isInteger(chunk.position) && chunk.position >= 0) {
                position = chunk.position;
              }
              position += chunk.data.byteLength;
              size += chunk.data.byteLength;
            } else if (chunk.type === "seek") {
              if (Number.isInteger(chunk.position) && chunk.position >= 0) {
                if (size < chunk.position) {
                  throw new DOMException(...INVALID2);
                }
                console.log("seeking", chunk);
                position = chunk.position;
                return;
              } else {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("seek requires a position argument"));
              }
            } else if (chunk.type === "truncate") {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                size = chunk.size;
                if (position > size) {
                  position = size;
                }
              } else {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("truncate requires a size argument"));
              }
            }
            await send(chunk);
          },
          async close() {
            await send({ type: "close" });
            worker.terminate();
          },
          async abort(reason) {
            await send({ type: "abort", reason });
            worker.terminate();
          }
        });
        return ws2;
      };
      const orig = FileSystemDirectoryHandle.prototype.getFileHandle;
      FileSystemDirectoryHandle.prototype.getFileHandle = async function(...args) {
        const handle = await orig.call(this, ...args);
        wm.set(handle, this);
        return handle;
      };
    }
    FileSystemFileHandle_default = FileSystemFileHandle;
  }
});

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemDirectoryHandle.js
var FileSystemDirectoryHandle_exports = {};
__export(FileSystemDirectoryHandle_exports, {
  FileSystemDirectoryHandle: () => FileSystemDirectoryHandle2,
  default: () => FileSystemDirectoryHandle_default
});
var GONE2, MOD_ERR, kAdapter3, FileSystemDirectoryHandle2, FileSystemDirectoryHandle_default;
var init_FileSystemDirectoryHandle = __esm({
  "esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/FileSystemDirectoryHandle.js"() {
    init_polyfill();
    init_bug_reporter();
    init_mod();
    init_urlpattern_polyfill();
    init_main();
    init_popover_polyfill();
    init_FileSystemHandle();
    init_util();
    ({ GONE: GONE2, MOD_ERR } = errors);
    kAdapter3 = Symbol("adapter");
    FileSystemDirectoryHandle2 = class _FileSystemDirectoryHandle extends FileSystemHandle_default {
      /** @type {FileSystemDirectoryHandle} */
      [kAdapter3];
      constructor(adapter) {
        super(adapter);
        this[kAdapter3] = adapter;
      }
      /**
       * @param {string} name Name of the directory
       * @param {object} [options]
       * @param {boolean} [options.create] create the directory if don't exist
       * @returns {Promise<FileSystemDirectoryHandle>}
       */
      async getDirectoryHandle(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getDirectoryHandle(name, options);
        return new _FileSystemDirectoryHandle(handle);
      }
      /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */
      async *entries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        for await (const [_5, entry] of this[kAdapter3].entries())
          yield [entry.name, entry.kind === "file" ? new FileSystemFileHandle2(entry) : new _FileSystemDirectoryHandle(entry)];
      }
      /** @deprecated use .entries() instead */
      async *getEntries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        console.warn("deprecated, use .entries() instead");
        for await (let entry of this[kAdapter3].entries())
          yield entry.kind === "file" ? new FileSystemFileHandle2(entry) : new _FileSystemDirectoryHandle(entry);
      }
      /**
       * @param {string} name Name of the file
       * @param {object} [options]
       * @param {boolean} [options.create] create the file if don't exist
       */
      async getFileHandle(name, options = {}) {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        if (name === "")
          throw new TypeError(`Name can't be an empty string.`);
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getFileHandle(name, options);
        return new FileSystemFileHandle2(handle);
      }
      /**
       * @param {string} name
       * @param {object} [options]
       * @param {boolean} [options.recursive]
       */
      async removeEntry(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.recursive = !!options.recursive;
        return this[kAdapter3].removeEntry(name, options);
      }
      async resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path: path2 } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path2, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path2, entry.name] });
            }
          }
        }
        return null;
      }
      async *keys() {
        for await (const [name] of this[kAdapter3].entries())
          yield name;
      }
      async *values() {
        for await (const [_5, entry] of this)
          yield entry;
      }
      [Symbol.asyncIterator]() {
        return this.entries();
      }
    };
    Object.defineProperty(FileSystemDirectoryHandle2.prototype, Symbol.toStringTag, {
      value: "FileSystemDirectoryHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemDirectoryHandle2.prototype, {
      getDirectoryHandle: { enumerable: true },
      entries: { enumerable: true },
      getFileHandle: { enumerable: true },
      removeEntry: { enumerable: true }
    });
    if (globalThis.FileSystemDirectoryHandle) {
      const proto = globalThis.FileSystemDirectoryHandle.prototype;
      proto.resolve = async function resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path: path2 } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path2, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path2, entry.name] });
            }
          }
        }
        return null;
      };
      async function ensureDoActuallyStillExist(handle) {
        const root = await navigator.storage.getDirectory();
        const path2 = await root.resolve(handle);
        if (path2 === null) {
          throw new DOMException(...GONE2);
        }
      }
      const entries = proto.entries;
      proto.entries = async function* () {
        await ensureDoActuallyStillExist(this);
        yield* entries.call(this);
      };
      proto[Symbol.asyncIterator] = async function* () {
        yield* this.entries();
      };
      const removeEntry = proto.removeEntry;
      proto.removeEntry = async function(name, options = {}) {
        return removeEntry.call(this, name, options).catch(async (err) => {
          const unknown = err instanceof DOMException && err.name === "UnknownError";
          if (unknown && !options.recursive) {
            const empty = (await entries.call(this).next()).done;
            if (!empty) {
              throw new DOMException(...MOD_ERR);
            }
          }
          throw err;
        });
      };
    }
    FileSystemDirectoryHandle_default = FileSystemDirectoryHandle2;
  }
});

// pages/hosting/main.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/components.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/webgen.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Style.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Components.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function css(data, ...expr) {
  const merge = data.map((x5, i4) => x5 + (expr[i4] || ""));
  const style = new CSSStyleSheet();
  style.replaceSync(merge.join(""));
  return style;
}
var createElement = (tagName, options) => window.document.createElement(tagName, options);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/css/themes.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var blur = {
  ["--background-color"]: "hsla(0, 0%, 4%, 1)",
  ["--on-background-text"]: "white",
  ["--background-card"]: "hsl(0deg 0% 8% / 68%)",
  ["--on-card-text"]: "#ffffff",
  ["--on-card-subtext"]: "#646464",
  ["--on-card-background"]: "rgb(41 41 41)",
  ["--text-red"]: "#f81919",
  ["--backdrop-filter"]: "blur(1rem)",
  ["--color-grayscaled-inline-font"]: "white"
};
var dark = {
  ["--box-shadow"]: "none",
  ["--background-color"]: "hsla(0, 0%, 4%, 1)",
  ["--on-background-text"]: "#dddddd",
  ["--background-card"]: "hsla(0, 0%, 9%, 1)",
  ["--on-card-text"]: "#ffffff",
  ["--on-card-subtext"]: "#646464",
  ["--on-card-background"]: "hsl(0deg 0% 14%)",
  ["--text-red"]: "#f81919",
  ["--color-grayscaled-inline-font"]: "white",
  ["--color-disabled-lightness"]: "14%",
  ["--color-disabled-font"]: "#5c5c5c"
};
var light = {
  ["--box-shadow"]: " 0px 4px 8px 0px rgb(0 0 0 / 15%)",
  ["--background-color"]: "hsl(0deg, 0%, 97.45%)",
  ["--on-background-text"]: "#2f363a",
  ["--background-card"]: " hsla(0, 0%, 100%, 1)",
  ["--on-card-text"]: "#2d2d2d",
  ["--on-card-subtext"]: "#646464",
  ["--on-card-background"]: " rgb(255, 255, 255)",
  ["--text-red"]: "#f81919",
  ["--color-grayscaled-lightness"]: "15%",
  ["--color-grayscaled-font"]: "#ffffff",
  ["--color-grayscaled-inline-font"]: "black"
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Style.ts
var Style = class {
  theme;
  current = 1 /* gray */;
  mediaQuery = globalThis.matchMedia("(prefers-color-scheme: dark)");
  options;
  constructor(options) {
    const styleAppendTo = options.defaultElementToHookStylesIn ?? document.documentElement;
    this.options = options;
    this.theme = styleAppendTo;
    const data = (options.primaryColor ?? "hsl(200, 50%, 40%)")?.match(/hsl\((?<hue>\d+), (?<saturation>\d+%), .*%\)/);
    if (!(data && data.groups && data.groups.hue && data.groups.saturation))
      throw new Error("Bad Primary Color");
    document.adoptedStyleSheets.push(css`:root{ --webgen-primary-hue: ${data.groups.hue}; --webgen-primary-sat: ${data.groups.saturation};}`);
    this.mediaQuery.addEventListener("change", (e) => {
      if (this.current == 5 /* autoDark */ || this.current == 6 /* autoLight */)
        this.updateTheme(e.matches ? 5 /* autoDark */ : 6 /* autoLight */);
    });
  }
  getTheme = () => this.current;
  getColors = () => ({
    ["critical" /* Critical */]: [360, 86, 65, "#333333"],
    ["colored" /* Colored */]: [227, 85, 65, "#FFFFFF"],
    ["grayscaled" /* Grayscaled */]: [0, 0, 100, "#333333"],
    ["disabled" /* Disabled */]: [0, 0, 75, "#A0A0A0"]
  });
  overrideTheme(data) {
    const dataWithDefaults = {
      ...this.getMapping()[this.current],
      ...data
    };
    this.applyStyles(dataWithDefaults);
  }
  mapColorDef(data) {
    const object = {};
    Object.entries(data).forEach(([color, values]) => {
      const indexToName = ["hue", "saturation", "lightness", "font"];
      values.forEach((value, index) => {
        object[`--color-${color}-${indexToName[index]}`] = value.toString() + ["deg", "%", "%", ""][index];
      });
    });
    return object;
  }
  applyStyles(data) {
    const extendData = {
      ...this.mapColorDef(this.getColors()),
      ...data
    };
    Object.entries(extendData).forEach(([key, value]) => this.theme.style.setProperty(key, value));
  }
  updateTheme(theme) {
    this.options.events?.themeRefreshed?.(theme, this);
    if (theme === 4 /* auto */)
      this.updateTheme(this.mediaQuery.matches ? 5 /* autoDark */ : 6 /* autoLight */);
    else {
      if (this.current == theme)
        return;
      if (theme === 1 /* gray */)
        this.theme.removeAttribute("style");
      this.applyStyles(this.getMapping()[theme]);
      document.body.setAttribute("data-theme", theme == 0 /* light */ || theme == 6 /* autoLight */ ? "light" : "dark");
      this.current = theme;
      this.options.events?.themeChanged?.(theme, this);
    }
  }
  getMapping = () => ({
    [0 /* light */]: light,
    [1 /* gray */]: {},
    [2 /* dark */]: dark,
    [3 /* blur */]: blur,
    [6 /* autoLight */]: light,
    [5 /* autoDark */]: dark
  });
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Body.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Custom.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Component.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/State.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Empty.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Box.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function Box(...components) {
  const block = createElement("div");
  block.append(...components.map((x5) => x5.draw()));
  return Custom(block);
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Empty.ts
var Empty = () => Box().removeFromLayout();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/State.ts
function isState(obj) {
  return typeof obj === "object" && obj !== null && "$on" in obj && typeof obj.$on === "function";
}
function isRef(obj) {
  return typeof obj === "object" && obj !== null && "listen" in obj;
}
function asRef(value) {
  if (isRef(value))
    return value;
  let _val = value;
  const list = /* @__PURE__ */ new Set();
  return {
    setValue: (val) => {
      const oldval = _val;
      _val = val;
      if (oldval === _val)
        return;
      for (const iterator of list) {
        iterator(val, oldval);
      }
    },
    getValue: () => _val,
    map: (map) => {
      const Ref = asRef(map(_val));
      list.add((val) => {
        Ref.setValue(map(val));
      });
      return Ref;
    },
    listen: (callback) => {
      list.add(callback);
      callback(_val);
    },
    asRefComponent: () => {
      if (!(_val instanceof Component)) {
        throw new Error("asRefComponent called on a non component Ref.");
      }
      console.debug("asRefComponent got constructed");
      const wrapper = Empty().draw();
      wrapper.append(_val.draw());
      list.add((val) => {
        wrapper.textContent = "";
        wrapper.append(val.draw());
      });
      return Custom(wrapper);
    },
    addItem: (item) => {
      if (!Array.isArray(_val)) {
        throw new Error("addItem called on a non array Ref.");
      }
      _val.push(item);
      list.forEach((it) => it(_val));
    },
    removeItem: (item) => {
      if (!Array.isArray(_val)) {
        throw new Error("addItem called on a non array Ref.");
      }
      const index = _val.indexOf(item);
      if (index === -1)
        return;
      _val.splice(index, 1);
      list.forEach((it) => it(_val));
    }
  };
}
function refMerge(data) {
  const loadData = () => Object.fromEntries(Object.entries(data).map(([key, value]) => [key, value.getValue()]));
  const internalValue = asRef(loadData());
  for (const iterator of Object.values(data)) {
    let firstTime = true;
    iterator.listen(() => {
      if (firstTime)
        return firstTime = false;
      internalValue.setValue(loadData());
    });
  }
  return internalValue;
}
var dependencyCollector = /* @__PURE__ */ new Map();
function _state(data, state2 = {}) {
  if (isState(data) || typeof data !== "object")
    return data;
  const observers = state2.o || /* @__PURE__ */ new Map();
  const observerProperties = state2.op || /* @__PURE__ */ new Map();
  const isArray = Array.isArray(data);
  const children = [];
  const proxySource = isArray ? [] : Object.create(data, {});
  for (const property in data) {
    const entry = data[property];
    if ("HTMLElement" in globalThis && entry instanceof HTMLElement)
      throw new Error("Cannot set a HTMLElement in an State Object");
    if (typeof entry === "object" && entry !== null) {
      proxySource[property] = !isState(entry) ? _state(entry) : entry;
      children.push(property);
    } else {
      proxySource[property] = entry;
    }
  }
  const dep = (a2) => (p6, c3) => {
    let obs = observers.get(p6);
    let props = observerProperties.get(c3);
    if (!obs) {
      obs = /* @__PURE__ */ new Set();
      observers.set(p6, obs);
    }
    if (!props) {
      props = /* @__PURE__ */ new Set();
      observerProperties.set(c3, props);
    }
    obs[a2](c3);
    props[a2](p6);
  };
  const $on = dep("add");
  const $off = dep("delete");
  const _em = (property, newValue, oldValue) => {
    observers.has(property) && observers.get(property).forEach((c3) => c3(newValue, oldValue));
  };
  const _st = () => {
    return {
      o: observers,
      op: observerProperties,
      r: proxySource,
      p: proxy._p
    };
  };
  const depProps = {
    $on,
    // Listen to properties
    $off,
    // Stop listening to properties
    _em,
    // Emit a change event for a given property
    _st,
    _p: void 0
  };
  const proxy = new Proxy(proxySource, {
    has(target, key) {
      return key in depProps || key in target;
    },
    get(...args) {
      const [, p6] = args;
      if (Reflect.has(depProps, p6))
        return Reflect.get(depProps, p6);
      if (typeof p6 === "string" && p6.startsWith("$"))
        return {
          getValue: () => proxy[p6.replace("$", "")],
          setValue: (val) => {
            proxy[p6.replace("$", "")] = val;
          },
          map: (map) => {
            const key = p6.replace("$", "");
            const pointer = asRef(proxy[key]);
            const c3 = (newVal) => pointer.setValue(map(newVal));
            c3(proxy[key]);
            $on(key, (val, oldVal) => c3(val, oldVal));
            return pointer;
          },
          listen: (c3) => {
            const key = p6.replace("$", "");
            c3(proxy[key]);
            $on(p6.replace("$", ""), (val, oldVal) => c3(val, oldVal));
          },
          addItem: (item) => {
            if (!Array.isArray(proxy[p6.replace("$", "")])) {
              throw new Error("addItem called on a non array Ref.");
            }
            proxy[p6.replace("$", "")].push(item);
          },
          removeItem: (item) => {
            if (!Array.isArray(proxy[p6.replace("$", "")])) {
              throw new Error("addItem called on a non array Ref.");
            }
            const index = proxy[p6.replace("$", "")].indexOf(item);
            if (index === -1)
              return;
            proxy[p6.replace("$", "")].splice(index, 1);
          }
        };
      const value = Reflect.get(...args);
      addDep(proxy, p6);
      if (isArray && p6 in Array.prototype) {
        return arrayOperation(
          p6,
          proxySource,
          proxy,
          value
        );
      }
      return value;
    },
    set(...args) {
      const [target, property, value] = args;
      const old = Reflect.get(target, property);
      if (Reflect.has(depProps, property)) {
        return Reflect.set(depProps, property, value);
      }
      if (value && isState(old)) {
        const o3 = old;
        const oldState = o3._st();
        const newR = isState(value) ? reactiveMerge(value, o3) : _state(value, oldState);
        Reflect.set(
          target,
          property,
          // Create a new reactive object
          newR
        );
        _em(property, newR);
        oldState.o.forEach((_c2, property2) => {
          const oldValue = Reflect.get(old, property2);
          const newValue = Reflect.get(newR, property2);
          if (oldValue !== newValue) {
            o3._em(property2, newValue, oldValue);
          }
        });
        return true;
      }
      const didSet = Reflect.set(...args);
      if (didSet) {
        if (old !== value) {
          _em(property, value, old);
        }
        if (proxy._p) {
          proxy._p[1]._em(...proxy._p);
        }
      }
      return didSet;
    }
  });
  if (state2.p)
    proxy._p = state2.p;
  children.map((c3) => {
    proxy[c3]._p = [c3, proxy];
  });
  return proxy;
}
function addDep(proxy, property) {
  dependencyCollector.forEach((tracker) => {
    let properties = tracker.get(proxy);
    if (!properties) {
      properties = /* @__PURE__ */ new Set();
      tracker.set(proxy, properties);
    }
    properties.add(property);
  });
}
function arrayOperation(op, arr, proxy, native) {
  const synthetic = (...args) => {
    const retVal = Array.prototype[op].call(arr, ...args);
    arr.forEach((item, i4) => proxy._em(String(i4), item));
    if (proxy._p) {
      const [property, parent] = proxy._p;
      parent._em(property, proxy);
    }
    return retVal;
  };
  switch (op) {
    case "shift":
    case "pop":
    case "sort":
    case "reverse":
    case "copyWithin":
      return synthetic;
    case "unshift":
    case "push":
    case "fill":
      return (...args) => synthetic(...args.map((arg) => _state(arg)));
    case "splice":
      return (start, remove, ...inserts) => synthetic(start, remove, ...inserts.map((arg) => _state(arg)));
    default:
      return native;
  }
}
function reactiveMerge(reactiveTarget, reactiveSource) {
  const state2 = reactiveSource._st();
  if (state2.o) {
    state2.o.forEach((callbacks, property) => {
      callbacks.forEach((c3) => {
        reactiveTarget.$on(property, c3);
      });
    });
  }
  if (state2.p) {
    reactiveTarget._p = state2.p;
  }
  return reactiveTarget;
}
var asState = (data) => _state(data);
function ref(data, ...expr) {
  const empty = Symbol("empty");
  const merge = data.map((x5, i4) => [x5, expr[i4] ?? empty]).flat();
  const state2 = asState({
    val: ""
  });
  function update() {
    let list = "";
    for (const iterator of merge) {
      if (iterator === empty)
        continue;
      if (isRef(iterator))
        list += iterator.getValue();
      else
        list += iterator;
    }
    state2.val = list;
  }
  for (const iterator of merge) {
    if (isRef(iterator))
      iterator.listen(update);
  }
  update();
  return state2.$val;
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Component.ts
var Component = class extends EventTarget {
  constructor(wrapper = createElement("div")) {
    super();
    this.wrapper = wrapper;
  }
  addClass(val, ...classes) {
    asRef(val).listen((val2, oldVal) => {
      if (oldVal)
        this.wrapper.classList.remove(oldVal);
      this.wrapper.classList.add(val2);
    });
    this.wrapper.classList.add(...classes);
    return this;
  }
  setAnchorName(name) {
    if (name == void 0) {
      this.wrapper.removeAttribute("anchor");
      return this;
    }
    this.setAttribute("anchor", name);
    return this;
  }
  setAttribute(key, value = "") {
    asRef(value).listen((val) => {
      if (val === void 0) {
        this.wrapper.removeAttribute(key);
        return;
      }
      this.wrapper.setAttribute(key, val);
    });
    return this;
  }
  setPadding(size) {
    this.wrapper.style.padding = size;
    return this;
  }
  addPrefix(component) {
    this.wrapper.prepend(component.draw());
    return this;
  }
  addSuffix(component) {
    this.wrapper.append(component.draw());
    return this;
  }
  setWidth(size) {
    this.wrapper.style.width = size;
    return this;
  }
  setHeight(size) {
    this.wrapper.style.height = size;
    return this;
  }
  setMargin(size) {
    this.wrapper.style.margin = size;
    return this;
  }
  setId(id) {
    this.wrapper.id = id;
    return this;
  }
  setGrow(value = 1) {
    this.wrapper.style.flexGrow = value.toString();
    return this;
  }
  setAlignItems(type) {
    this.wrapper.style.alignItems = type;
    return this;
  }
  setAlignContent(type) {
    this.wrapper.style.alignContent = type;
    return this;
  }
  setAlignSelf(type) {
    this.wrapper.style.alignSelf = type;
    return this;
  }
  setJustifyItems(type) {
    this.wrapper.style.justifyItems = type;
    return this;
  }
  setJustifyContent(type) {
    this.wrapper.style.justifyContent = type;
    return this;
  }
  setJustifySelf(type) {
    this.wrapper.style.justifySelf = type;
    return this;
  }
  setBorderRadius(value) {
    const map = {
      "tiny": "0.3rem",
      "mid": "0.5rem",
      "large": "0.8rem",
      "complete": "100rem"
    };
    this.wrapper.style.borderRadius = map[value] ?? value;
    return this;
  }
  setTextSize(size) {
    this.addClass(`text-${size}`);
    return this;
  }
  setFontWeight(weight) {
    this.addClass(`font-${weight}`);
    return this;
  }
  setDirection(type) {
    this.wrapper.style.flexDirection = type;
    return this;
  }
  draw() {
    return this.wrapper;
  }
  onRightClick(func) {
    this.wrapper.addEventListener("contextmenu", (e) => func(e));
    return this;
  }
  onClick(func) {
    this.wrapper.addEventListener("click", func);
    return this;
  }
  removeFromLayout() {
    this.wrapper.style.display = "contents";
    return this;
  }
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Custom.ts
var CustomComponent = class extends Component {
  constructor(text) {
    super();
    this.wrapper = text;
  }
};
var Custom = (text) => new CustomComponent(text);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Body.ts
var Body = (component) => {
  const item = createElement("article");
  item.append(component.draw());
  document.body.append(item);
  return Custom(item);
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Button.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Accessibility.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var accessibilityDisableTabOnDisabled = (color = "grayscaled" /* Grayscaled */) => color === "disabled" /* Disabled */ ? -1 : 0;

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/types.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var ColoredComponent = class extends Component {
  color = asRef("grayscaled" /* Grayscaled */);
  constructor(wrapper = createElement("a")) {
    super(wrapper);
    this.color.listen((val) => {
      this.wrapper.tabIndex = accessibilityDisableTabOnDisabled(val);
    });
    this.addClass(this.color);
  }
  setColor(color) {
    asRef(color).listen((val) => this.color.setValue(val));
    return this;
  }
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/light-components/loadingWheel.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var loadingWheel = () => {
  const icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  icon.classList.add("loading-wheel");
  icon.setAttribute("viewBox", "0 0 73 73");
  icon.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  icon.setAttribute("fill", "none");
  icon.innerHTML = `<circle cx="36.5" cy="36.5" r="35.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;
  return icon;
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Button.ts
var speicalSyles = ["spinner" /* Spinner */, "progress" /* Progress */];
var enableTuple = (enabled, color = "grayscaled" /* Grayscaled */) => ["disabled" /* Disabled */, color][enabled ? "values" : "reverse"]();
var ButtonComponent = class extends ColoredComponent {
  prog = createElement("div");
  style = asRef("normal" /* Normal */);
  constructor(string, wrapper = createElement("button")) {
    super(wrapper);
    this.color.listen((val) => {
      this.wrapper.tabIndex = accessibilityDisableTabOnDisabled(val);
    });
    this.addClass(this.color);
    this.wrapper.classList.add("wbutton", "normal" /* Normal */);
    this.wrapper.tabIndex = speicalSyles.includes("normal" /* Normal */) ? -1 : accessibilityDisableTabOnDisabled();
    this.wrapper.append(loadingWheel());
    const element = createElement("div");
    this.wrapper.append(element);
    asRef(string).listen((val) => {
      element.replaceChildren(typeof val == "string" ? val : val.draw());
    });
    this.color.listen((color) => {
      this.wrapper.tabIndex = speicalSyles.includes(this.wrapper.classList[3]) ? -1 : accessibilityDisableTabOnDisabled(color);
    });
    this.addClass(this.style);
    this.addClass(this.style.map((it) => it == "spinner" /* Spinner */ ? "loading" : "non-loading"));
  }
  setEnabled = (enabled) => this.wrapper.classList.replace(...enableTuple(enabled));
  setStyle(style, progress) {
    asRef(style).listen((style2) => {
      this.wrapper.tabIndex = speicalSyles.includes(style2) ? -1 : accessibilityDisableTabOnDisabled();
      this.style.setValue(style2);
      if (progress !== void 0 && style2 === "progress" /* Progress */) {
        this.prog.classList.add("progress");
        asRef(progress).listen((progress2) => {
          this.prog.style.width = `${progress2.toString()}%`;
        });
        this.wrapper.append(this.prog);
      }
    });
    return this;
  }
  setAlignContent(type) {
    this.wrapper.style.alignContent = type;
    return this;
  }
  setJustifyContent(type) {
    this.wrapper.style.justifyContent = type;
    return this;
  }
  setGrow(value = 1) {
    this.wrapper.style.flexGrow = value.toString();
    return this;
  }
  onPromiseClick(func) {
    this.onClick(async (env, e) => {
      const styleBefore = this.style.getValue();
      this.setStyle("spinner" /* Spinner */);
      try {
        await func(env, e);
      } catch (error) {
        console.error(error);
      }
      this.setStyle(styleBefore);
    });
    return this;
  }
  onClick(func) {
    if (this.color.getValue() == "disabled" /* Disabled */)
      return this;
    this.wrapper.addEventListener("click", (e) => func(e, this));
    return this;
  }
};
var LinkButtonComponent = class extends ButtonComponent {
  constructor(title, url2, target) {
    super(title, createElement("a"));
    if (this.wrapper instanceof HTMLAnchorElement) {
      this.wrapper.href = url2;
      if (target)
        this.wrapper.target = target;
    }
  }
};
var Button = (string) => new ButtonComponent(string);
var LinkButton = (string, url2, target) => new LinkButtonComponent(string, url2, target);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Cache.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var GLOBAL_CACHE = /* @__PURE__ */ new Map();
function Cache(cacheId, loader, render) {
  if (!GLOBAL_CACHE.has(cacheId)) {
    const shell = createElement("div");
    shell.style.display = "contents";
    GLOBAL_CACHE.set(cacheId, {
      render: Custom(shell)
    });
    shell.append(render("cache", void 0).draw());
    loader?.().then((x5) => render("loaded", x5)).then((x5) => x5.draw()).then((x5) => shell.children[0].replaceWith(x5));
  }
  const data = GLOBAL_CACHE.get(cacheId);
  return Box(data.render);
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/Helper.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var dropNullish = (...components) => components.filter((x5) => x5);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/icons/MaterialIcons.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/lazyInit.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var lazyInit = (fn2) => {
  let prom = void 0;
  return () => prom = prom || fn2();
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/icons/MaterialIcons.ts
var iconSet = {
  outlined: lazyInit(() => Promise.resolve().then(() => __toESM(require_outlined()))),
  filled: lazyInit(() => Promise.resolve().then(() => __toESM(require_filled()))),
  round: lazyInit(() => Promise.resolve().then(() => __toESM(require_round()))),
  sharp: lazyInit(() => Promise.resolve().then(() => __toESM(require_sharp()))),
  "two-tone": lazyInit(() => Promise.resolve().then(() => __toESM(require_two_tone())))
};
var MaterialIconComponent = class extends Component {
  constructor(name, type) {
    super();
    asRef(name).listen((val) => this.wrapper.innerText = val);
    asRef(type).listen((val) => iconSet[val]());
    this.addClass(asRef(type).map((it) => it == "filled" ? "material-icons" : "material-icons-" + it), "wicon");
  }
};
var MaterialIcon = (name, type = "round") => new MaterialIconComponent(name, type);
var MIcon = MaterialIcon;

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Form.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Form = (ele) => new class extends Component {
  wrapper = createElement("form");
  constructor() {
    super();
    this.wrapper.append(ele.draw());
  }
  activeSubmitTo(selector) {
    const submit = createElement("input");
    submit.type = "submit";
    submit.hidden = true;
    submit.onclick = (e) => {
      e.preventDefault();
      if (!this.wrapper.reportValidity())
        return;
      this.wrapper.querySelector(selector)?.click();
    };
    this.wrapper.append(submit);
    return this;
  }
}();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/FormInputs.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Layer.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var LayerComponent = class extends Component {
  level = 0;
  tintlayer = createElement("div");
  constructor(child, level = 0, surface = "shadow") {
    super();
    this.wrapper.append(this.tintlayer, child.draw());
    this.wrapper.classList.add("wlayer", "wlayer" + level, surface);
    this.tintlayer.classList.add("wlayer-inner");
  }
  setBorderRadius(value) {
    super.setBorderRadius(value);
    Custom(this.tintlayer).setBorderRadius(value);
    return this;
  }
};
var Layer = (child, level = 0, surface = "shadow") => new LayerComponent(child, level, surface);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/List.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function List(list, keyFunc, renderFunc) {
  const container = Box().draw();
  list.listen((newValue = [], oldValue = []) => {
    const oldElements = oldValue.map((item) => keyFunc(item));
    const newElements = newValue.map((item) => keyFunc(item));
    newElements.filter((key) => !oldElements.includes(key)).forEach((key) => {
      const element = container.querySelector(`[data-key="${key}"]`);
      if (element)
        return;
      const component = renderFunc(newValue.find((item) => keyFunc(item) === key)).setAttribute("data-key", key).draw();
      component.style.viewTransitionName = `item-${key}`;
      container.append(component);
    });
    oldElements.filter((key) => !newElements.includes(key)).forEach((key) => {
      const element = container.querySelector(`[data-key="${key}"]`);
      element?.remove();
    });
    newElements.filter((key) => oldElements.includes(key)).forEach((key) => {
      const element = container.querySelector(`[data-key="${key}"]`);
      const index = newValue.findIndex((item) => keyFunc(item) === key);
      if (element && element.parentElement?.children[index] !== element)
        element.parentElement?.insertBefore(element, element.parentElement.children[index]);
    });
  });
  return Custom(container).removeFromLayout();
}
function Items(list, renderFunc) {
  return list.map((list2) => Box(...list2.map(renderFunc)).removeFromLayout()).asRefComponent();
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Popover.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Popover = (content2) => new class extends Component {
  constructor() {
    super();
    this.addClass("wpopover");
    this.wrapper.append(content2.draw());
    this.setAttribute("popover");
    document.body.append(this.draw());
  }
  showPopover() {
    try {
      this.wrapper.showPopover();
    } catch {
    }
    return this;
  }
  hidePopover() {
    try {
      this.wrapper.hidePopover();
    } catch {
      console.log("Failed to hide popover");
    }
    return this;
  }
  togglePopover(force) {
    this.wrapper.togglePopover(force);
    return this;
  }
  isOpen() {
    return this.wrapper.matches(":popover-open");
  }
  clearAnchors(anchorName) {
    const anchors = document.querySelectorAll(`[anchor="${anchorName}"]`);
    anchors.forEach((anchor) => anchor.removeAttribute("anchor"));
    return this;
  }
  pullingAnchorPositioning(anchorName, positioning, interval = 20) {
    setInterval(() => {
      const anchor = document.querySelector(`[anchor="${anchorName}"]`);
      if (!anchor)
        return;
      const rect = anchor.getBoundingClientRect();
      positioning(rect, this.wrapper.style);
    }, interval);
    return this;
  }
}();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Stacks.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var SpacerCompoent = class extends Component {
};
var AlignComponent = class extends Component {
  constructor(type, components) {
    super();
    this.wrapper.classList.add(type);
    this.wrapper.append(...dropNullish(...components).map((x5) => x5.draw()));
  }
  setMargin(margin) {
    this.wrapper.style.width = margin ? `calc(100% - ${margin} - ${margin})` : "";
    this.wrapper.style.margin = margin ?? "";
    return this;
  }
  setGap(gap = "var(--gap)") {
    this.wrapper.style.gap = gap;
    return this;
  }
};
var CenterV = (...list) => Vertical(Spacer(), ...list, Spacer());
var Spacer = () => new SpacerCompoent().addClass("spacer");
var Horizontal = (...components) => new AlignComponent("horizontal-stack", components.flat());
var Vertical = (...components) => new AlignComponent("vertical-stack", components.flat());
var GridComponent = class extends Component {
  constructor(components) {
    super();
    this.wrapper.classList.add("wggrid");
    this.wrapper.style.display = "grid";
    this.wrapper.append(...components.map((x5) => {
      if (Array.isArray(x5)) {
        const { width, height } = x5[0];
        const ele = x5[1].draw();
        if (width)
          ele.style.gridColumn = `${width} span`;
        if (height)
          ele.style.gridRow = `${height} span`;
        return ele;
      }
      return x5.draw();
    }));
  }
  setGap(gap = "var(--gap)") {
    this.wrapper.style.gap = gap;
    return this;
  }
  setRawColumns(template) {
    this.wrapper.style.gridTemplateColumns = template;
    return this;
  }
  setDynamicColumns(minSize = 6, max = "1fr") {
    this.wrapper.style.gridTemplateColumns = `repeat(auto-fit,minmax(${minSize}rem,${max}))`;
    return this;
  }
  setEvenColumns(count2, size = "1fr") {
    this.wrapper.style.gridTemplateColumns = `${size} `.repeat(count2);
    return this;
  }
  setAutoRow(row) {
    this.wrapper.style.gridAutoRows = row;
    return this;
  }
  setAutoColumn(column) {
    this.wrapper.style.gridAutoColumns = column;
    return this;
  }
  setDirection(type) {
    this.wrapper.style.gridAutoFlow = type;
    return this;
  }
};
var Grid = (...components) => new GridComponent(components);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/FormInputs.ts
var speicalSyles2 = ["spinner" /* Spinner */, "progress" /* Progress */];
var InputForm = class extends ColoredComponent {
  data = null;
  key = null;
  valueRender = (data) => `${data}` || JSON.stringify(data);
  setValue(value) {
    if (isRef(value))
      value.listen((val) => this.dispatchEvent(new CustomEvent("update", { detail: val })));
    else
      this.dispatchEvent(new CustomEvent("update", { detail: asRef(value).getValue() }));
    return this;
  }
  sync(data, key) {
    this.data = data;
    this.key = key;
    this.addEventListener("update", (event) => data[key] = event.detail);
    if (Object.hasOwn(data, key))
      this.setValue(data[key]);
    data.$on(key, (value) => this.setValue(value));
    return this;
  }
  setRender(action) {
    this.valueRender = action;
    this.dispatchEvent(new CustomEvent("data", {}));
    return this;
  }
  onChange(action) {
    this.addEventListener("update", (data) => action(data.detail));
    return this;
  }
};
var content = asRef(Box());
var dropDownPopover = Popover(Layer(
  content.asRefComponent(),
  5
).setBorderRadius("mid").addClass("wdropdown-outer-layer")).pullingAnchorPositioning("--wdropdown-default", (rect, style) => {
  style.top = `max(-5px, ${rect.bottom}px)`;
  style.left = `${rect.left}px`;
  style.minWidth = `${rect.width}px`;
  style.bottom = "var(--gap)";
});
var DropDownInputComponent = class extends InputForm {
  prog = createElement("div");
  text = createElement("span");
  button;
  constructor(dropdown, label, icon = MIcon("keyboard_arrow_down")) {
    super();
    const text = asRef(label);
    this.button = Button(text).setWidth("100%").setJustifyContent("space-between").addSuffix(icon);
    this.wrapper.innerHTML = "";
    this.color.setValue("disabled" /* Disabled */);
    this.wrapper.append(this.button.draw());
    this.wrapper.classList.add("wdropdown");
    this.addEventListener("update", (event) => {
      const data = event.detail;
      text.setValue(data == void 0 ? asRef(label).getValue() : this.valueRender(data));
      dropDownPopover.hidePopover();
    });
    this.button.onClick(() => {
      if (dropDownPopover.isOpen()) {
        dropDownPopover.hidePopover();
        return;
      }
      dropDownPopover.clearAnchors("--wdropdown-default");
      this.button.setAnchorName("--wdropdown-default");
      dropDownPopover.showPopover();
      content.setValue(
        Grid(
          Items(
            asRef(dropdown),
            (item) => Button(this.valueRender(item)).setStyle("inline" /* Inline */).onClick(() => {
              this.setValue(item);
            })
          )
        ).addClass("wdropdown-content").setDirection("row").setGap("5px").setPadding("5px")
      );
    });
  }
  setStyle(style, progress) {
    this.button.setStyle(style, progress);
    return this;
  }
};
var DropDownInput = (label, list) => new DropDownInputComponent(list, label);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/FormText.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Label.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Label = (title, type = "span") => new class extends Component {
  wrapper = createElement(type);
  constructor() {
    super();
    this.addClass("wlabel");
    if (isRef(title))
      title.listen((val) => this.wrapper.textContent = val);
    else
      this.wrapper.textContent = title;
  }
  setTextAlign(type2) {
    this.wrapper.style.textAlign = type2;
    return this;
  }
  setBalanced() {
    if ("textWrap" in this.wrapper.style)
      this.wrapper.style.textWrap = "balance";
    return this;
  }
  removeWrap() {
    this.wrapper.style.whiteSpace = "nowrap";
    return this;
  }
}();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/FormText.ts
var TextInputComponent = class extends InputForm {
  input = createElement("input");
  constructor(type, label, mode) {
    super();
    this.wrapper.classList.add("winput", "normal" /* Normal */);
    const placeholder2 = Label(label).draw();
    this.input.type = type;
    this.addEventListener("update", (event) => {
      const value = event.detail;
      if (value)
        this.wrapper.classList.add("has-value");
      this.input.value = value ?? "";
    });
    this.input.onfocus = () => {
      this.input.focus();
      this.wrapper.classList.add("has-value");
    };
    this.wrapper.onclick = () => {
      if (this.input.value === "") {
        this.wrapper.classList.add("has-value");
        this.input.focus();
      }
    };
    this.input.onblur = () => {
      if (this.input.value === "") {
        this.wrapper.classList.remove("has-value");
      }
    };
    if (mode == "live" || type == "date") {
      this.input.oninput = () => this.setValue(this.input.value);
    } else {
      this.input.onchange = () => {
        this.setValue(this.input.value);
      };
    }
    this.wrapper.append(placeholder2, this.input);
    this.color.map((it) => it == "disabled" /* Disabled */).listen((val) => this.input.disabled = val);
    this.wrapper.tabIndex = -1;
  }
  setStyle(_style) {
    return this;
  }
  required() {
    this.input.required = true;
    return this;
  }
  setAutofill(text) {
    this.input.autocomplete = text;
    return this;
  }
};
var TextInput = (type, label, mode = "live") => new TextInputComponent(type, label, mode);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/IconButton.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var IconButtonComponent = class extends ColoredComponent {
  constructor(icon, label) {
    super();
    this.wrapper.classList.add("wiconbutton");
    this.wrapper.append(
      icon.draw()
    );
    this.wrapper.ariaLabel = label;
  }
  asLinkButton(url2, target) {
    this.wrapper.href = url2;
    if (target)
      this.wrapper.target = target;
    return this;
  }
  setStyle(_style) {
    throw new Error("Method not implemented.");
  }
};
var IconButton = (icon, label) => new IconButtonComponent(icon, label);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Image.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var ImageComponent = class extends Component {
  alt;
  constructor(data, alt) {
    super();
    this.alt = alt;
    this.wrapper.classList.add("wimage");
    if (typeof data == "string") {
      this.wrapper.classList.add("loading");
      this.wrapper.append(this.renderLoading());
      this.wrapper.append(this.renderImage(data, true));
    } else if (data.type == "direct") {
      this.wrapper.classList.add("loading");
      this.wrapper.append(this.renderLoading());
      data.source().then((x5) => {
        this.wrapper.classList.remove("loading");
        this.wrapper.children[0].replaceWith(this.renderImage(URL.createObjectURL(x5), true));
      });
    } else if (data.type == "loading") {
      this.wrapper.classList.add("loading");
      this.wrapper.append(this.renderLoading());
    } else if (data.type == "uploading") {
      const background = this.renderImage(data.blobUrl);
      background.classList.add("background");
      const progress = Box(Custom(this.renderImage(data.blobUrl))).draw();
      progress.classList.add("progress");
      progress.style.height = `${data.percentage.toFixed(1)}%`;
      const overlay = Vertical(
        Spacer(),
        Label(data.text ?? "Uploading...").addClass("small"),
        Spacer(),
        Label(`${data.percentage.toFixed(1)}%`).addClass("big"),
        Spacer(),
        Label(data.filename).addClass("small"),
        Spacer()
      ).addClass("overlay").draw();
      const darkLayer = Box().addClass("dark-layer").draw();
      this.wrapper.append(background, progress, darkLayer, overlay);
    } else if (data.type == "waiting-upload") {
      const background = this.renderImage(data.blobUrl);
      background.classList.add("background");
      const progress = Box(Custom(this.renderImage(data.blobUrl))).draw();
      progress.classList.add("progress");
      progress.style.height = `100%`;
      const overlay = Vertical(
        Spacer(),
        Label(" ").addClass("small"),
        Spacer(),
        Label(data.text ?? "Finishing Upload...").addClass("mid"),
        Spacer(),
        Label(data.filename).addClass("small"),
        Spacer()
      ).addClass("overlay").draw();
      const darkLayer = Box().addClass("dark-layer").draw();
      this.wrapper.append(background, progress, darkLayer, overlay);
    }
  }
  renderLoading() {
    return loadingWheel();
  }
  renderImage(source, removeLoading = false) {
    const img = createElement("img");
    img.style.width = "100%";
    img.src = source;
    img.alt = this.alt;
    if (removeLoading)
      img.onload = () => {
        this.wrapper.classList.remove("loading");
        this.wrapper.querySelector(".loading-wheel")?.remove();
      };
    return img;
  }
  resizeToBox() {
    this.addClass("resize-to-box");
    return this;
  }
  setAspectRatio(ratio) {
    this.wrapper.style.aspectRatio = ratio;
    return this;
  }
};
var Image = (data, alt) => new ImageComponent(data, alt);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/MediaQuery.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function MediaQuery(query, view) {
  const holder = createElement("div");
  holder.innerHTML = "";
  holder.style.display = "contents";
  holder.append(view(matchMedia(query).matches).draw());
  matchMedia(query).addEventListener("change", ({ matches }) => {
    holder.innerHTML = "";
    holder.append(view(matches).draw());
  }, { passive: true });
  return Custom(holder);
}
function mediaQueryRef(matchString) {
  const query = matchMedia(matchString);
  const pointer = asRef(query.matches);
  query.addEventListener("change", ({ matches }) => pointer.setValue(matches), { passive: true });
  return pointer;
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Sheet.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/mobileQuery.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var isMobile = mediaQueryRef("(max-width: 750px)");

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Sheet.ts
var SheetComponent = class extends Component {
  constructor(offset, kind) {
    super();
    this.offset = offset;
    this.kind = kind;
    this.addClass("wsheet");
    this.wrapper.append(kind.draw());
  }
  onClose = asRef(() => {
  });
  canClose = asRef(true);
  setWidth(size) {
    this.wrapper.style.setProperty("--sheet-desktop-width", size);
    return this;
  }
  setHeight(size) {
    this.wrapper.style.setProperty("--sheet-desktop-height", size);
    return this;
  }
  setOnClose(onClose) {
    this.onClose.setValue(onClose);
    return this;
  }
  setCanClose(canClose) {
    canClose.listen((it) => this.canClose.setValue(it));
    return this;
  }
};
var SheetsStackComponent = class extends Component {
  constructor(mobileTrigger) {
    super();
    this.mobileTrigger = mobileTrigger;
    this.onClick(() => {
      const sheet = this.sheets.getValue().at(-1);
      if (!sheet.canClose.getValue())
        return;
      sheet.onClose.getValue()();
      this.remove(sheet);
    });
    this.addClass("wstacking-sheets");
    this.addClass(mobileTrigger.map((it) => it ? "mobile-variant" : "desktop-variant"));
  }
  sheets = asRef([]);
  add(sheet) {
    this.sheets.addItem(sheet);
    const index = this.sheets.getValue().length - 1;
    const element = sheet.draw();
    element.style.zIndex = `${index + 10}`;
    const sheetVisible = this.sheets.map((it) => it.includes(sheet));
    const sheetOnTop = this.sheets.map((it) => it.at(-1) === sheet);
    sheet.addClass(sheetVisible.map((it) => it ? "shown" : "hidden"));
    sheet.addClass(sheetOnTop.map((it) => it ? "on-top" : "not-on-top"));
    sheet.addClass(this.sheets.map((sheets) => sheets.length - 1 > 0 ? "background" : "no-background"));
    this.mobileTrigger.map((mobile) => {
      element.style.setProperty("--sheet-index", `${index > 0 && !mobile ? index - 1 : index}`);
    });
    sheet.onClick((ev) => {
      ev.stopPropagation();
    });
    this.sheets.map((it) => it.length).listen((it) => {
      if (it && it > 0) {
        element.style.setProperty("--sheet-reverse-index", `${it - index - 1}`);
      } else
        element.style.setProperty("--sheet-reverse-index", `0`);
    });
    this.wrapper.append(element);
    return this;
  }
  setDefault(component) {
    this.add(new SheetComponent(asRef(0), component));
  }
  async remove(sheet) {
    const index = this.sheets.getValue().indexOf(sheet);
    const animationEnded = Promise.withResolvers();
    this.wrapper.children[index].addEventListener("animationend", () => animationEnded.resolve());
    this.sheets.setValue(this.sheets.getValue().filter((it) => it !== sheet));
    await animationEnded.promise;
    this.wrapper.children[index].remove();
    return this;
  }
  setSheetWidth(size) {
    this.wrapper.style.setProperty("--sheet-desktop-width", size);
    return this;
  }
  setSheetHeight(size) {
    this.wrapper.style.setProperty("--sheet-desktop-height", size);
    return this;
  }
};
var SheetsStack = (mobileTrigger = isMobile) => new SheetsStackComponent(mobileTrigger);
var Sheet = (content2) => new SheetComponent(asRef(0), content2);

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/SheetDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function SheetDialog(sheetRegistry, title, ...content2) {
  const isOpen = asRef(false);
  const sheet = Sheet(
    Grid(
      Grid(
        Label(title).addClass("wsheet-title").setTextSize("3xl").setFontWeight("bold")
      ).setAlignItems("end").setHeight("80px"),
      ...content2
    ).setGap().setMargin("15px").setAlignContent("start")
  );
  isOpen.listen((open, oldValue) => {
    if (open)
      sheetRegistry.add(sheet);
    else if (oldValue)
      sheetRegistry.remove(sheet);
  });
  sheet.setOnClose(() => {
    isOpen.setValue(false);
  });
  return {
    open: () => isOpen.setValue(true),
    close: () => isOpen.setValue(false),
    setId: (id) => sheet.setId(id),
    setOnClose: (onClose) => isOpen.listen(onClose),
    setCanClose: (pointer) => sheet.setCanClose(pointer)
  };
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Taglist.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Taglist = (list, selected, icon = { forward: MIcon("arrow_back_ios_new"), backwards: MIcon("arrow_forward_ios") }) => new class extends Component {
  items = createElement("div");
  move = createElement("div");
  constructor() {
    super();
    const state2 = asState({
      left: false,
      right: false
    });
    this.wrapper.classList.add("wtags");
    this.items.classList.add("items");
    this.move.classList.add("move");
    this.wrapper.append(this.items, this.move);
    this.items.append(...list.map(
      (x5, i4) => Button(x5).setColor("colored" /* Colored */).onClick(() => selected.setValue(i4)).setStyle(selected.map((index) => index == i4 ? "normal" /* Normal */ : "secondary" /* Secondary */)).draw()
    ));
    this.move.append(
      IconButton(icon.forward, "go backwards in tag list").onClick(() => this.items.scrollBy({
        left: 0 - this.wrapper.clientWidth / 2,
        behavior: "smooth"
      })).addClass(state2.$left.map((val) => val ? "show" : "hidden")).draw(),
      IconButton(icon.backwards, "go forward in tag list").addClass(state2.$right.map((val) => val ? "show" : "hidden")).onClick(() => this.items.scrollBy({
        left: this.wrapper.clientWidth / 2,
        behavior: "smooth"
      })).draw()
    );
    this.items.addEventListener("scroll", () => {
      if (this.items.scrollLeft == 0)
        state2.left = false;
      else
        state2.left = true;
      if (this.items.scrollWidth - this.items.clientWidth - this.items.scrollLeft == 0)
        state2.right = false;
      else
        state2.right = true;
    }, { passive: true });
    new ResizeObserver(() => {
      state2.right = this.items.scrollWidth !== this.items.offsetWidth;
    }).observe(this.wrapper);
    setTimeout(() => {
      state2.right = this.items.scrollWidth !== this.items.offsetWidth;
    }, 1e3);
  }
}();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/icons/BootstrapIcons.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var BootstrapIconComponent = class extends Component {
  constructor(name) {
    super();
    this.addClass(asRef(name).map((it) => `bi-${it}`), "bi", "wicon");
  }
};
var BootstrapIcon = (name) => new BootstrapIconComponent(name);
var BIcon = BootstrapIcon;

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/KeyValue.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
async function createKeyValue(collectionName) {
  const db = await new Promise((resolve, reject2) => {
    const request = indexedDB.open("webgen-keyval");
    request.onerror = () => {
      reject2(new Error("Failed to open IndexedDB"));
    };
    request.onsuccess = () => {
      resolve(request.result);
    };
    request.onupgradeneeded = function() {
      request.result.createObjectStore(collectionName);
    };
  });
  const set = (key, value) => {
    return new Promise((resolve, reject2) => {
      const transaction = db.transaction([collectionName], "readwrite");
      const store = transaction.objectStore(collectionName);
      transaction.onerror = () => {
        reject2(new Error("Error in IndexedDB transaction"));
      };
      transaction.oncomplete = () => {
        resolve();
      };
      store.put(value, key);
    });
  };
  const get = (key) => {
    return new Promise((resolve, reject2) => {
      const transaction = db.transaction([collectionName], "readonly");
      const store = transaction.objectStore(collectionName);
      const request = store.get(key);
      request.onerror = () => {
        reject2(new Error("Error retrieving value from IndexedDB"));
      };
      request.onsuccess = () => {
        resolve(request.result);
      };
    });
  };
  const has = (key) => {
    return new Promise((resolve, reject2) => {
      const transaction = db.transaction([collectionName], "readonly");
      const store = transaction.objectStore(collectionName);
      const request = store.get(key);
      request.onerror = () => {
        reject2(new Error("Error retrieving value from IndexedDB"));
      };
      request.onsuccess = () => {
        resolve(request.result !== void 0);
      };
    });
  };
  const clear = () => {
    return new Promise((resolve, reject2) => {
      const transaction = db.transaction([collectionName], "readwrite");
      const store = transaction.objectStore(collectionName);
      const request = store.clear();
      request.onerror = () => {
        reject2(new Error("Error clearing IndexedDB store"));
      };
      request.onsuccess = () => {
        resolve();
      };
    });
  };
  const remove = (key) => {
    return new Promise((resolve, reject2) => {
      const transaction = db.transaction([collectionName], "readwrite");
      const store = transaction.objectStore(collectionName);
      const request = store.delete(key);
      request.onerror = () => {
        reject2(new Error("Error deleting key from IndexedDB"));
      };
      request.onsuccess = () => {
        resolve();
      };
    });
  };
  return {
    set,
    get,
    has,
    clear,
    remove
  };
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/collections/sort_by.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function sortBy(array, selector, options) {
  const len = array.length;
  const indexes = new Array(len);
  const selectors = new Array(len);
  const order = options?.order ?? "asc";
  array.forEach((item, idx) => {
    indexes[idx] = idx;
    const s2 = selector(item);
    selectors[idx] = Number.isNaN(s2) ? null : s2;
  });
  indexes.sort((ai2, bi2) => {
    let a2 = selectors[ai2];
    let b5 = selectors[bi2];
    if (order === "desc") {
      [a2, b5] = [b5, a2];
    }
    if (a2 === null)
      return 1;
    if (b5 === null)
      return -1;
    return a2 > b5 ? 1 : a2 < b5 ? -1 : 0;
  });
  for (let i4 = 0; i4 < len; i4++) {
    indexes[i4] = array[indexes[i4]];
  }
  return indexes;
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/components/Entry.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Entry = (content2) => new EntryComponent(content2);
var BasicLabel = (content2) => EntryComponent.basicContent(content2);
var EntryComponent = class extends Component {
  prefix = createElement("div");
  suffix = createElement("div");
  state = asState({
    isLoading: false
  });
  constructor(content2) {
    super();
    this.wrapper = Layer(
      content2 instanceof Component ? content2 : BasicLabel(content2),
      2,
      "shadow"
    ).addClass("wentry").setBorderRadius("large").draw();
    this.wrapper.setAttribute("aria-role", "button");
    this.prefix.classList.add("prefix");
    this.wrapper.prepend(this.prefix);
    this.suffix.classList.add("suffix");
    this.wrapper.append(this.suffix);
  }
  static basicContent(content2) {
    return Grid(
      ...content2.subtitle ? [
        Label(content2.title).addClass("title"),
        Label(content2.subtitle).addClass("subtitle")
      ] : [
        Label(content2.title).addClass("title")
      ]
    ).addClass("basic-text");
  }
  addSuffix(component) {
    this.suffix.append(component.draw());
    return this;
  }
  addPrefix(component) {
    this.prefix.append(component.draw());
    this.prefix.style.marginRight = "var(--gap)";
    return this;
  }
  onClick(func, icon = MIcon("arrow_forward_ios")) {
    this.onPromiseClick(async (e) => {
      await func(e);
    }, icon);
    return this;
  }
  onPromiseClick(func, icon = MIcon("arrow_forward_ios")) {
    this.wrapper.classList.add("action");
    const item = CenterV(icon).draw();
    const actionIcon = this.state.$isLoading.map(
      () => this.state.isLoading ? Box(Custom(loadingWheel())).addClass("loading") : Custom(item)
    ).asRefComponent().addClass("action-item");
    this.suffix.append(actionIcon.draw());
    this.wrapper.onclick = (ev) => {
      this.state.isLoading = true;
      func(ev).then(() => {
        this.state.isLoading = false;
      });
    };
    return this;
  }
};

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/src/webgen.ts
var WebGen = (options = {}) => {
  console.log("Loaded @lucsoft/webgen");
  const theme = new Style(options);
  if (options.updateThemeOnInit ?? true)
    theme.updateTheme(options.theme ?? 4 /* auto */);
  return {
    theme
  };
};

// pages/shared/components.ts
var LoadingSpinner = () => Box(Custom(loadingWheel())).addClass("loading");
var lazyChart = lazyInit(() => Promise.resolve().then(() => (init_auto2(), auto_exports)));

// pages/hosting/main.ts
init_restSpec();

// components/nav.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/Progress.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function Progress(progress) {
  return Box(
    Custom((() => {
      if (progress == -1)
        return Label("\u26A0\uFE0F Failed to upload!").addClass("error-message").setTextSize("sm").draw();
      const element = createElement("progress");
      if (isRef(progress)) {
        progress.listen((value) => element.value = value);
        element.max = 100;
      } else {
        element.value = progress;
        element.max = 110;
      }
      return element;
    })()).addClass("low-level")
  );
}

// pages/shared/cache.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var fileCache = lazyInit(() => createKeyValue("file-cache"));

// pages/shared/list.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
init_restSpec();
var HeavyList = (items, map) => new class extends Component {
  placeholder = Box();
  loadMore = async (_offset, _limit) => {
  };
  paging = asState({ enabled: false, limit: 30 });
  constructor() {
    super();
    console.debug("HeavyList got constructed");
    const list = asRef(items);
    list.listen((val) => {
      this.wrapper.textContent = "";
      if (val === "loading") {
        this.wrapper.append(
          LoadingSpinner().draw()
        );
      } else if ("status" in val) {
        if (val.status === "fulfilled") {
          this.wrapper.append(
            this.paging.$enabled.map(
              () => this.canLoadMore(val.value.length) ? Vertical(
                ...val.value.length == 0 ? [this.placeholder] : val.value.map((x5) => map(x5)).filter((_5, index) => index % this.paging.limit !== 1),
                Horizontal(
                  Button("Load More").onPromiseClick(() => this.loadMore(val.value.length, this.paging.limit))
                ).setMargin("0 0 var(--gap)")
              ).setGap() : Vertical(
                ...val.value.length == 0 ? [this.placeholder] : val.value.map((x5) => map(x5))
              ).setGap()
            ).asRefComponent().draw()
          );
        } else {
          this.wrapper.append(
            Horizontal(
              Vertical(
                MIcon("error"),
                Label(displayError(val.reason))
              ).setAlignItems("center").setGap("calc(var(--gap) * 0.25)").addClass("error-message")
            ).draw()
          );
        }
      } else {
        this.wrapper.append(
          Vertical(
            ...val.length == 0 ? [this.placeholder] : val.map((x5) => map(x5)),
            this.paging.$enabled.map(() => this.paging.enabled ? Button("Load More").setMargin("0 0 var(--gap)").onPromiseClick(() => this.loadMore(val.length - 2, this.paging.limit + 1)) : Empty()).asRefComponent().removeFromLayout()
          ).setGap().draw()
        );
      }
    });
  }
  canLoadMore(length) {
    return this.paging.enabled && length % this.paging.limit == 1;
  }
  enablePaging(loadMore, limit = 30) {
    this.paging.enabled = true;
    this.paging.limit = limit;
    this.loadMore = loadMore;
    return this;
  }
  setPlaceholder(val) {
    this.placeholder = val;
    return this;
  }
}();
var placeholder = (title, subtitle) => CenterV(
  Label(title).setTextSize("4xl").setFontWeight("bold").addClass("list-title"),
  Label(subtitle).setTextSize("xl")
).setMargin("100px 0 0").setGap("1rem").setAttribute("align", "center");

// pages/shared/listCount.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var count = (list) => list.map((val) => {
  if (val === void 0 || val === "loading")
    return "";
  if ("status" in val) {
    return val.status === "fulfilled" ? `(${val.value.length})` : "";
  }
  return `(${val.length})`;
});

// pages/shared/navigation.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/assert/assert.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/assert/assertion_error.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var AssertionError = class extends Error {
  /** Constructs a new instance. */
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};

// esbuild_serve:http-import:https://deno.land/std@0.221.0/assert/assert.ts
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}

// pages/shared/navigation.ts
function traverseToMenuNode(rootNode, path2) {
  const pathSegments = path2.split("/").filter(Boolean);
  let currentNode = rootNode;
  for (const segment of pathSegments) {
    if (currentNode?.children) {
      const childNode = asRef(currentNode.children).getValue().find(
        (child) => !(child instanceof Component) && child.id === segment
      );
      if (childNode) {
        currentNode = childNode;
        continue;
      }
    }
    return null;
  }
  return currentNode || null;
}
function resolvePathToNodes(rootNode, path2) {
  const nodes = [];
  const pathSegments = path2.split("/").filter(Boolean);
  let currentNode = rootNode;
  for (const segment of pathSegments) {
    if (currentNode?.children) {
      const childNode = asRef(currentNode.children).getValue().find(
        (child) => !(child instanceof Component) && child.id === segment
      );
      if (childNode) {
        currentNode = childNode;
        nodes.push(currentNode);
        continue;
      }
    }
    assert(segment, `Missing path segment ${segment} for ${path2}`);
  }
  return nodes;
}
function getMenuNodeByPrefix(rootNode, rootId) {
  if (rootId == "-")
    return rootNode;
  assert(rootNode.categories);
  const categoryNode = rootNode.categories.find((category) => category.id === rootId);
  assert(categoryNode, "category not found");
  return categoryNode;
}
var MenuImpl = class extends Component {
  rootNode;
  path;
  displayed = asRef([]);
  #header = asRef(defaultHeader);
  #footer = asRef(defaultFooter);
  constructor(rootNode) {
    super();
    this.rootNode = rootNode;
    this.path = asRef(rootNode.categories?.at(0) ? `${rootNode.categories.at(0).id}/` : "-/");
    this.wrapper.append(
      Vertical(
        this.#header.map((it) => it(this)).asRefComponent().removeFromLayout(),
        HeavyList(this.displayed, (item) => {
          if (item instanceof Component) {
            return item;
          }
          if (asRef(item.hidden ?? false).getValue()) {
            return Empty();
          }
          const entry = Entry(item.replacement ? asRef(item.replacement).getValue() : item).addClass(isMobile.map((mobile) => mobile ? "small" : "desktop"));
          const click = this.createClickHandler(item);
          if (item.suffix) {
            entry.addSuffix(asRef(item.suffix).getValue());
          }
          if (click) {
            entry.onPromiseClick(async () => await click());
          }
          return entry;
        }),
        this.#footer.map((it) => it(this)).asRefComponent().removeFromLayout()
      ).setGap().draw()
    );
    this.path.listen((val) => {
      const [rootId] = val.split("/");
      const unprefixed = val.replace(rootId, "");
      const root = getMenuNodeByPrefix(rootNode, rootId);
      assert(root);
      const item = traverseToMenuNode(root, unprefixed);
      assert(item, "No Node found");
      if (isRef(item.children)) {
        item.children.listen((items) => {
          if (val == this.path.getValue()) {
            this.displayed.setValue(items);
          }
        });
      } else {
        this.displayed.setValue(item.children ?? []);
      }
    });
  }
  createClickHandler(menu) {
    if (menu.clickHandler) {
      return async () => {
        await menu.clickHandler?.(`${this.path.getValue() + menu.id}/`, menu);
        if (menu.children) {
          this.path.setValue(`${this.path.getValue() + menu.id}/`);
        }
      };
    }
    if (menu.children) {
      return () => {
        this.path.setValue(`${this.path.getValue() + menu.id}/`);
      };
    }
    return void 0;
  }
  setHeader(header) {
    this.#header.setValue(header);
    return this;
  }
  setFooter(footer) {
    this.#footer.setValue(footer);
  }
};
var Navigation = (rootNode) => new MenuImpl(rootNode);
function defaultHeader(menu) {
  return isMobile.map((mobile) => {
    const list = Vertical(
      createBreadcrumb(menu),
      createTagList(menu)
    ).setGap();
    if (!mobile) {
      return Grid(
        list,
        createActionList(menu)
      ).setRawColumns("auto max-content").setGap().setAlignItems("center");
    }
    return list;
  }).asRefComponent();
}
function defaultFooter(menu) {
  return isMobile.map((mobile) => mobile && menu.rootNode.actions ? Box(createActionList(menu)).addClass(asRef(menu.rootNode.actions).map((it) => it.length == 0 ? "remove-from-layout" : "normal"), "sticky-footer") : Empty()).asRefComponent().removeFromLayout();
}
function createActionList(menu) {
  return asRef(menu.rootNode.actions ?? []).map((it) => Grid(...it).addClass("action-list-bar")).asRefComponent().removeFromLayout();
}
function createTagList(menu) {
  if (!menu.rootNode.categories)
    return Empty();
  const index = asRef(0);
  index.listen((val, oldVal) => {
    if (oldVal != void 0) {
      const path2 = menu.rootNode.categories[val];
      if (path2) {
        menu.path.setValue(`${path2.id}/`);
      }
    }
  });
  menu.path.listen((path2) => {
    index.setValue(menu.rootNode.categories.findIndex((it) => it.id == path2.split("/").at(0)));
  });
  return menu.path.map((path2) => {
    const [rootId] = path2.split("/");
    const unprefixed = path2.replace(rootId, "");
    const visible = unprefixed == "/";
    return visible && menu.rootNode.categories ? Taglist(menu.rootNode.categories.map((it) => it.title), index) : Empty();
  }).asRefComponent();
}
function createBreadcrumb(menu) {
  return isMobile.map((mobile) => {
    const history2 = menu.path.map((path2) => {
      const [rootId] = path2.split("/");
      const unprefixed = path2.replace(rootId, "");
      const root = getMenuNodeByPrefix(menu.rootNode, rootId);
      const items = resolvePathToNodes(root, unprefixed) ?? [];
      return [root, ...items];
    });
    function moveToPath(index) {
      menu.path.setValue(`${history2.getValue().filter((_5, i4) => index >= i4).map((it) => it.id ?? "-").join("/")}/`);
    }
    if (mobile) {
      return history2.map((it) => {
        const last = it.at(-2);
        if (!last) {
          return Label(parseTitle(menu.rootNode, it.at(-1), it.length - 1)).addClass("label");
        }
        return Box(
          // TODO: Make this a bit smaller
          Grid(
            MIcon("arrow_back_ios_new"),
            Label(parseTitle(menu.rootNode, last, it.indexOf(last) + 1)).addClass("label")
          ).addClass("history-entry", "mobile").onClick(() => moveToPath(it.indexOf(last))),
          Label(parseTitle(menu.rootNode, it.at(-1), it.length - 1)).addClass("label")
        );
      }).asRefComponent().addClass("history-list").removeFromLayout();
    }
    return history2.map(
      (it) => Grid(
        ...it.map(
          (entry, index) => Box(
            Label(entry.title).setFontWeight("bold").addClass("label"),
            MIcon("arrow_forward_ios")
          ).addClass("history-entry").onClick(() => moveToPath(index))
        ).filter((_5, i4) => i4 != it.length - 1),
        Label(parseTitle(menu.rootNode, it.at(-1), it.length - 1)).addClass("label").setFontWeight("bold")
      ).addClass("history-list")
    ).asRefComponent().removeFromLayout();
  }).asRefComponent().removeFromLayout();
}
function parseTitle(rootNode, node, index) {
  if (index === 0 && node.displayTextInHeader != "same")
    return rootNode.title;
  return node.title;
}

// pages/shared/mod.ts
init_restSpec();

// pages/shared/slider.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var SliderInput = (label) => new class extends InputForm {
  input = createElement("input");
  valueRender = (value) => `${(value / Number(this.input.max || "100") * 100).toFixed(0)} %`;
  constructor() {
    super();
    const val = asState({ value: "" });
    this.input.type = "range";
    this.input.classList.add("wslider");
    this.wrapper.append(
      Vertical(
        Grid(
          Label(label).setTextSize("sm").setFontWeight("bold").removeWrap(),
          Spacer(),
          val.$value.map((val2) => Label(val2).setTextSize("sm").setFontWeight("bold")).asRefComponent().addClass("same-height")
        ).setRawColumns("max-content auto max-content").setPadding("0 0.2rem"),
        Custom(this.input)
      ).setMargin("0 -0.1rem").draw()
    );
    this.addEventListener("update", (event) => {
      const value = event.detail;
      if (value) {
        this.wrapper.classList.add("has-value");
      }
      this.input.value = (value ?? 0).toString();
    });
    this.input.oninput = () => {
      val.value = this.valueRender(this.input.valueAsNumber);
    };
    this.input.onchange = () => {
      val.value = this.valueRender(this.input.valueAsNumber);
      this.setValue(this.input.valueAsNumber);
    };
    this.addEventListener("data", () => {
      val.value = this.valueRender(this.input.valueAsNumber);
    });
    this.dispatchEvent(new CustomEvent("data", {}));
  }
  setMax(val) {
    this.input.max = val.toString();
    return this;
  }
  setStep(val) {
    this.input.step = val.toString();
    return this;
  }
  setMin(val) {
    this.input.min = val.toString();
    return this;
  }
  setStyle(_style) {
    throw new Error("Method not implemented.");
  }
  setColor(_color) {
    throw new Error("Method not implemented.");
  }
}();

// pages/shared/table2.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Table2 = class extends Component {
  columns = asRef([]);
  hoveredRow = asRef(void 0);
  rowClick = asRef(void 0);
  rowClickable = asRef(void 0);
  constructor(dataSource) {
    super();
    this.wrapper.append(
      this.columns.map(
        (columns) => Box(
          ...columns.map(
            (column, columnIndex) => Box(
              this.header(column),
              dataSource.map(
                (rows) => Box(
                  ...rows.map((row, rowIndex) => {
                    const clickEnabled = this.rowClick.map((it) => !!it && (this.rowClickable.getValue()?.(rowIndex) ?? true));
                    const hovering = refMerge({
                      clickEnabled,
                      hoveredRow: this.hoveredRow
                    });
                    const item = Box(column.converter(row)).addClass(rowIndex % 2 == 0 ? "even" : "odd", "item", columnIndex == 0 ? "left" : columnIndex == columns.length - 1 ? "right" : "middle").addClass(hovering.map(({ clickEnabled: clickEnabled2, hoveredRow }) => clickEnabled2 && hoveredRow === rowIndex ? "hover" : "non-hover")).draw();
                    item.addEventListener("pointerenter", () => this.hoveredRow.setValue(rowIndex));
                    item.addEventListener("pointerleave", () => this.hoveredRow.setValue(void 0));
                    item.onclick = () => {
                      if (clickEnabled.getValue()) {
                        this.rowClick.getValue()?.(rowIndex, columnIndex);
                      }
                    };
                    return Custom(item);
                  })
                ).removeFromLayout()
              ).asRefComponent().removeFromLayout()
            ).addClass("column")
          )
        ).addClass("wgtable")
      ).asRefComponent().draw()
    );
  }
  setColumnTemplate(layout) {
    asRef(layout).listen((value) => {
      this.wrapper.style.setProperty("--wgtable-column-template", value);
    });
    return this;
  }
  addColumn(title, converter, sorting) {
    this.columns.setValue([
      ...this.columns.getValue(),
      {
        converter,
        title: asRef(title ?? ""),
        sorting: asRef(sorting)
      }
    ]);
    return this;
  }
  setRowClickEnabled(clickableHandler) {
    asRef(clickableHandler).listen((value) => this.rowClickable.setValue(value));
    return this;
  }
  setRowClick(clickHandler) {
    asRef(clickHandler).listen((value) => this.rowClick.setValue(value));
    return this;
  }
  header(column) {
    return Box(
      Label(column.title)
    ).addClass("header");
  }
};

// pages/shared/upload.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function ProgressTracker(percentage, expectedSize) {
  let bytesUploaded = 0;
  return new TransformStream({
    transform(chunk, controller) {
      bytesUploaded += chunk.length;
      percentage.setValue(bytesUploaded / expectedSize * 100);
      controller.enqueue(chunk);
    }
  });
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/delay.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function delay(ms2, options = {}) {
  const { signal, persistent } = options;
  if (signal?.aborted)
    return Promise.reject(signal.reason);
  return new Promise((resolve, reject2) => {
    const abort = () => {
      clearTimeout(i4);
      reject2(signal?.reason);
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve();
    };
    const i4 = setTimeout(done, ms2);
    signal?.addEventListener("abort", abort, { once: true });
    if (persistent === false) {
      try {
        Deno.unrefTimer(i4);
      } catch (error) {
        if (!(error instanceof ReferenceError)) {
          throw error;
        }
        console.error("`persistent` option is only available in Deno");
      }
    }
  });
}

// pages/_legacy/helper.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// assets/imports.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// assets/img/template-artwork.png
var template_artwork_default = "./template-artwork-57BXUF2S.png";

// components/pages.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// assets/img/bbnHolding.svg
var bbnHolding_default = "./bbnHolding-Z7WOZPKW.svg";

// assets/img/bbnMusic.svg
var bbnMusic_default = "./bbnMusic-DRY3HEUI.svg";

// assets/img/bbnHosting.svg
var bbnHosting_default = "./bbnHosting-MFNJZPY7.svg";

// assets/img/bbnAdmin.svg
var bbnAdmin_default = "./bbnAdmin-WUYEKLQ5.svg";

// assets/img/bbnWallet.svg
var bbnWallet_default = "./bbnWallet-UEEJRE73.svg";

// components/pages.ts
var pages = [
  [bbnHolding_default, [], "/", 0],
  [bbnMusic_default, [], "/c/music", 1],
  [bbnMusic_default, [], "/music", 2],
  [bbnHosting_default, [], "/hosting", 0],
  [bbnWallet_default, [], "/wallet", 1],
  [bbnAdmin_default, ["/bbn/manage", "/hmsys/user"], "/admin", 1]
];
var loginRequired = [
  "/c/music",
  "/hosting",
  "/admin",
  "/oauth",
  "/wallet"
];
function activeTitle(type) {
  if (type == "Music") {
    return "KSPC Music";
  }
  if (type == "Hosting") {
    return "KSPC Hosting";
  }
  if (type == "Wallet") {
    return "KSPC Wallet";
  }
  if (type == "Admin") {
    return "KSPC Admin";
  }
  return "KSPC Holding";
}

// spec/music.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/collections/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/collections/sum_of.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function sumOf(array, selector) {
  let sum = 0;
  for (const i4 of array) {
    sum += selector(i4);
  }
  return sum;
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/collections/sort_by.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/zod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/index.ts
var zod_v3_22_exports = {};
__export(zod_v3_22_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  default: () => zod_v3_22_default,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType,
  z: () => external_exports
});
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/external.ts
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/errors.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/locales/en.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/helpers/util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var util;
((util2) => {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = (0, util2.objectKeys)(obj).filter(
      (k4) => typeof obj[obj[k4]] !== "number"
    );
    const filtered = {};
    for (const k4 of validKeys) {
      filtered[k4] = obj[k4];
    }
    return (0, util2.objectValues)(filtered);
  };
  util2.objectValues = (obj) => {
    return (0, util2.objectKeys)(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_5, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
((objectUtil3) => {
  objectUtil3.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/ZodError.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  issues = [];
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i4 = 0;
          while (i4 < issue.path.length) {
            const el2 = issue.path[i4];
            const terminal = i4 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i4++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static create = (issues) => {
    const error = new _ZodError(issues);
    return error;
  };
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  addIssue = (sub) => {
    this.issues = [...this.issues, sub];
  };
  addIssues = (subs = []) => {
    this.issues = [...this.issues, ...subs];
  };
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/locales/en.ts
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(
        issue.expected,
        util.jsonStringifyReplacer
      )}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(
        issue.keys,
        ", "
      )}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(
        issue.options
      )}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(
        issue.options
      )}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/errors.ts
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/helpers/parseUtil.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m6) => !!m6).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      getErrorMap(),
      // then global override map
      en_default
      // then global default map
    ].filter((x5) => !!x5)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  value = "valid";
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x5) => x5.status === "aborted";
var isDirty = (x5) => x5.status === "dirty";
var isValid = (x5) => x5.status === "valid";
var isAsync = (x5) => typeof Promise !== "undefined" && x5 instanceof Promise;

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/types.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/helpers/errorUtil.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var errorUtil;
((errorUtil2) => {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/types.ts
var ParseInputLazyPath = class {
  parent;
  data;
  _path;
  _key;
  _cachedPath = [];
  constructor(parent, value, path2, key) {
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error ?? ctx.defaultError };
    }
    return { message: invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  _type;
  _output;
  _input;
  _def;
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  /** Alias of safeParseAsync */
  spa = this.safeParseAsync;
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(
          typeof refinementData === "function" ? refinementData(val, ctx) : refinementData
        );
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: "ZodDefault" /* ZodDefault */
    });
  }
  brand() {
    return new ZodBranded({
      typeName: "ZodBranded" /* ZodBranded */,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: "ZodCatch" /* ZodCatch */
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`
      );
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`
      );
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  static create = (params) => {
    return new _ZodString({
      checks: [],
      typeName: "ZodString" /* ZodString */,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  static create = (params) => {
    return new _ZodNumber({
      checks: [],
      typeName: "ZodNumber" /* ZodNumber */,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  min = this.gte;
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  max = this.lte;
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  step = this.multipleOf;
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find(
      (ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value)
    );
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  static create = (params) => {
    return new _ZodBigInt({
      checks: [],
      typeName: "ZodBigInt" /* ZodBigInt */,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  min = this.gte;
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  max = this.lte;
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
var ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodBoolean({
      typeName: "ZodBoolean" /* ZodBoolean */,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
  static create = (params) => {
    return new _ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: "ZodDate" /* ZodDate */,
      ...processCreateParams(params)
    });
  };
};
var ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodSymbol({
      typeName: "ZodSymbol" /* ZodSymbol */,
      ...processCreateParams(params)
    });
  };
};
var ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
  params;
  static create = (params) => {
    return new _ZodUndefined({
      typeName: "ZodUndefined" /* ZodUndefined */,
      ...processCreateParams(params)
    });
  };
};
var ZodNull = class _ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodNull({
      typeName: "ZodNull" /* ZodNull */,
      ...processCreateParams(params)
    });
  };
};
var ZodAny = class _ZodAny extends ZodType {
  // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
  _any = true;
  _parse(input) {
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodAny({
      typeName: "ZodAny" /* ZodAny */,
      ...processCreateParams(params)
    });
  };
};
var ZodUnknown = class _ZodUnknown extends ZodType {
  // required
  _unknown = true;
  _parse(input) {
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodUnknown({
      typeName: "ZodUnknown" /* ZodUnknown */,
      ...processCreateParams(params)
    });
  };
};
var ZodNever = class _ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
  static create = (params) => {
    return new _ZodNever({
      typeName: "ZodNever" /* ZodNever */,
      ...processCreateParams(params)
    });
  };
};
var ZodVoid = class _ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
  static create = (params) => {
    return new _ZodVoid({
      typeName: "ZodVoid" /* ZodVoid */,
      ...processCreateParams(params)
    });
  };
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i4) => {
          return def.type._parseAsync(
            new ParseInputLazyPath(ctx, item, ctx.path, i4)
          );
        })
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i4) => {
      return def.type._parseSync(
        new ParseInputLazyPath(ctx, item, ctx.path, i4)
      );
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
  static create = (schema, params) => {
    return new _ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: "ZodArray" /* ZodArray */,
      ...processCreateParams(params)
    });
  };
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(
      schema.items.map((item) => deepPartialify(item))
    );
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  _cached = null;
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, key)
        ),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError2 = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError2
            };
          return {
            message: defaultError2
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  /**
   * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
   * If you want to pass through unknown properties, use `.passthrough()` instead.
   */
  nonstrict = this.passthrough;
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  // extend<
  //   Augmentation extends ZodRawShape,
  //   NewOutput extends util.flatten<{
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   }>,
  //   NewInput extends util.flatten<{
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }>
  // >(
  //   augmentation: Augmentation
  // ): ZodObject<
  //   extendShape<T, Augmentation>,
  //   UnknownKeys,
  //   Catchall,
  //   NewOutput,
  //   NewInput
  // > {
  //   return new ZodObject({
  //     ...this._def,
  //     shape: () => ({
  //       ...this._def.shape(),
  //       ...augmentation,
  //     }),
  //   }) as any;
  // }
  /**
   * @deprecated Use `.extend` instead
   *  */
  augment = this.extend;
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: "ZodObject" /* ZodObject */
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(
      util.objectKeys(this.shape)
    );
  }
  static create = (shape, params) => {
    return new _ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: "ZodObject" /* ZodObject */,
      ...processCreateParams(params)
    });
  };
  static strictCreate = (shape, params) => {
    return new _ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: "ZodObject" /* ZodObject */,
      ...processCreateParams(params)
    });
  };
  static lazycreate = (shape, params) => {
    return new _ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: "ZodObject" /* ZodObject */,
      ...processCreateParams(params)
    });
  };
};
var ZodUnion = class _ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map(
        (result) => new ZodError(result.ctx.common.issues)
      );
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
  static create = (types, params) => {
    return new _ZodUnion({
      options: types,
      typeName: "ZodUnion" /* ZodUnion */,
      ...processCreateParams(params)
    });
  };
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(
            `Discriminator property ${String(
              discriminator
            )} has duplicate value ${String(value)}`
          );
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b5) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b5);
  if (a2 === b5) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b5);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b5 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b5[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b5.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b5[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b5) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class _ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      );
    }
  }
  static create = (left, right, params) => {
    return new _ZodIntersection({
      left,
      right,
      typeName: "ZodIntersection" /* ZodIntersection */,
      ...processCreateParams(params)
    });
  };
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(
        new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)
      );
    }).filter((x5) => !!x5);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
  static create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new _ZodTuple({
      items: schemas,
      typeName: "ZodTuple" /* ZodTuple */,
      rest: null,
      ...processCreateParams(params)
    });
  };
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)
        )
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: "ZodRecord" /* ZodRecord */,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: "ZodRecord" /* ZodRecord */,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(
      ([key, value], index) => {
        return {
          key: keyType._parse(
            new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])
          ),
          value: valueType._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])
          )
        };
      }
    );
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
  static create = (keyType, valueType, params) => {
    return new _ZodMap({
      valueType,
      keyType,
      typeName: "ZodMap" /* ZodMap */,
      ...processCreateParams(params)
    });
  };
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map(
      (item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4))
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
  static create = (valueType, params) => {
    return new _ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: "ZodSet" /* ZodSet */,
      ...processCreateParams(params)
    });
  };
};
var ZodFunction = class _ZodFunction extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          en_default
        ].filter((x5) => !!x5),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          en_default
        ].filter((x5) => !!x5),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me3 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me3._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me3._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me3 = this;
      return OK(function(...args) {
        const parsedArgs = me3._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me3._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  validate = this.implement;
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: "ZodFunction" /* ZodFunction */,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
  static create = (getter, params) => {
    return new _ZodLazy({
      getter,
      typeName: "ZodLazy" /* ZodLazy */,
      ...processCreateParams(params)
    });
  };
};
var ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
  static create = (value, params) => {
    return new _ZodLiteral({
      value,
      typeName: "ZodLiteral" /* ZodLiteral */,
      ...processCreateParams(params)
    });
  };
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: "ZodEnum" /* ZodEnum */,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(
      this.options.filter((opt) => !values.includes(opt))
    );
  }
  static create = createZodEnum;
};
var ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
  static create = (values, params) => {
    return new _ZodNativeEnum({
      values,
      typeName: "ZodNativeEnum" /* ZodNativeEnum */,
      ...processCreateParams(params)
    });
  };
};
var ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      })
    );
  }
  static create = (schema, params) => {
    return new _ZodPromise({
      type: schema,
      typeName: "ZodPromise" /* ZodPromise */,
      ...processCreateParams(params)
    });
  };
};
var ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" /* ZodEffects */ ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then(
            (result) => ({ status: status.value, value: result })
          );
        });
      }
    }
    util.assertNever(effect);
  }
  static create = (schema, effect, params) => {
    return new _ZodEffects({
      schema,
      typeName: "ZodEffects" /* ZodEffects */,
      effect,
      ...processCreateParams(params)
    });
  };
  static createWithPreprocess = (preprocess, schema, params) => {
    return new _ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: "ZodEffects" /* ZodEffects */,
      ...processCreateParams(params)
    });
  };
};
var ZodOptional = class _ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
  static create = (type, params) => {
    return new _ZodOptional({
      innerType: type,
      typeName: "ZodOptional" /* ZodOptional */,
      ...processCreateParams(params)
    });
  };
};
var ZodNullable = class _ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
  static create = (type, params) => {
    return new _ZodNullable({
      innerType: type,
      typeName: "ZodNullable" /* ZodNullable */,
      ...processCreateParams(params)
    });
  };
};
var ZodDefault = class _ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
  static create = (type, params) => {
    return new _ZodDefault({
      innerType: type,
      typeName: "ZodDefault" /* ZodDefault */,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
};
var ZodCatch = class _ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
  static create = (type, params) => {
    return new _ZodCatch({
      innerType: type,
      typeName: "ZodCatch" /* ZodCatch */,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
};
var ZodNaN = class _ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  static create = (params) => {
    return new _ZodNaN({
      typeName: "ZodNaN" /* ZodNaN */,
      ...processCreateParams(params)
    });
  };
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b5) {
    return new _ZodPipeline({
      in: a2,
      out: b5,
      typeName: "ZodPipeline" /* ZodPipeline */
    });
  }
};
var ZodReadonly = class _ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  static create = (type, params) => {
    return new _ZodReadonly({
      innerType: type,
      typeName: "ZodReadonly" /* ZodReadonly */,
      ...processCreateParams(params)
    });
  };
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      if (!check(data)) {
        const p6 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = p6.fatal ?? fatal ?? true;
        const p22 = typeof p6 === "string" ? { message: p6 } : p6;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind = /* @__PURE__ */ ((ZodFirstPartyTypeKind2) => {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  return ZodFirstPartyTypeKind2;
})(ZodFirstPartyTypeKind || {});
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;

// esbuild_serve:http-import:https://deno.land/x/zod@v3.22.4/index.ts
var zod_v3_22_default = external_exports;

// spec/music.ts
var DATE_PATTERN = /\d\d\d\d-\d\d-\d\d/;
var userString = zod_v3_22_exports.string().min(1).transform((x5) => x5.trim());
var DropType = /* @__PURE__ */ ((DropType2) => {
  DropType2["Published"] = "PUBLISHED";
  DropType2["Publishing"] = "PUBLISHING";
  DropType2["Private"] = "PRIVATE";
  DropType2["UnderReview"] = "UNDER_REVIEW";
  DropType2["Unsubmitted"] = "UNSUBMITTED";
  DropType2["ReviewDeclined"] = "REVIEW_DECLINED";
  return DropType2;
})(DropType || {});
var ArtistTypes = /* @__PURE__ */ ((ArtistTypes2) => {
  ArtistTypes2["Primary"] = "PRIMARY";
  ArtistTypes2["Featuring"] = "FEATURING";
  ArtistTypes2["Songwriter"] = "SONGWRITER";
  ArtistTypes2["Producer"] = "PRODUCER";
  return ArtistTypes2;
})(ArtistTypes || {});
var artist = zod_v3_22_exports.tuple([
  userString,
  zod_v3_22_exports.string(),
  zod_v3_22_exports.nativeEnum(ArtistTypes)
]);
var song = zod_v3_22_exports.object({
  id: zod_v3_22_exports.string(),
  isrc: zod_v3_22_exports.string().optional(),
  title: userString,
  artists: artist.array().refine((x5) => x5.some(([, , type]) => type == "PRIMARY"), { message: "At least one primary artist is required" }),
  secondaryGenre: zod_v3_22_exports.string(),
  year: zod_v3_22_exports.number(),
  country: zod_v3_22_exports.string(),
  //TODO: Add in frontend mby
  language: zod_v3_22_exports.string().optional(),
  explicit: zod_v3_22_exports.boolean(),
  instrumental: zod_v3_22_exports.boolean(),
  file: zod_v3_22_exports.string({ required_error: "a Song is missing its file." }),
  progress: zod_v3_22_exports.number().optional().transform((x5) => void 0)
}).refine(({ instrumental, explicit }) => !(instrumental && explicit), "Can't have an explicit instrumental song");
var pureDrop = zod_v3_22_exports.object({
  upc: zod_v3_22_exports.string().trim().max(0).nullable().or(
    zod_v3_22_exports.string().trim().min(12, { message: "UPC/EAN: Invalid length" }).max(13, { message: "UPC/EAN: Invalid length" }).regex(/^\d+$/, { message: "UPC/EAN: Not a number" }).refine((gtin) => parseInt(gtin.slice(-1), 10) === (10 - sumOf(gtin.slice(0, -1).split("").map((digit, index) => parseInt(digit, 10) * ((16 - gtin.length + index) % 2 === 0 ? 3 : 1)), (x5) => x5) % 10) % 10, {
      message: "UPC/EAN: Invalid"
    })
  ),
  title: userString,
  artists: artist.array().refine((x5) => x5.some(([, , type]) => type == "PRIMARY"), { message: "At least one primary artist is required" }),
  release: zod_v3_22_exports.string().regex(DATE_PATTERN, { message: "Not a date" }),
  language: zod_v3_22_exports.string(),
  primaryGenre: zod_v3_22_exports.string(),
  secondaryGenre: zod_v3_22_exports.string(),
  compositionCopyright: userString,
  soundRecordingCopyright: userString,
  artwork: zod_v3_22_exports.string(),
  songs: song.array().min(1),
  comments: userString.optional()
});
var drop = pureDrop.merge(zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  user: zod_v3_22_exports.string(),
  type: zod_v3_22_exports.nativeEnum(DropType)
}));
var pageOne = zod_v3_22_exports.object({
  upc: zod_v3_22_exports.string().trim().min(12, { message: "UPC/EAN: Invalid length" }).max(13, { message: "UPC/EAN: Invalid length" }).regex(/^\d+$/, { message: "UPC/EAN: Not a number" }).refine((gtin) => parseInt(gtin.slice(-1), 10) === (10 - sumOf(gtin.slice(0, -1).split("").map((digit, index) => parseInt(digit, 10) * ((16 - gtin.length + index) % 2 === 0 ? 3 : 1)), (x5) => x5) % 10) % 10, {
    message: "UPC/EAN: Invalid checksum"
  }).or(zod_v3_22_exports.string().trim().max(0, { message: "UPC/EAN: Invalid" }).nullable())
});
var pageTwo = zod_v3_22_exports.object({
  title: userString,
  artists: artist.array().refine((x5) => x5.some(([, , type]) => type == "PRIMARY"), { message: "At least one primary artist is required" }),
  release: zod_v3_22_exports.string().regex(DATE_PATTERN, { message: "Not a date" }),
  language: zod_v3_22_exports.string(),
  primaryGenre: zod_v3_22_exports.string(),
  secondaryGenre: zod_v3_22_exports.string()
});
var pageThree = zod_v3_22_exports.object({
  compositionCopyright: userString,
  soundRecordingCopyright: userString
});
var pageFour = zod_v3_22_exports.object({
  artwork: zod_v3_22_exports.string(),
  loading: zod_v3_22_exports.literal(false, { errorMap: () => ({ message: "Artwork is still uploading" }) }).transform(() => void 0)
});
var pageFive = zod_v3_22_exports.object({
  songs: song.array().min(1, { message: "At least one song is required" }),
  uploadingSongs: zod_v3_22_exports.array(zod_v3_22_exports.string()).max(0, { message: "Some uploads are still in progress" })
});
var payout = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  file: zod_v3_22_exports.string(),
  period: zod_v3_22_exports.string(),
  entries: zod_v3_22_exports.object({
    isrc: zod_v3_22_exports.string(),
    data: zod_v3_22_exports.array(
      zod_v3_22_exports.object({
        store: zod_v3_22_exports.string(),
        territory: zod_v3_22_exports.string(),
        quantity: zod_v3_22_exports.number(),
        revenue: zod_v3_22_exports.number()
      })
    )
  }).array(),
  user: zod_v3_22_exports.string()
});
var oauthapp = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  name: userString,
  redirect: zod_v3_22_exports.string().url().array(),
  secret: zod_v3_22_exports.string(),
  icon: zod_v3_22_exports.string()
});
var file = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  length: zod_v3_22_exports.number(),
  chunkSize: zod_v3_22_exports.number(),
  uploadDate: zod_v3_22_exports.string(),
  filename: zod_v3_22_exports.string(),
  metadata: zod_v3_22_exports.object({
    type: zod_v3_22_exports.string()
  })
});
var PaymentType = /* @__PURE__ */ ((PaymentType2) => {
  PaymentType2["Restrained"] = "RESTRAINED";
  PaymentType2["Unrestrained"] = "UNRESTRAINED";
  return PaymentType2;
})(PaymentType || {});
var wallet = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  transactions: zod_v3_22_exports.object({
    amount: zod_v3_22_exports.number(),
    // positive for incoming, negative for outgoing
    timestamp: zod_v3_22_exports.string(),
    type: zod_v3_22_exports.nativeEnum(PaymentType),
    description: zod_v3_22_exports.string(),
    counterParty: zod_v3_22_exports.string()
  }).array(),
  cut: zod_v3_22_exports.number(),
  user: zod_v3_22_exports.string(),
  userName: zod_v3_22_exports.string().optional(),
  email: zod_v3_22_exports.string().optional(),
  balance: zod_v3_22_exports.object({
    restrained: zod_v3_22_exports.number(),
    unrestrained: zod_v3_22_exports.number()
  }).optional(),
  stripeAccountId: zod_v3_22_exports.string().optional()
});
var limits = zod_v3_22_exports.object({
  memory: zod_v3_22_exports.number(),
  disk: zod_v3_22_exports.number(),
  cpu: zod_v3_22_exports.number()
});
var ServerTypes = /* @__PURE__ */ ((ServerTypes2) => {
  ServerTypes2["Vanilla"] = "/minecraft/vanilla/";
  ServerTypes2["Default"] = "/minecraft/default/";
  ServerTypes2["Fabric"] = "/minecraft/modded/fabric/";
  ServerTypes2["Forge"] = "/minecraft/modded/forge/";
  ServerTypes2["Bedrock"] = "/minecraft/bedrock/";
  ServerTypes2["PocketMine"] = "/minecraft/pocketmine/";
  return ServerTypes2;
})(ServerTypes || {});
var serverPowerState = zod_v3_22_exports.enum(["starting", "installing", "stopping", "running", "offline"]);
var serverPowerActions = zod_v3_22_exports.enum(["start", "stop", "kill"]);
var location2 = zod_v3_22_exports.enum(["bbn-fsn", "bbn-hel", "bbn-mum", "bbn-sgp"]);
var serverLabels = zod_v3_22_exports.enum([
  "suspended",
  "contact-support",
  "maintenance",
  "disabled"
]);
var server = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  name: zod_v3_22_exports.string().max(30),
  type: zod_v3_22_exports.nativeEnum(ServerTypes),
  location: location2,
  limits,
  state: serverPowerState,
  address: zod_v3_22_exports.string().optional(),
  ports: zod_v3_22_exports.number().array(),
  user: zod_v3_22_exports.string(),
  stateSince: zod_v3_22_exports.number().describe("unix timestamp"),
  labels: serverLabels.array(),
  version: zod_v3_22_exports.string()
});
var serverCreate = zod_v3_22_exports.object({
  name: zod_v3_22_exports.string().min(3).max(20),
  type: zod_v3_22_exports.nativeEnum(ServerTypes),
  location: location2,
  limits: zod_v3_22_exports.object({
    memory: limits.shape.memory.min(300, "Minimum memory is 300MB"),
    disk: limits.shape.disk.min(200, "Minimum disk is 200MB"),
    cpu: limits.shape.cpu.min(3, "Minimum cpu is 3% of a core")
  }),
  version: zod_v3_22_exports.string()
});
var metaLimit = limits.extend({
  slots: zod_v3_22_exports.number()
});
var storeItems = zod_v3_22_exports.enum(["memory", "disk", "cpu", "slots"]);
var meta = zod_v3_22_exports.object({
  _id: zod_v3_22_exports.string(),
  owner: zod_v3_22_exports.string(),
  coins: zod_v3_22_exports.number(),
  limits: metaLimit,
  used: metaLimit,
  pricing: zod_v3_22_exports.record(
    storeItems,
    zod_v3_22_exports.object({
      price: zod_v3_22_exports.number(),
      amount: zod_v3_22_exports.number()
    })
  )
});
var bugReport = zod_v3_22_exports.object({
  type: zod_v3_22_exports.literal("web-frontend"),
  error: zod_v3_22_exports.string(),
  errorStack: zod_v3_22_exports.string(),
  platform: zod_v3_22_exports.string().optional(),
  platformVersion: zod_v3_22_exports.string().optional(),
  browserVersion: zod_v3_22_exports.string().optional(),
  browser: zod_v3_22_exports.string().optional(),
  userId: zod_v3_22_exports.string().optional(),
  location: zod_v3_22_exports.string()
});
var transcript = zod_v3_22_exports.object({
  messages: zod_v3_22_exports.object({
    author: zod_v3_22_exports.string(),
    authorid: zod_v3_22_exports.string(),
    content: zod_v3_22_exports.string(),
    timestamp: zod_v3_22_exports.string(),
    avatar: zod_v3_22_exports.string(),
    attachments: zod_v3_22_exports.array(zod_v3_22_exports.string()).optional(),
    embeds: zod_v3_22_exports.array(zod_v3_22_exports.any()).optional()
  }).array(),
  closed: zod_v3_22_exports.string(),
  with: zod_v3_22_exports.string(),
  _id: zod_v3_22_exports.string()
});
var installedAddon = zod_v3_22_exports.object({
  projectId: zod_v3_22_exports.string(),
  versionId: zod_v3_22_exports.string()
});
var sidecarRequest = zod_v3_22_exports.discriminatedUnion("type", [
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("list"),
    path: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("read"),
    path: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("next-chunk"),
    path: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("install-addons"),
    addons: installedAddon.array()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("installed-addons")
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("uninstall-addon"),
    projectId: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("write"),
    path: zod_v3_22_exports.string(),
    chunk: zod_v3_22_exports.string().optional()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("command"),
    command: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("delete"),
    path: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("state"),
    state: serverPowerActions
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("tree"),
    path: zod_v3_22_exports.string()
  })
]);
var addon = zod_v3_22_exports.object({
  id: zod_v3_22_exports.string(),
  name: zod_v3_22_exports.string(),
  description: zod_v3_22_exports.string(),
  downloads: zod_v3_22_exports.number(),
  lastUpdated: zod_v3_22_exports.string(),
  icon: zod_v3_22_exports.string(),
  background: zod_v3_22_exports.string()
});
var sidecarFile = zod_v3_22_exports.object({
  name: zod_v3_22_exports.string(),
  canWrite: zod_v3_22_exports.boolean(),
  isFile: zod_v3_22_exports.boolean(),
  fileMimeType: zod_v3_22_exports.string().optional(),
  lastModified: zod_v3_22_exports.number().optional(),
  size: zod_v3_22_exports.number().optional()
});
var sidecarResponse = zod_v3_22_exports.discriminatedUnion("type", [
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("list"),
    path: zod_v3_22_exports.string(),
    canWrite: zod_v3_22_exports.boolean(),
    list: sidecarFile.array()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("read"),
    path: zod_v3_22_exports.string(),
    chunk: zod_v3_22_exports.string().optional(),
    finish: zod_v3_22_exports.boolean().optional()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("log"),
    chunk: zod_v3_22_exports.string(),
    backlog: zod_v3_22_exports.boolean().optional()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("error"),
    error: zod_v3_22_exports.string(),
    path: zod_v3_22_exports.string().optional()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("next-chunk"),
    path: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("state"),
    state: serverPowerState
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("stats"),
    stats: zod_v3_22_exports.object({
      cpu: zod_v3_22_exports.number(),
      memory: zod_v3_22_exports.number(),
      disk: zod_v3_22_exports.number()
    })
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("install-addons"),
    success: zod_v3_22_exports.boolean()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("installed-addons"),
    addons: zod_v3_22_exports.object({
      addon: installedAddon,
      dependencies: installedAddon.array()
    }).array()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("uninstall-addon"),
    success: zod_v3_22_exports.boolean()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("tree"),
    path: zod_v3_22_exports.string(),
    canWrite: zod_v3_22_exports.boolean(),
    files: sidecarFile.array()
  })
]);
var requestPayoutResponse = zod_v3_22_exports.discriminatedUnion("type", [
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("createAccount"),
    url: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("needDetails"),
    missingDetails: zod_v3_22_exports.array(zod_v3_22_exports.string()),
    url: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    type: zod_v3_22_exports.literal("success")
  })
]);
var audit = zod_v3_22_exports.discriminatedUnion("action", [
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("store-purchase" /* StorePurchase */),
    user: zod_v3_22_exports.string(),
    type: zod_v3_22_exports.enum(["memory", "disk", "cpu", "slots"])
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("server-create" /* ServerCreate */),
    user: zod_v3_22_exports.string(),
    serverId: zod_v3_22_exports.string(),
    data: zod_v3_22_exports.any()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("server-power-change" /* ServerPowerChange */),
    user: zod_v3_22_exports.string(),
    server: zod_v3_22_exports.string(),
    power: serverPowerActions
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("server-modify" /* ServerModify */),
    user: zod_v3_22_exports.string(),
    serverId: zod_v3_22_exports.string(),
    changes: zod_v3_22_exports.object({
      name: zod_v3_22_exports.string(),
      location: zod_v3_22_exports.string(),
      limits,
      state: serverPowerState,
      ports: zod_v3_22_exports.number().array(),
      labels: zod_v3_22_exports.enum(["suspended", "contact-support"]).array()
    }).partial()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("server-delete" /* ServerDelete */),
    user: zod_v3_22_exports.string(),
    serverId: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("file-upload" /* FileUpload */),
    user: zod_v3_22_exports.string(),
    file: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("file-delete" /* FileDelete */),
    user: zod_v3_22_exports.string(),
    file: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("file-read" /* FileRead */),
    user: zod_v3_22_exports.string(),
    file: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("command-execute" /* CommandExecute */),
    user: zod_v3_22_exports.string(),
    server: zod_v3_22_exports.string(),
    command: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("reset-password" /* ResetPassword */)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("drop-review" /* DropReview */),
    dropId: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("drop-type-change" /* DropTypeChange */),
    dropId: zod_v3_22_exports.string(),
    type: zod_v3_22_exports.nativeEnum(DropType)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("drop-create" /* DropCreate */),
    dropId: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("oauth-validate" /* OAuthValidate */),
    appId: zod_v3_22_exports.string(),
    scopes: zod_v3_22_exports.array(zod_v3_22_exports.string())
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("oauth-authorize" /* OAuthAuthorize */),
    appId: zod_v3_22_exports.string(),
    scopes: zod_v3_22_exports.array(zod_v3_22_exports.string())
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("web-authn-sign-in" /* WebAuthNSignIn */)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("web-authn-sign-up" /* WebAuthNSignUp */)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("password-sign-in" /* PasswordSignIn */)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("password-sign-up" /* PasswordSignUp */)
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("oauth-sign-in" /* OAuthSignIn */),
    provider: zod_v3_22_exports.string()
  }),
  zod_v3_22_exports.object({
    action: zod_v3_22_exports.literal("oauth-sign-up" /* OAuthSignUp */),
    provider: zod_v3_22_exports.string()
  })
]);
var serverAudit = zod_v3_22_exports.object({
  id: zod_v3_22_exports.string(),
  _id: zod_v3_22_exports.string().optional(),
  // Remove after some time
  meta: audit,
  user: zod_v3_22_exports.object({
    profile: zod_v3_22_exports.object({
      username: zod_v3_22_exports.string(),
      avatar: zod_v3_22_exports.string()
    })
  })
});
var group = zod_v3_22_exports.object({
  displayName: zod_v3_22_exports.string(),
  _id: zod_v3_22_exports.string(),
  // Replace with id
  permission: zod_v3_22_exports.string()
});

// pages/_legacy/helper.ts
function IsLoggedIn() {
  try {
    return localStorage["access-token"] ? JSON.parse(b64DecodeUnicode(localStorage["access-token"].split(".")[1])).user : null;
  } catch (_5) {
    resetTokens();
    return null;
  }
}
function changeThemeColor() {
  return (_data) => {
  };
}
function b64DecodeUnicode(value) {
  return decodeURIComponent(atob(value).split("").map((c3) => `%${`00${c3.charCodeAt(0).toString(16)}`.slice(-2)}`).join(""));
}
function rawAccessToken() {
  return JSON.parse(b64DecodeUnicode(localStorage["access-token"].split(".")[1]));
}
var activeUser = asState({
  email: void 0,
  username: "--",
  avatar: void 0,
  permission: [],
  id: void 0
});
function permCheck(...per) {
  return API.isPermited(per, activeUser.permission);
}
function updateActiveUserData() {
  try {
    const user = IsLoggedIn();
    if (!user)
      return;
    activeUser.username = user.profile.username;
    activeUser.email = user.profile.email;
    activeUser.avatar = user.profile.avatar;
    activeUser.id = user._id;
    activeUser.permission = asState(user.permissions);
  } catch (_5) {
    logOut();
  }
}
function checkIfRefreshTokenIsValid() {
  const token = localStorage["refresh-token"];
  if (!token)
    return;
  const tokenData = JSON.parse(b64DecodeUnicode(token.split(".")[1]));
  if (isExpired(tokenData.exp)) {
    logOut();
    return;
  }
}
function logOut(goal) {
  if (location.pathname.startsWith("/signin"))
    return;
  resetTokens();
  location.href = "/signin";
  localStorage.goal = goal ?? "/c/music";
}
function resetTokens() {
  localStorage.removeItem("refresh-token");
  localStorage.removeItem("access-token");
  localStorage.removeItem("goal");
}
async function renewAccessTokenIfNeeded() {
  if (!localStorage.getItem("access-token"))
    return;
  const { exp } = rawAccessToken();
  if (!exp)
    return logOut();
  if (isExpired(exp)) {
    await forceRefreshToken();
  }
}
var tokens = asState({
  accessToken: localStorage["access-token"],
  refreshToken: localStorage["refresh-token"]
});
async function forceRefreshToken() {
  try {
    const access = await API.auth.refreshAccessToken.post(localStorage["refresh-token"]).then(stupidErrorAlert);
    localStorage["access-token"] = access.token;
    tokens.accessToken = access.token;
  } catch (_5) {
    location.href = "/";
  }
}
function isExpired(exp) {
  return exp * 1e3 < (/* @__PURE__ */ new Date()).getTime() + 0.5 * 60 * 1e3;
}
async function RegisterAuthRefresh() {
  if (!IsLoggedIn())
    return shouldLoginPage();
  try {
    updateActiveUserData();
    checkIfRefreshTokenIsValid();
    await renewAccessTokenIfNeeded();
    setInterval(() => renewAccessTokenIfNeeded(), 1e3);
  } catch (error) {
    console.error(error);
  }
}
function shouldLoginPage() {
  if (!loginRequired.find((x5) => location.pathname.startsWith(x5))) {
    return;
  }
  localStorage.goal = location.pathname + location.search;
  location.href = "/signin";
  throw "aborting javascript here";
}
var sheetStack = SheetsStack().setSheetWidth("auto").setSheetHeight("auto");
var a = document.createElement("a");
document.body.appendChild(a);
a.setAttribute("style", "display: none");
function stringToColor(str) {
  let hash = 0;
  for (let i4 = 0; i4 < str.length; i4++) {
    hash = str.charCodeAt(i4) + ((hash << 5) - hash);
  }
  let color = "#";
  for (let i4 = 0; i4 < 3; i4++) {
    const value = hash >> i4 * 8 & 255;
    color += `00${value.toString(16)}`.slice(-2);
  }
  return color;
}
function ProfilePicture(component, name) {
  const ele = component.draw();
  ele.style.backgroundColor = stringToColor(name);
  return Custom(ele).addClass("profile-picture");
}
function getNameInital(name) {
  if (name.includes(", ")) {
    return name.split(", ").map((x5) => x5.at(0)?.toUpperCase()).join("");
  }
  if (name.includes(",")) {
    return name.split(",").map((x5) => x5.at(0)?.toUpperCase()).join("");
  }
  if (name.includes(" ")) {
    return name.split(" ").map((x5) => x5.at(0)?.toUpperCase()).join("");
  }
  return name.at(0).toUpperCase();
}
function showProfilePicture(x5) {
  return ProfilePicture(
    x5.profile.avatar ? Image({
      type: "direct",
      source: async () => {
        const blob2 = new Blob();
        const data = await API.user.picture(x5._id);
        if (data.status == "fulfilled") {
          return data.value;
        }
        return blob2;
      }
    }, "Profile Picture") : Label(getNameInital(x5.profile.username)),
    x5.profile.username
  );
}

// components/nav.ts
var Nav = (component) => {
  const nav = createElement("nav");
  nav.append(component.draw());
  return Custom(nav);
};
var navMenuPopover = Popover(
  Box(
    activeUser.$permission.map(
      () => Vertical(
        Label("SWITCH TO").addClass("title"),
        pages.map(
          ([logo, permission, route, login]) => permCheck(...permission) && (!login || login == 1 && IsLoggedIn() || login == 2 && !IsLoggedIn()) ? Horizontal(
            Image(logo, "Logo"),
            Spacer(),
            MIcon("arrow_forward_ios")
          ).addClass("small-entry").onClick(() => location.pathname = route) : Empty()
        ),
        Horizontal(
          Label("Go to Settings"),
          Spacer(),
          MIcon("arrow_forward_ios")
        ).addClass("small-entry", "settings").onClick(() => location.href = "/settings")
      )
    ).asRefComponent()
  ).addClass("drop-over")
).pullingAnchorPositioning("--nav-menu-popover", (rect, style) => {
  style.top = `max(-5px, ${rect.bottom}px)`;
  style.left = `${rect.left}px`;
  style.minWidth = `${rect.width}px`;
  style.bottom = "var(--gap)";
  style.height = "min-content";
});
function DynaNavigation(type) {
  return Nav(
    Grid(
      Horizontal(
        Vertical(
          MIcon("apps"),
          Vertical(
            Label(activeTitle(type)).setFontWeight("bold").setTextSize("2xl").setMargin("2px 0 0")
          )
        ).setGap(".5rem").setDirection("row").setAlignItems("center").setJustifyContent("center").addClass("clickable").setAnchorName("--nav-menu-popover").onClick(() => {
          navMenuPopover.showPopover();
        }),
        Spacer(),
        activeUser.$email.map(
          (email) => email ? LinkButton(
            Grid(
              showProfilePicture(IsLoggedIn()),
              Label(activeUser.$username).setFontWeight("bold")
            ).setRawColumns("max-content max-content").setAlignItems("center").setGap(".7rem"),
            "/settings"
          ).addClass("profile-button").setStyle("inline" /* Inline */) : (type === "Home" || type === "Music") && !location.pathname.startsWith("/signin") ? LinkButton("Sign in", "/signin").addClass("login-button") : Box()
        ).asRefComponent() ?? null
      ),
      IsLoggedIn() && IsLoggedIn().profile.verified?.email != true ? Grid(
        BasicLabel({
          title: "Your Email is not verified. Please check your Inbox/Spam folder."
        }).addClass("label"),
        Button("Resend Verify Email").addClass("link").onPromiseClick(async () => {
          await API.user.mail.resendVerifyEmail.post();
          await delay(1e3);
        })
      ).addClass("email-banner", type.toLowerCase()) : Empty()
    ).setMargin("0.5rem auto").setGap("0.4rem")
  ).addClass(type.toLowerCase());
}

// pages/hosting/data.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var MB = 1e6;
var state = asState({
  loaded: false,
  servers: [],
  meta: void 0
});
var creationState = asState({
  loading: false,
  type: void 0,
  versions: []
});

// pages/hosting/loading.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/x/hmsys_connector@0.9.0/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/encoding/base64.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/encoding/_util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var encoder = new TextEncoder();
function getTypeName(value) {
  const type = typeof value;
  if (type !== "object") {
    return type;
  } else if (value === null) {
    return "null";
  } else {
    return value?.constructor?.name ?? "object";
  }
}
function validateBinaryLike(source) {
  if (typeof source === "string") {
    return encoder.encode(source);
  } else if (source instanceof Uint8Array) {
    return source;
  } else if (source instanceof ArrayBuffer) {
    return new Uint8Array(source);
  }
  throw new TypeError(
    `The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${getTypeName(source)}.`
  );
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/encoding/base64.ts
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encodeBase64(data) {
  const uint8 = validateBinaryLike(data);
  let result = "";
  let i4;
  const l4 = uint8.length;
  for (i4 = 2; i4 < l4; i4 += 3) {
    result += base64abc[uint8[i4 - 2] >> 2];
    result += base64abc[(uint8[i4 - 2] & 3) << 4 | uint8[i4 - 1] >> 4];
    result += base64abc[(uint8[i4 - 1] & 15) << 2 | uint8[i4] >> 6];
    result += base64abc[uint8[i4] & 63];
  }
  if (i4 === l4 + 1) {
    result += base64abc[uint8[i4 - 2] >> 2];
    result += base64abc[(uint8[i4 - 2] & 3) << 4];
    result += "==";
  }
  if (i4 === l4) {
    result += base64abc[uint8[i4 - 2] >> 2];
    result += base64abc[(uint8[i4 - 2] & 3) << 4 | uint8[i4 - 1] >> 4];
    result += base64abc[(uint8[i4 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decodeBase64(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i4 = 0; i4 < size; i4++) {
    bytes[i4] = binString.charCodeAt(i4);
  }
  return bytes;
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/network.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.217.0/assert/assert.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.217.0/assert/assertion_error.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var AssertionError2 = class extends Error {
  /** Constructs a new instance. */
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};

// esbuild_serve:http-import:https://deno.land/std@0.217.0/assert/assert.ts
function assert2(expr, msg = "") {
  if (!expr) {
    throw new AssertionError2(msg);
  }
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/async/delay.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function delay2(ms2, options = {}) {
  const { signal, persistent } = options;
  if (signal?.aborted)
    return Promise.reject(signal.reason);
  return new Promise((resolve, reject2) => {
    const abort = () => {
      clearTimeout(i4);
      reject2(signal?.reason);
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve();
    };
    const i4 = setTimeout(done, ms2);
    signal?.addEventListener("abort", abort, { once: true });
    if (persistent === false) {
      try {
        Deno.unrefTimer(i4);
      } catch (error) {
        if (!(error instanceof ReferenceError)) {
          throw error;
        }
        console.error("`persistent` option is only available in Deno");
      }
    }
  });
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/async/pool.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var ERROR_WHILE_MAPPING_MESSAGE = "Threw while mapping.";
function pooledMap(poolLimit, array, iteratorFn) {
  const res = new TransformStream({
    async transform(p6, controller) {
      try {
        const s2 = await p6;
        controller.enqueue(s2);
      } catch (e) {
        if (e instanceof AggregateError && e.message === ERROR_WHILE_MAPPING_MESSAGE) {
          controller.error(e);
        }
      }
    }
  });
  (async () => {
    const writer = res.writable.getWriter();
    const executing = [];
    try {
      for await (const item of array) {
        const p6 = Promise.resolve().then(() => iteratorFn(item));
        writer.write(p6);
        const e = p6.then(
          () => executing.splice(executing.indexOf(e), 1)
        );
        executing.push(e);
        if (executing.length >= poolLimit) {
          await Promise.race(executing);
        }
      }
      await Promise.all(executing);
      writer.close();
    } catch {
      const errors2 = [];
      for (const result of await Promise.allSettled(executing)) {
        if (result.status === "rejected") {
          errors2.push(result.reason);
        }
      }
      writer.write(Promise.reject(
        new AggregateError(errors2, ERROR_WHILE_MAPPING_MESSAGE)
      )).catch(() => {
      });
    }
  })();
  return Symbol.asyncIterator in res.readable && typeof res.readable[Symbol.asyncIterator] === "function" ? res.readable[Symbol.asyncIterator]() : async function* () {
    const reader = res.readable.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      yield value;
    }
    reader.releaseLock();
  }();
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/datetime/constants.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var SECOND = 1e3;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/extended/scheduler.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function createScheduler() {
  let hasTask = Promise.withResolvers();
  const queue = [];
  const scheduler = new ReadableStream({
    pull: async (controller) => {
      if (queue.length === 0) {
        hasTask = Promise.withResolvers();
        await hasTask.promise;
      }
      const task = sortBy(queue, (it) => it.priority)[0];
      controller.enqueue(task);
      queue.splice(queue.indexOf(task), 1);
    }
  });
  return {
    scheduler,
    add: (object) => {
      queue.push(object);
      hasTask.resolve();
    }
  };
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/async/retry.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.217.0/async/_util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function exponentialBackoffWithJitter(cap, base, attempt, multiplier, jitter) {
  const exp = Math.min(cap, base * multiplier ** attempt);
  return (1 - jitter * Math.random()) * exp;
}

// esbuild_serve:http-import:https://deno.land/std@0.217.0/async/retry.ts
var RetryError = class extends Error {
  /**
   * Constructs a new {@linkcode RetryError} instance.
   *
   * @example
   * ```
   * import { RetryError } from "https://deno.land/std@$STD_VERSION/async/retry.ts";
   *
   * throw new RetryError({ foo: "bar" }, 3);
   * ```
   */
  constructor(cause, attempts) {
    super(`Retrying exceeded the maxAttempts (${attempts}).`);
    this.name = "RetryError";
    this.cause = cause;
  }
};
var defaultRetryOptions = {
  multiplier: 2,
  maxTimeout: 6e4,
  maxAttempts: 5,
  minTimeout: 1e3,
  jitter: 1
};
async function retry(fn2, opts) {
  const options = {
    ...defaultRetryOptions,
    ...opts
  };
  assert2(options.maxTimeout >= 0, "maxTimeout is less than 0");
  assert2(
    options.minTimeout <= options.maxTimeout,
    "minTimeout is greater than maxTimeout"
  );
  assert2(options.jitter <= 1, "jitter is greater than 1");
  let attempt = 0;
  while (true) {
    try {
      return await fn2();
    } catch (error) {
      if (attempt + 1 >= options.maxAttempts) {
        throw new RetryError(error, options.maxAttempts);
      }
      const timeout = exponentialBackoffWithJitter(
        options.maxTimeout,
        options.minTimeout,
        attempt,
        options.multiplier,
        options.jitter
      );
      await new Promise((r) => setTimeout(r, timeout));
    }
    attempt++;
  }
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/extended/stableWebSockets.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
async function createStableWebSocket(connection, events) {
  let socket = void 0;
  let close = false;
  const pooledMessages = [];
  function send(data) {
    pooledMessages.push(data);
  }
  const socketFirstTimeConnected = Promise.withResolvers();
  console.debug(connection.url, "start");
  (async () => {
    try {
      while (!close) {
        await retry(async () => {
          const socketClosed = Promise.withResolvers();
          const websocket = new WebSocket(connection.url, connection.protocol);
          socket = websocket;
          let activePool;
          websocket.addEventListener("open", () => {
            console.debug(connection.url, "connected");
            activePool = setInterval(() => {
              if (pooledMessages.length > 0) {
                websocket.send(pooledMessages.shift());
              }
            }, 10);
            events.onReconnect?.();
            socketFirstTimeConnected.resolve();
          }, { once: true });
          websocket.addEventListener("close", () => {
            console.debug(connection.url, "close");
            clearInterval(activePool);
            socketClosed.reject();
          }, { once: true });
          websocket.addEventListener("error", (error) => {
            console.debug(connection.url, "error", error);
          });
          websocket.addEventListener("message", (message) => {
            events.onMessage?.(message.data);
          });
          await socketClosed.promise;
        });
      }
    } catch (error) {
      console.error("Bad State", error);
    }
  })();
  await socketFirstTimeConnected.promise;
  return {
    send,
    close: () => {
      close = true;
      socket?.close();
    }
  };
}

// esbuild_serve:http-import:https://raw.githubusercontent.com/lucsoft/WebGen/d389a5b/network.ts
function createIndexPaginationLoader(options) {
  let offset = 0;
  let hasMore = true;
  return {
    reset: () => {
      offset = 0;
      hasMore = true;
    },
    next: async () => {
      const items = await options.loader(offset, options.limit + 1);
      hasMore = items.length > options.limit;
      if (hasMore)
        items.pop();
      offset += items.length;
      return { items, hasMore };
    }
  };
}
function createCachedLoader(source) {
  const items = asRef([]);
  const hasMore = asRef(true);
  return {
    items,
    hasMore,
    reset: () => {
      source.reset();
      items.setValue([]);
      hasMore.setValue(true);
    },
    next: async () => {
      const response = await source.next();
      hasMore.setValue(response.hasMore);
      items.setValue([...items.getValue(), ...response.items]);
      return response;
    }
  };
}
function createThrottledPipeline(options) {
  const tasks = createScheduler();
  let nextReset = Date.now();
  let remaining = options.strategy === 0 /* Static */ ? options.throughputPerMinute : 0;
  if (options.strategy === 0 /* Static */)
    setInterval(() => {
      nextReset = Date.now();
      remaining = options.strategy === 0 /* Static */ ? options.throughputPerMinute : 0;
    }, 1 * MINUTE);
  let lastHeader = void 0;
  const throttler = new class ThrottledStream extends TransformStream {
    constructor() {
      super({
        transform: async (task, controller) => {
          const curve = options.curve ?? 1.5;
          if (options.strategy === 1 /* Dynamic */) {
            const headers2 = lastHeader;
            if (headers2) {
              const limit = Number(headers2.get("X-Ratelimit-Limit") ?? headers2.get("X-Rate-Limit-Limit"));
              const remaining2 = Number(headers2.get("X-Ratelimit-Remaining") ?? headers2.get("X-Rate-Limit-Remaining"));
              const reset = Number(headers2.get("X-Ratelimit-Reset") ?? headers2.get("X-Rate-Limit-Reset"));
              assert2(!isNaN(limit) || !isNaN(remaining2) || !isNaN(reset), "Ratelimit headers are not numbers");
              await delay2(Math.pow(1 - remaining2 / limit, curve) * reset * 1e3);
            }
          } else {
            const reset = (Date.now() - nextReset) / 1e3;
            await delay2(Math.pow(1 - remaining / options.throughputPerMinute, curve) * reset * 1e3);
            remaining--;
          }
          controller.enqueue(task);
        }
      });
    }
  }();
  const sourceStream = tasks.scheduler.pipeThrough(throttler);
  pooledMap(
    options.concurrency ?? 1,
    sourceStream,
    async (task) => {
      try {
        const response = await fetch(task.request, {
          mode: options.strategy === 1 /* Dynamic */ ? "no-cors" : "cors"
        });
        task.completed.resolve(response);
        lastHeader = response.headers;
      } catch (error) {
        task.completed.reject(error);
      }
    }
  );
  return {
    fetch: (priority, request) => {
      const completed = Promise.withResolvers();
      const requestObj = typeof request === "string" ? new Request(request) : request;
      tasks.add({
        priority,
        request: requestObj,
        completed
      });
      return completed.promise;
    }
  };
}

// pages/hosting/views/state.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/_common/assert_path.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path2)}`
    );
  }
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/_common/constants.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/_common/strip_trailing_separators.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i4 = segment.length - 1; i4 > 0; i4--) {
    if (isSep(segment.charCodeAt(i4))) {
      end = i4;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/windows/_util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z || code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z;
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/windows/dirname.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/_common/dirname.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function assertArg(path2) {
  assertPath(path2);
  if (path2.length === 0)
    return ".";
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/windows/dirname.ts
function dirname(path2) {
  assertArg(path2);
  const len = path2.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path2.charCodeAt(1))) {
        let j7 = 2;
        let last = j7;
        for (; j7 < len; ++j7) {
          if (isPathSeparator(path2.charCodeAt(j7)))
            break;
        }
        if (j7 < len && j7 !== last) {
          last = j7;
          for (; j7 < len; ++j7) {
            if (!isPathSeparator(path2.charCodeAt(j7)))
              break;
          }
          if (j7 < len && j7 !== last) {
            last = j7;
            for (; j7 < len; ++j7) {
              if (isPathSeparator(path2.charCodeAt(j7)))
                break;
            }
            if (j7 === len) {
              return path2;
            }
            if (j7 !== last) {
              rootEnd = offset = j7 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code)) {
      if (path2.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path2.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code)) {
    return path2;
  }
  for (let i4 = len - 1; i4 >= offset; --i4) {
    if (isPathSeparator(path2.charCodeAt(i4))) {
      if (!matchedSlash) {
        end = i4;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return stripTrailingSeparators(path2.slice(0, end), isPosixPathSeparator);
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/posix/_util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function isPosixPathSeparator2(code) {
  return code === CHAR_FORWARD_SLASH;
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/posix/dirname.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function dirname2(path2) {
  assertArg(path2);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i4 = path2.length - 1; i4 >= 1; --i4) {
    if (isPosixPathSeparator2(path2.charCodeAt(i4))) {
      if (matchedNonSeparator) {
        end = i4;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator2(path2.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(
    path2.slice(0, end),
    isPosixPathSeparator2
  );
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/_os.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var osType = (() => {
  const { Deno: Deno2 } = globalThis;
  if (typeof Deno2?.build?.os === "string") {
    return Deno2.build.os;
  }
  const { navigator: navigator2 } = globalThis;
  if (navigator2?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";

// esbuild_serve:http-import:https://deno.land/std@0.221.0/path/dirname.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function dirname3(path2) {
  return isWindows ? dirname(path2) : dirname2(path2);
}

// pages/hosting/views/state.ts
var currentFiles = asRef([]);
var hostingButtons = asRef([]);
var auditLogs = asRef([]);
var uploadingFiles = asRef({});
var allFiles = refMerge({
  uploadingFiles: uploadingFiles.map(
    (files) => Object.entries(files).filter(([filePath]) => dirname3(filePath) === path.getValue().replace(/\/$/, "")).map(([_path, file2]) => file2)
  ),
  currentFiles: currentFiles.map((it) => {
    const { compare } = new Intl.Collator();
    return Array.from(it).sort((a2, b5) => compare(a2.name, b5.name)).sort((a2, b5) => Number(!!a2.fileMimeType) - Number(!!b5.fileMimeType));
  })
}).map(({ currentFiles: currentFiles2, uploadingFiles: uploadingFiles2 }) => [...uploadingFiles2, ...currentFiles2]);
var path = asRef("");
var loading = asRef(false);
var canWriteInFolder = asRef(false);

// pages/hosting/loading.ts
async function refreshState() {
  state.servers = asState(await API.hosting.servers());
  state.meta = asState(await API.hosting.meta());
}
var liveUpdates = lazyInit(async () => {
  let firstTime = true;
  const connection = await createStableWebSocket({
    url: API.WS_URL
  }, {
    onReconnect: () => {
      firstTime = true;
    },
    onMessage: (msg) => {
      if (typeof msg !== "string")
        return;
      const json2 = JSON.parse(msg);
      if (json2.login === "require authentication") {
        tokens.$accessToken.listen(
          (val) => val && connection.send(JSON.stringify(
            {
              action: "login" /* Login */,
              type: "client",
              token: API.getToken(),
              id: activeUser.id
            }
          ))
        );
      }
      if (json2.login === true && firstTime === true) {
        firstTime = false;
        connection.send(JSON.stringify(
          {
            action: "trigger",
            type: "@bbn/hosting/list",
            auth: {
              token: API.getToken(),
              id: activeUser.id
            },
            data: {
              id: activeUser.id
            }
          }
        ));
      }
      if (json2.type !== "sync") {
        return;
      }
      const { data: { servers: _servers } } = json2.data;
      const servers = JSON.parse(_servers);
      for (const server2 of servers) {
        const index = state.servers.findIndex((x5) => x5._id == server2._id);
        if (index === -1)
          return;
        for (const [key, value] of Object.entries(server2)) {
          state.servers[index][key] = value;
        }
      }
    }
  });
});
var messageQueueSidecar = [];
var isSidecarConnect = asRef(false);
var sidecarDetailsSource = asRef((_data) => {
});
var closeSignal = Promise.withResolvers();
function stopSidecarConnection() {
  closeSignal.resolve();
}
async function startSidecarConnection(id) {
  closeSignal = Promise.withResolvers();
  messageQueueSidecar = [];
  const url2 = new URL(`wss://bbn.one/api/@bbn/sidecar/${id}/ws`);
  url2.searchParams.set("TOKEN", API.getToken());
  const syncedResponses = /* @__PURE__ */ new Set();
  const connection = await createStableWebSocket({
    url: url2.toString()
  }, {
    onMessage: (event) => {
      if (typeof event !== "string")
        return;
      const msg = JSON.parse(event);
      for (const iterator of syncedResponses) {
        if (iterator.request.type === "uninstall-addon" && (msg.type === "uninstall-addon" || msg.type === "error") || iterator.request.type === "install-addons" && (msg.type === "install-addons" || msg.type === "error") || iterator.request.type === "installed-addons" && (msg.type === "installed-addons" || msg.type === "error") || (iterator.request.type === "write" && (msg.type === "next-chunk" || msg.type === "error") || iterator.request.type === "read" && (msg.type === "read" || msg.type === "error") || iterator.request.type === "next-chunk" && (msg.type === "read" || msg.type === "error") || iterator.request.type === "list" && msg.type === "list") && iterator.request.path == msg.path) {
          syncedResponses.delete(iterator);
          iterator.response.resolve(msg);
          break;
        }
      }
      if (msg.type === "state") {
        const index = state.servers.findIndex((x5) => x5._id == id);
        if (index === -1)
          return;
        state.servers[index].state = msg.state;
      }
      sidecarDetailsSource.getValue()?.(msg);
    }
  });
  const watcher = setInterval(() => {
    if (messageQueueSidecar.length == 0)
      return;
    const msg = messageQueueSidecar.shift();
    syncedResponses.add(msg);
    connection.send(JSON.stringify(msg.request));
  }, 100);
  isSidecarConnect.setValue(true);
  await closeSignal.promise;
  connection.close();
  isSidecarConnect.setValue(false);
  clearInterval(watcher);
}
async function listFiles(path2) {
  const response = Promise.withResolvers();
  messageQueueSidecar.push({
    request: {
      type: "list",
      path: path2
    },
    response
  });
  const data = await response.promise;
  if (data.type == "list") {
    canWriteInFolder.setValue(data.canWrite);
    currentFiles.setValue(data.list);
  }
}
function downloadFile(path2) {
  let firstTime = true;
  return new ReadableStream({
    pull: async (controller) => {
      const nextChunk = Promise.withResolvers();
      messageQueueSidecar.push({
        request: {
          type: firstTime ? "read" : "next-chunk",
          path: path2
        },
        response: nextChunk
      });
      const response = await nextChunk.promise;
      if (response.type === "error") {
        controller.error(response.error);
        return;
      }
      if (response.type === "read" && response.chunk) {
        controller.enqueue(decodeBase64(response.chunk));
      }
      if (response.type === "read" && response.finish) {
        controller.close();
      }
      firstTime = false;
    }
  });
}
async function uploadFile(path2, file2, progress) {
  const check = Promise.withResolvers();
  messageQueueSidecar.push({
    request: {
      type: "write",
      path: path2
    },
    response: check
  });
  await check.promise;
  const stream = file2.stream().pipeThrough(ProgressTracker(progress, file2.size));
  for await (const iterator of stream) {
    const nextChunk = Promise.withResolvers();
    messageQueueSidecar.push({
      request: {
        type: "write",
        path: path2,
        chunk: encodeBase64(iterator)
      },
      response: nextChunk
    });
    await nextChunk.promise;
  }
  progress.setValue(100);
}
async function installAddon(addons) {
  const response = Promise.withResolvers();
  messageQueueSidecar.push({
    request: {
      type: "install-addons",
      addons
    },
    response
  });
  const data = await response.promise;
  if (data.type == "install-addons") {
    return data.success;
  }
  return false;
}
async function uninstallAddon(projectId) {
  const response = Promise.withResolvers();
  messageQueueSidecar.push({
    request: {
      type: "uninstall-addon",
      projectId
    },
    response
  });
  const data = await response.promise;
  if (data.type == "uninstall-addon") {
    return data.success;
  }
  return false;
}

// pages/hosting/views/menu.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/uptime.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var SECOND2 = 1e3;
var MINUTE2 = 60 * SECOND2;
var HOUR2 = 60 * MINUTE2;
var DAY2 = 24 * HOUR2;
function formatTime(duration) {
  if (duration < 5 * SECOND2) {
    return "now";
  } else if (duration < MINUTE2) {
    return `${Math.floor(duration / SECOND2)}s`;
  } else if (duration < 20 * MINUTE2) {
    const minutes = Math.floor(duration / MINUTE2);
    const seconds = Math.floor(duration % MINUTE2 / SECOND2);
    return `${minutes}min ${seconds}s`;
  } else if (duration < HOUR2) {
    return `${Math.floor(duration / MINUTE2)}min`;
  } else if (duration < 72 * HOUR2) {
    return `${Math.floor(duration / HOUR2)}h`;
  } else {
    const days = Math.floor(duration / DAY2);
    const hours = Math.floor(duration % DAY2 / HOUR2);
    return `${days}d ${hours}h`;
  }
}
function calculateUptime(startDate) {
  const duration = (/* @__PURE__ */ new Date()).getTime() - startDate.getTime();
  return formatTime(duration);
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/debounce.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function debounce(fn2, wait) {
  let timeout = null;
  let flush = null;
  const debounced = (...args) => {
    debounced.clear();
    flush = () => {
      debounced.clear();
      fn2.call(debounced, ...args);
    };
    timeout = setTimeout(flush, wait);
  };
  debounced.clear = () => {
    if (typeof timeout === "number") {
      clearTimeout(timeout);
      timeout = null;
      flush = null;
    }
  };
  debounced.flush = () => {
    flush?.();
  };
  Object.defineProperty(debounced, "pending", {
    get: () => typeof timeout === "number"
  });
  return debounced;
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/datetime/constants.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var SECOND3 = 1e3;
var MINUTE3 = SECOND3 * 60;
var HOUR3 = MINUTE3 * 60;
var DAY3 = HOUR3 * 24;
var WEEK2 = DAY3 * 7;

// data/locations.json
var locations_default = {
  "bbn-fsn": "\u{1F1E9}\u{1F1EA} Falkenstein (Free) (Medium Load)",
  "bbn-hel": "\u{1F1EB}\u{1F1EE} Helsinki (Free) (Low Load)",
  "bbn-mum": "\u{1F1EE}\u{1F1F3} Mumbai (Free) (High Load)",
  "bbn-sgp": "\u{1F1F8}\u{1F1EC} Singapore (Free) (High Load)"
};

// data/servers.json
var servers_default = {
  "/minecraft/vanilla/": {
    name: "Minecraft Vanilla"
  },
  "/minecraft/default/": {
    name: "Minecraft"
  },
  "/minecraft/paper/": {
    name: "Minecraft (Paper)"
  },
  "/minecraft/modded/fabric/": {
    name: "Minecraft Fabric"
  },
  "/minecraft/modded/forge/": {
    name: "Minecraft Forge"
  },
  "/minecraft/bedrock/": {
    name: "Minecraft Bedrock"
  },
  "/minecraft/pocketmine/": {
    name: "Pocketmine MP"
  }
};

// pages/hosting/dialogs/deleteServerDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
init_restSpec();
var deleteServerDialog = (serverId) => {
  const sheet = SheetDialog(
    sheetStack,
    "Delete Server",
    Grid(
      Label("Deleting this Server will result in data loss.\nAfter this point there is no going back."),
      Grid(
        Button("Cancel").setStyle("inline" /* Inline */).onClick(() => sheet.close()),
        Button("Delete").setColor("critical" /* Critical */).onPromiseClick(async () => {
          await API.hosting.serverId(serverId).delete().then(stupidErrorAlert);
          location.href = "/hosting";
        })
      ).setGap(".5rem").setJustifyItems("end").setRawColumns("auto max-content")
    ).setGap()
  );
  return sheet;
};

// pages/hosting/dialogs/editServerDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
init_restSpec();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/fmt/bytes.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function format(num, options = {}) {
  if (!Number.isFinite(num)) {
    throw new TypeError(`Expected a finite number, got ${typeof num}: ${num}`);
  }
  const UNITS_FIRSTLETTER = (options.bits ? "b" : "B") + "kMGTPEZY";
  if (options.signed && num === 0) {
    return ` 0 ${UNITS_FIRSTLETTER[0]}`;
  }
  const prefix = num < 0 ? "-" : options.signed ? "+" : "";
  num = Math.abs(num);
  const localeOptions = getLocaleOptions(options);
  if (num < 1) {
    const numberString2 = toLocaleString(num, options.locale, localeOptions);
    return prefix + numberString2 + " " + UNITS_FIRSTLETTER[0];
  }
  const exponent = Math.min(
    Math.floor(
      options.binary ? Math.log(num) / Math.log(1024) : Math.log10(num) / 3
    ),
    UNITS_FIRSTLETTER.length - 1
  );
  num /= Math.pow(options.binary ? 1024 : 1e3, exponent);
  if (!localeOptions) {
    num = Number(num.toPrecision(3));
  }
  const numberString = toLocaleString(
    num,
    options.locale,
    localeOptions
  );
  let unit = UNITS_FIRSTLETTER[exponent];
  if (exponent > 0) {
    unit += options.binary ? "i" : "";
    unit += options.bits ? "bit" : "B";
  }
  return prefix + numberString + " " + unit;
}
function getLocaleOptions({ maximumFractionDigits, minimumFractionDigits }) {
  if (maximumFractionDigits || minimumFractionDigits) {
    return {
      maximumFractionDigits,
      minimumFractionDigits
    };
  }
}
function toLocaleString(num, locale, options) {
  if (typeof locale === "string" || Array.isArray(locale)) {
    return num.toLocaleString(locale, options);
  } else if (locale === true || options !== void 0) {
    return num.toLocaleString(void 0, options);
  }
  return num.toString();
}

// pages/hosting/dialogs/editServerDialog.ts
var editServerDialog = (server2, versions) => {
  const data = asState({
    name: server2.name,
    memory: server2.limits.memory,
    disk: server2.limits.disk,
    cpu: server2.limits.cpu,
    location: server2.location,
    version: server2.version
  });
  const sheet = SheetDialog(
    sheetStack,
    `Edit '${server2.name}'`,
    Grid(
      Label(`A ${servers_default[server2.type].name} Server.`),
      MediaQuery("(max-width: 700px)", (small) => Grid(
        [
          {
            width: small ? 1 : 2
          },
          TextInput("text", "Friendly Name").sync(data, "name")
        ],
        DropDownInput("Location", Object.keys(locations_default)).setRender((location3) => locations_default[location3]).sync(data, "location"),
        SliderInput("Memory (RAM)").setMin(1).setMax(state.meta.limits.memory - state.meta.used.memory + server2.limits.memory).sync(data, "memory").setRender((val) => format(val * MB)),
        SliderInput("Disk (Storage)").setMin(server2.limits.disk).setMax(state.meta.limits.disk - state.meta.used.disk + server2.limits.disk).sync(data, "disk").setRender((val) => format(val * MB)),
        SliderInput("CPU (Processor)").setMin(1).setMax(state.meta.limits.cpu - state.meta.used.cpu + server2.limits.cpu).sync(data, "cpu").setRender((val) => `${val.toString()} %`),
        DropDownInput("Version", versions).sync(data, "version")
      ).setGap().setEvenColumns(small ? 1 : 3)).removeFromLayout(),
      Grid(
        Button("Close").setStyle("inline" /* Inline */).onClick(() => sheet.close()),
        Button("Save").setColor("critical" /* Critical */).onPromiseClick(async () => {
          await API.hosting.serverId(server2._id).edit(data).then(stupidErrorAlert);
          location.reload();
        })
      ).setGap(".5rem").setJustifyItems("end").setRawColumns("auto max-content")
    ).setGap()
  );
  return sheet;
};

// pages/hosting/dialogs/forceRestartDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
init_restSpec();
var forceRestartDialog = (serverId) => {
  const sheet = SheetDialog(
    sheetStack,
    "Hard Restart",
    Grid(
      Label("Hard Restarting the Server could lead to data loss depending on the State of the Server. Use at your own risk."),
      Grid(
        Button("Cancel").setStyle("inline" /* Inline */).onClick(() => sheet.close()),
        Button("Hard Restart").setColor("critical" /* Critical */).onPromiseClick(async () => {
          await API.hosting.serverId(serverId).forcerestart().then(stupidErrorAlert);
          location.reload();
        })
      ).setGap(".5rem").setJustifyItems("end").setRawColumns("auto max-content")
    ).setGap()
  );
  return sheet;
};

// pages/hosting/modrinth.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/mod.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/retry.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/_util.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function exponentialBackoffWithJitter2(cap, base, attempt, multiplier, jitter) {
  const exp = Math.min(cap, base * multiplier ** attempt);
  return (1 - jitter * Math.random()) * exp;
}

// esbuild_serve:http-import:https://deno.land/std@0.221.0/async/retry.ts
var RetryError2 = class extends Error {
  /**
   * Constructs a new {@linkcode RetryError} instance.
   *
   * @example
   * ```ts
   * import { RetryError } from "https://deno.land/std@$STD_VERSION/async/retry.ts";
   *
   * throw new RetryError({ foo: "bar" }, 3);
   * ```
   */
  constructor(cause, attempts) {
    super(`Retrying exceeded the maxAttempts (${attempts}).`);
    this.name = "RetryError";
    this.cause = cause;
  }
};
var defaultRetryOptions2 = {
  multiplier: 2,
  maxTimeout: 6e4,
  maxAttempts: 5,
  minTimeout: 1e3,
  jitter: 1
};
async function retry2(fn2, opts) {
  const options = {
    ...defaultRetryOptions2,
    ...opts
  };
  assert(options.maxTimeout >= 0, "maxTimeout is less than 0");
  assert(
    options.minTimeout <= options.maxTimeout,
    "minTimeout is greater than maxTimeout"
  );
  assert(options.jitter <= 1, "jitter is greater than 1");
  let attempt = 0;
  while (true) {
    try {
      return await fn2();
    } catch (error) {
      if (attempt + 1 >= options.maxAttempts) {
        throw new RetryError2(error, options.maxAttempts);
      }
      const timeout = exponentialBackoffWithJitter2(
        options.maxTimeout,
        options.minTimeout,
        attempt,
        options.multiplier,
        options.jitter
      );
      await new Promise((r) => setTimeout(r, timeout));
    }
    attempt++;
  }
}

// pages/hosting/modrinth.ts
var apiUrl = "https://api.modrinth.com/v2";
var ServerTypeToModrinthTypeMap = {
  ["/minecraft/default/" /* Default */]: ["bukkit", "spigot", "paper", "purpur", "folia"],
  ["/minecraft/modded/fabric/" /* Fabric */]: ["fabric"],
  ["/minecraft/modded/forge/" /* Forge */]: ["forge"]
};
var pipeline = createThrottledPipeline({
  strategy: 0 /* Static */,
  throughputPerMinute: 300,
  curve: 5,
  concurrency: 5
});
async function find(versions, type, offset = 0, limit = 21, query = "") {
  const path2 = new URL(`${apiUrl}/search`);
  path2.searchParams.set("index", "relevance");
  path2.searchParams.set("query", query);
  if (!Object.keys(ServerTypeToModrinthTypeMap).includes(type))
    throw new Error("Invalid server type");
  path2.searchParams.set(
    "facets",
    JSON.stringify([
      ServerTypeToModrinthTypeMap[type].map((v5) => `categories:${v5}`),
      ["project_type:mod"],
      versions.map((version) => "versions:" + version),
      ["server_side:required", "server_side:optional"]
    ])
  );
  path2.searchParams.set("limit", limit.toString());
  path2.searchParams.set("offset", offset.toString());
  const json2 = await retry2(async () => {
    const response = await pipeline.fetch(0 /* High */, path2.toString());
    assert(response.ok);
    return response.json();
  });
  return json2.hits;
}
var downloadCache = /* @__PURE__ */ new Map();
async function getLatestDownload(versions, type, projectid) {
  if (downloadCache.has(`${apiUrl}/project/${projectid}/version`)) {
    return downloadCache.get(`${apiUrl}/project/${projectid}/version`);
  }
  const path2 = new URL(`${apiUrl}/project/${projectid}/version`);
  path2.searchParams.set("loaders", JSON.stringify(ServerTypeToModrinthTypeMap[type]));
  path2.searchParams.set("game_versions", JSON.stringify(versions));
  const json2 = await retry2(async () => {
    const response2 = await pipeline.fetch(2 /* Low */, path2.toString());
    assert(response2.ok);
    return response2.json();
  });
  const response = json2[0];
  downloadCache.set(`${apiUrl}/project/${projectid}/version`, response);
  return response;
}
async function getSpecificDownload(versionId) {
  const path2 = new URL(`${apiUrl}/version/${versionId}`);
  const json2 = await retry2(async () => {
    const response = await pipeline.fetch(0 /* High */, path2.toString());
    assert(response.ok);
    return response.json();
  });
  return json2;
}
async function collectDownloadList(versions, type, projectid, versionId) {
  const download = versionId ? await getSpecificDownload(versionId) : await getLatestDownload(versions, type, projectid);
  if (!download)
    return [];
  return [
    {
      projectId: download.project_id,
      versionId: download.id
    },
    ...await Promise.all(
      download.dependencies.filter((v5) => v5.dependency_type === "required").map((v5) => collectDownloadList(versions, type, v5.project_id, v5.version_id ?? void 0))
    )
  ].flat();
}
async function getRealFiltered(versions, type, offset, limit, query = "") {
  const projects = await find(versions, type, offset, limit, query);
  return projects.map((project) => ({
    ...project,
    download: getLatestDownload(versions, type, project.project_id)
  }));
}

// pages/hosting/translation.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var labels = {
  suspended: "Suspended",
  "contact-support": "Contact Support",
  maintenance: "Maintenance",
  disabled: "Disabled"
};
var auditLabels = {
  "server-create": "Server Created",
  "server-delete": "Server Deleted",
  "server-modify": "Server Specs Updated",
  "server-power-change": "Power changed to $powerChange",
  "store-purchase": "Purchased $storeItem in store",
  "file-upload": "File Uploaded",
  "file-delete": "File Deleted",
  "file-read": "File Read",
  "command-execute": "Command Executed",
  "reset-password": "Reset Password",
  "drop-review": "Drop Review",
  "drop-type-change": "Drop Type Change",
  "drop-create": "Drop Created",
  "oauth-validate": "OAuth Validation",
  "oauth-authorize": "OAuth Authorization"
};

// pages/hosting/views/profile.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/libs/canvasConfetti.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var import_confetti = __toESM(require_confetti());
function confettiFromElement(element) {
  const { top, height, left, width } = element.target.getBoundingClientRect();
  const x5 = (left + width / 2) / globalThis.innerWidth;
  const y5 = (top + height / 2) / globalThis.innerHeight;
  const origin = { x: x5, y: y5 };
  (0, import_confetti.default)({ origin });
}

// pages/hosting/views/profile.ts
var profileView = () => MediaQuery("(max-width: 700px)", (small) => state.$meta.map(
  (meta2) => Grid(
    Entry(
      Grid(
        Label(meta2.coins.toLocaleString()).setTextSize("4xl").setFontWeight("bold"),
        Label("Coins").setFontWeight("bold").addClass("gray-color")
      ).addClass("details-item")
    ).addClass("full-width"),
    Box(
      Entry(
        Grid(
          Label(`${meta2.used.slots} / ${meta2.limits.slots}`).setTextSize("4xl").setFontWeight("bold"),
          Label("Servers").setFontWeight("bold").addClass("gray-color")
        ).addClass("details-item")
      ).addClass("docked"),
      meta2.pricing.slots ? ShopStack(meta2.pricing.slots.price > meta2.coins ? "Not enough Coins" : "Upgrade available", {
        type: meta2.pricing.slots.price > meta2.coins ? "blocked" : "available",
        label: `Add x${meta2.pricing.slots.amount} Servers`,
        sublabel: `Requires ${meta2.pricing.slots.price} Coins`,
        action: async (ev) => {
          await API.hosting.store.create("slots").then(stupidErrorAlert);
          confettiFromElement(ev);
          refreshState();
        }
      }) : Empty()
    ).addClass("shop"),
    Box(
      Entry(
        Grid(
          Label(`${format(meta2.used.memory * MB)} / ${format(meta2.limits.memory * MB)}`).setTextSize("4xl").setFontWeight("bold"),
          Label("Memory").setFontWeight("bold").addClass("gray-color")
        ).addClass("details-item")
      ).addClass("docked"),
      meta2.pricing.memory ? ShopStack(meta2.pricing.memory.price > meta2.coins ? "Not enough Coins" : "Upgrade available", {
        type: meta2.pricing.memory.price > meta2.coins ? "blocked" : "available",
        label: `Add ${format((meta2.pricing.memory.amount ?? 0) * MB)}`,
        sublabel: `Requires ${meta2.pricing.memory.price} Coins`,
        action: async (ev) => {
          await API.hosting.store.create("memory").then(stupidErrorAlert);
          confettiFromElement(ev);
          refreshState();
        }
      }) : Empty()
    ).addClass("shop"),
    Box(
      Entry(
        Grid(
          Label(`${format(meta2.used.disk * MB)} / ${format(meta2.limits.disk * MB)}`).setTextSize("4xl").setFontWeight("bold"),
          Label("Disk").setFontWeight("bold").addClass("gray-color")
        ).addClass("details-item")
      ).addClass("docked"),
      meta2.pricing.disk ? ShopStack(meta2.pricing.disk.price > meta2.coins ? "Not enough Coins" : "Upgrade available", {
        type: meta2.pricing.disk.price > meta2.coins ? "blocked" : "available",
        label: `Add ${format(meta2.pricing.disk.amount * MB)}`,
        sublabel: `Requires ${meta2.pricing.disk.price} Coins`,
        action: async (ev) => {
          await API.hosting.store.create("disk").then(stupidErrorAlert);
          confettiFromElement(ev);
          refreshState();
        }
      }) : Empty()
    ).addClass("shop"),
    Box(
      Entry(
        Grid(
          Label(`${meta2.used.cpu}% / ${meta2.limits.cpu}%`).setTextSize("4xl").setFontWeight("bold"),
          Label("CPU").setFontWeight("bold").addClass("gray-color")
        ).addClass("details-item")
      ).addClass("docked"),
      meta2.pricing.cpu ? ShopStack(meta2.pricing.cpu.price > meta2.coins ? "Not enough Coins" : "Upgrade available", {
        type: meta2.pricing.cpu.price > meta2.coins ? "blocked" : "available",
        label: `Add ${meta2.pricing.cpu.amount} %`,
        sublabel: `Requires ${meta2.pricing.cpu.price} Coins`,
        action: async (ev) => {
          await API.hosting.store.create("cpu").then(stupidErrorAlert);
          confettiFromElement(ev);
          refreshState();
        }
      }) : Empty()
    ).addClass("shop")
  ).setEvenColumns(small ? 1 : 2).setGap().addClass("details-grid")
).asRefComponent());
var ShopStack = (actionText, variant) => Grid(
  Label(actionText),
  Vertical(
    variant.type == "blocked" ? null : Button(variant.label).setStyle("secondary" /* Secondary */).setColor("colored" /* Colored */).onPromiseClick(variant.action),
    Label(variant.sublabel).addClass("sublabel")
  ).addClass("group")
).addClass(variant.type, "shop-stack");

// pages/hosting/views/changeStateButton.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function ChangeStateButton(server2) {
  return server2.$state.map((state2) => ({
    "offline": IconButton(MIcon("play_arrow"), "delete").addClass("color-green").setColor("colored" /* Colored */).onClick((e) => {
      e.stopPropagation();
      API.hosting.serverId(server2._id).start();
      startSidecarConnection(server2._id);
      const response = Promise.withResolvers();
      messageQueueSidecar.push({
        request: {
          type: "state",
          state: "start"
        },
        response
        // Maybe we can use this to show a different loading spinner until the server is starting
      });
    }),
    // TODO: make this better (labels or something)
    "installing": LoadingSpinner(),
    "stopping": LoadingSpinner(),
    "starting": LoadingSpinner(),
    "running": IconButton(MIcon("stop"), "delete").setColor("critical" /* Critical */).onClick((e) => {
      e.stopPropagation();
      server2.state = "stopping";
      startSidecarConnection(server2._id);
      const response = Promise.withResolvers();
      messageQueueSidecar.push({
        request: {
          type: "state",
          state: "stop"
        },
        response
      });
    })
  })[state2] ?? Box()).asRefComponent().addClass(isMobile.map((it) => it ? "small" : "normal"), "icon-buttons-list", "action-list");
}

// pages/hosting/views/FileBrowser.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/shared/fileTypeName.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function fileTypeName(fileType) {
  const mimeType = fileType.split(";").at(0);
  if (!mimeType)
    return `${fileType} File`;
  if (mimeType === "application/octet-stream") {
    return "Binary File";
  }
  return `${mimeType.split("/").at(-1)?.toLocaleUpperCase()} Document`;
}

// pages/shared/libs/streamSaver.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var import_StreamSaver_min = __toESM(require_StreamSaver_min());
import_StreamSaver_min.default.mitm = "/mitm.html";
var createDownloadStream = import_StreamSaver_min.default.createWriteStream;

// pages/hosting/constants.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var fileNameIncludes = {
  "world": "globe2",
  "world_nether": "globe2",
  "world_the_end": "globe2",
  "logs": "body-text",
  "plugins": "plug",
  "mods": "box-seam",
  "config": "gear"
};
var supportedFiletypes = [
  "aac",
  "ai",
  "bmp",
  "cs",
  "css",
  "csv",
  "doc",
  "docx",
  "exe",
  "gif",
  "heic",
  "html",
  "java",
  "jpg",
  "js",
  "json",
  "jsx",
  "key",
  "m4p",
  "md",
  "mdx",
  "mov",
  "mp3",
  "mp4",
  "otf",
  "pdf",
  "php",
  "png",
  "ppt",
  "pptx",
  "psd",
  "py",
  "raw",
  "rb",
  "sass",
  "scss",
  "sh",
  "sql",
  "svg",
  "tiff",
  "tsx",
  "ttf",
  "txt",
  "wav",
  "woff",
  "xls",
  "xlsx",
  "xml",
  "yml"
];
var otherFiletypes = {
  "zip": "archive",
  "tar": "archive",
  "gz": "archive",
  "7z": "archive",
  "rar": "archive",
  "yaml": "filetype-yml",
  "jar": "filetype-java"
};
function mapFiletoIcon(file2) {
  if (!file2.fileMimeType) {
    return fileNameIncludes[file2.name] ?? "folder";
  }
  const filetype = file2.name.split(".").at(-1);
  if (!filetype)
    return "file-earmark";
  if (supportedFiletypes.includes(filetype)) {
    return `filetype-${filetype}`;
  }
  if (otherFiletypes[filetype]) {
    return otherFiletypes[filetype];
  }
  return "file-earmark";
}

// pages/hosting/dialogs/deleteFileDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function deleteFileDialog() {
  const response = Promise.withResolvers();
  const dialog = SheetDialog(
    sheetStack,
    "Are you sure?",
    Vertical(
      Box(Label("Deleting this File will result in data loss.\nAfter this point there is no going back.")).setMargin("0 0 1.5rem")
    ),
    Grid(
      Button("Cancel").onClick(() => dialog.close()),
      Button("Delete").onClick(() => {
        response.resolve(true);
        dialog.close();
      }).setColor("critical" /* Critical */)
    ).setGap(".5rem").setJustifyItems("end").setRawColumns("auto max-content")
  );
  dialog.setOnClose(() => response.resolve(false));
  dialog.open();
  return response.promise;
}

// pages/hosting/dialogs/editFileDialog.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/@monaco-editor/loader@1.4.0
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/v135/state-local@1.0.7/denonext/state-local.mjs
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function O4(e, t, n3) {
  return t in e ? Object.defineProperty(e, t, { value: n3, enumerable: true, configurable: true, writable: true }) : e[t] = n3, e;
}
function g2(e, t) {
  var n3 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i4) {
      return Object.getOwnPropertyDescriptor(e, i4).enumerable;
    })), n3.push.apply(n3, r);
  }
  return n3;
}
function v3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n3 = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g2(Object(n3), true).forEach(function(r) {
      O4(e, r, n3[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n3)) : g2(Object(n3)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n3, r));
    });
  }
  return e;
}
function y3() {
  for (var e = arguments.length, t = new Array(e), n3 = 0; n3 < e; n3++)
    t[n3] = arguments[n3];
  return function(r) {
    return t.reduceRight(function(i4, a2) {
      return a2(i4);
    }, r);
  };
}
function c2(e) {
  return function t() {
    for (var n3 = this, r = arguments.length, i4 = new Array(r), a2 = 0; a2 < r; a2++)
      i4[a2] = arguments[a2];
    return i4.length >= e.length ? e.apply(this, i4) : function() {
      for (var f4 = arguments.length, s2 = new Array(f4), o3 = 0; o3 < f4; o3++)
        s2[o3] = arguments[o3];
      return t.apply(n3, [].concat(i4, s2));
    };
  };
}
function h3(e) {
  return {}.toString.call(e).includes("Object");
}
function m3(e) {
  return !Object.keys(e).length;
}
function l2(e) {
  return typeof e == "function";
}
function j4(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function w2(e, t) {
  return h3(t) || u("changeType"), Object.keys(t).some(function(n3) {
    return !j4(e, n3);
  }) && u("changeField"), t;
}
function P4(e) {
  l2(e) || u("selectorType");
}
function T4(e) {
  l2(e) || h3(e) || u("handlerType"), h3(e) && Object.values(e).some(function(t) {
    return !l2(t);
  }) && u("handlersType");
}
function S3(e) {
  e || u("initialIsRequired"), h3(e) || u("initialType"), m3(e) && u("initialContent");
}
function E3(e, t) {
  throw new Error(e[t] || e.default);
}
var D3 = { initialIsRequired: "initial state is required", initialType: "initial state should be an object", initialContent: "initial state shouldn't be an empty object", handlerType: "handler should be an object or a function", handlersType: "all handlers should be a functions", selectorType: "selector should be a function", changeType: "provided value of changes should be an object", changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state', default: "an unknown error accured in `state-local` package" };
var u = c2(E3)(D3);
var p3 = { changes: w2, selector: P4, handler: T4, initial: S3 };
function q4(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  p3.initial(e), p3.handler(t);
  var n3 = { current: e }, r = c2(I4)(n3, t), i4 = c2(F4)(n3), a2 = c2(p3.changes)(e), f4 = c2(C3)(n3);
  function s2() {
    var d5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(b5) {
      return b5;
    };
    return p3.selector(d5), d5(n3.current);
  }
  function o3(d5) {
    y3(r, i4, a2, f4)(d5);
  }
  return [s2, o3];
}
function C3(e, t) {
  return l2(t) ? t(e.current) : t;
}
function F4(e, t) {
  return e.current = v3(v3({}, e.current), t), t;
}
function I4(e, t, n3) {
  return l2(t) ? t(e.current) : Object.keys(n3).forEach(function(r) {
    var i4;
    return (i4 = t[r]) === null || i4 === void 0 ? void 0 : i4.call(t, e.current[r]);
  }), n3;
}
var R2 = { create: q4 };
var x2 = R2;

// esbuild_serve:http-import:https://esm.sh/v135/@monaco-editor/loader@1.4.0/denonext/loader.mjs
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function E4(r, e, t) {
  return e in r ? Object.defineProperty(r, e, { value: t, enumerable: true, configurable: true, writable: true }) : r[e] = t, r;
}
function d3(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(r);
    e && (n3 = n3.filter(function(o3) {
      return Object.getOwnPropertyDescriptor(r, o3).enumerable;
    })), t.push.apply(t, n3);
  }
  return t;
}
function p4(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? d3(Object(t), true).forEach(function(n3) {
      E4(r, n3, t[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : d3(Object(t)).forEach(function(n3) {
      Object.defineProperty(r, n3, Object.getOwnPropertyDescriptor(t, n3));
    });
  }
  return r;
}
function C4(r, e) {
  if (r == null)
    return {};
  var t = {}, n3 = Object.keys(r), o3, i4;
  for (i4 = 0; i4 < n3.length; i4++)
    o3 = n3[i4], !(e.indexOf(o3) >= 0) && (t[o3] = r[o3]);
  return t;
}
function v4(r, e) {
  if (r == null)
    return {};
  var t = C4(r, e), n3, o3;
  if (Object.getOwnPropertySymbols) {
    var i4 = Object.getOwnPropertySymbols(r);
    for (o3 = 0; o3 < i4.length; o3++)
      n3 = i4[o3], !(e.indexOf(n3) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n3) && (t[n3] = r[n3]);
  }
  return t;
}
function b3(r, e) {
  return L4(r) || W4(r, e) || _3(r, e) || z3();
}
function L4(r) {
  if (Array.isArray(r))
    return r;
}
function W4(r, e) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(r)))) {
    var t = [], n3 = true, o3 = false, i4 = void 0;
    try {
      for (var a2 = r[Symbol.iterator](), u3; !(n3 = (u3 = a2.next()).done) && (t.push(u3.value), !(e && t.length === e)); n3 = true)
        ;
    } catch (c3) {
      o3 = true, i4 = c3;
    } finally {
      try {
        !n3 && a2.return != null && a2.return();
      } finally {
        if (o3)
          throw i4;
      }
    }
    return t;
  }
}
function _3(r, e) {
  if (r) {
    if (typeof r == "string")
      return g3(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set")
      return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return g3(r, e);
  }
}
function g3(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n3 = new Array(e); t < e; t++)
    n3[t] = r[t];
  return n3;
}
function z3() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var D4 = { paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs" } };
var y4 = D4;
function M3(r) {
  return function e() {
    for (var t = this, n3 = arguments.length, o3 = new Array(n3), i4 = 0; i4 < n3; i4++)
      o3[i4] = arguments[i4];
    return o3.length >= r.length ? r.apply(this, o3) : function() {
      for (var a2 = arguments.length, u3 = new Array(a2), c3 = 0; c3 < a2; c3++)
        u3[c3] = arguments[c3];
      return e.apply(t, [].concat(o3, u3));
    };
  };
}
var h4 = M3;
function q5(r) {
  return {}.toString.call(r).includes("Object");
}
var j5 = q5;
function R3(r) {
  return r || w3("configIsRequired"), j5(r) || w3("configType"), r.urls ? ($4(), { paths: { vs: r.urls.monacoBase } }) : r;
}
function $4() {
  console.warn(O5.deprecation);
}
function H3(r, e) {
  throw new Error(r[e] || r.default);
}
var O5 = { configIsRequired: "the configuration object is required", configType: "the configuration object should be an object", default: "an unknown error accured in `@monaco-editor/loader` package", deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  ` };
var w3 = h4(H3)(O5);
var B3 = { config: R3 };
var P5 = B3;
var N4 = function() {
  for (var e = arguments.length, t = new Array(e), n3 = 0; n3 < e; n3++)
    t[n3] = arguments[n3];
  return function(o3) {
    return t.reduceRight(function(i4, a2) {
      return a2(i4);
    }, o3);
  };
};
var A3 = N4;
function S4(r, e) {
  return Object.keys(e).forEach(function(t) {
    e[t] instanceof Object && r[t] && Object.assign(e[t], S4(r[t], e[t]));
  }), p4(p4({}, r), e);
}
var I5 = S4;
var F5 = { type: "cancelation", msg: "operation is manually canceled" };
function G4(r) {
  var e = false, t = new Promise(function(n3, o3) {
    r.then(function(i4) {
      return e ? o3(F5) : n3(i4);
    }), r.catch(o3);
  });
  return t.cancel = function() {
    return e = true;
  }, t;
}
var s = G4;
var U3 = x2.create({ config: y4, isInitialized: false, resolve: null, reject: null, monaco: null });
var T5 = b3(U3, 2);
var f2 = T5[0];
var l3 = T5[1];
function Y4(r) {
  var e = P5.config(r), t = e.monaco, n3 = v4(e, ["monaco"]);
  l3(function(o3) {
    return { config: I5(o3.config, n3), monaco: t };
  });
}
function J4() {
  var r = f2(function(e) {
    var t = e.monaco, n3 = e.isInitialized, o3 = e.resolve;
    return { monaco: t, isInitialized: n3, resolve: o3 };
  });
  if (!r.isInitialized) {
    if (l3({ isInitialized: true }), r.monaco)
      return r.resolve(r.monaco), s(m4);
    if (window.monaco && window.monaco.editor)
      return x3(window.monaco), r.resolve(window.monaco), s(m4);
    A3(Q4, X4)(Z4);
  }
  return s(m4);
}
function Q4(r) {
  return document.body.appendChild(r);
}
function V4(r) {
  var e = document.createElement("script");
  return r && (e.src = r), e;
}
function X4(r) {
  var e = f2(function(n3) {
    var o3 = n3.config, i4 = n3.reject;
    return { config: o3, reject: i4 };
  }), t = V4("".concat(e.config.paths.vs, "/loader.js"));
  return t.onload = function() {
    return r();
  }, t.onerror = e.reject, t;
}
function Z4() {
  var r = f2(function(t) {
    var n3 = t.config, o3 = t.resolve, i4 = t.reject;
    return { config: n3, resolve: o3, reject: i4 };
  }), e = window.require;
  e.config(r.config), e(["vs/editor/editor.main"], function(t) {
    x3(t), r.resolve(t);
  }, function(t) {
    r.reject(t);
  });
}
function x3(r) {
  f2().monaco || l3({ monaco: r });
}
function k3() {
  return f2(function(r) {
    var e = r.monaco;
    return e;
  });
}
var m4 = new Promise(function(r, e) {
  return l3({ resolve: r, reject: e });
});
var rr2 = { config: Y4, init: J4, __getMonacoInstance: k3 };
var er2 = rr2;

// pages/hosting/dialogs/editFileDialog.ts
var lazyMonaco = lazyInit(() => er2.init());
var editFileLanguage = asRef("yaml");
var editFilestreamingText = asRef(new Response("Loading file...").body?.pipeThrough(new TextDecoderStream()));
var editFileDownloading = asRef(true);
var editFileUploading = asRef(false);
var editFileReadOnly = asRef(false);
var editFilePath = asRef("");
var editFileCurrentEditor = asRef(void 0);
async function createMonacoEditor() {
  const monaco = await lazyMonaco();
  const box = document.createElement("div");
  const editor = monaco.editor.create(box, {
    value: "",
    language: "yaml",
    theme: "vs-dark",
    automaticLayout: true
  });
  editFileLanguage.listen((lang) => {
    monaco.editor.setModelLanguage(editor.getModel(), lang);
  });
  editFilestreamingText.listen(async (streamingText) => {
    editFileDownloading.setValue(true);
    editor.setValue("");
    for await (const iterator of streamingText) {
      editor.setValue(editor.getValue() + iterator);
    }
    editFileDownloading.setValue(false);
  });
  editFileDownloading.listen((downloading) => {
    editor.updateOptions({
      readOnly: downloading || editFileReadOnly.getValue()
    });
  });
  editFileUploading.listen((uploading) => {
    editor.updateOptions({
      readOnly: uploading || editFileReadOnly.getValue()
    });
  });
  editFileCurrentEditor.setValue(editor);
  return Custom(box).addClass("file-dialog-shell");
}
var editFileDialog = SheetDialog(
  sheetStack,
  editFileReadOnly.map((readOnly) => readOnly ? "Read File" : "Edit File"),
  Vertical(
    refMerge({
      downloading: editFileDownloading,
      uploading: editFileUploading
    }).map(
      ({ downloading, uploading }) => (() => {
        if (downloading) {
          return Box(
            MIcon("cloud_download"),
            Label("Your file is currently downloading...")
          ).addClass("file-is-downloading");
        }
        if (uploading) {
          return Box(
            MIcon("cloud_upload"),
            Label("Your file is currently uploading...")
          ).addClass("file-is-downloading");
        }
        return Box(
          MIcon("cloud_done"),
          Label("Your file is up to date")
        ).addClass("file-is-downloading");
      })()
    ).asRefComponent(),
    Cache("monaco-editor", () => createMonacoEditor(), (type, data) => type === "cache" ? Label("Loading Editor") : data ?? Box()),
    Grid(
      Button("Cancel").onClick(() => editFileDialog.close()),
      Button("Save").onPromiseClick(async () => {
        if (editFileReadOnly.getValue()) {
          return;
        }
        if (editFileDownloading.getValue()) {
          return alert("File is still downloading");
        }
        editFileUploading.setValue(true);
        const editor = editFileCurrentEditor.getValue();
        await uploadFile(
          editFilePath.getValue(),
          new File([editor.getValue()], editFilePath.getValue()),
          asRef(0)
        );
        editFileUploading.setValue(false);
        await delay(300);
        editFileDialog.close();
      }).setColor(editFileReadOnly.map((readOnly) => readOnly ? "disabled" /* Disabled */ : "grayscaled" /* Grayscaled */))
    ).setGap(".5rem").setJustifyItems("end").setRawColumns("auto max-content")
  )
);

// pages/hosting/views/pathNavigation.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function pathNavigation() {
  return path.map(
    (list) => Grid(
      ...list.split("/").filter((_5, index, list2) => list2.length - 1 != index).map(
        (item, currentIndex, list2) => Button(item || "home").setStyle("secondary" /* Secondary */).onClick(() => {
          path.setValue([...list2.filter((_5, listIndex) => listIndex <= currentIndex), ""].join("/"));
          loading.setValue(true);
          listFiles(path.getValue()).finally(() => loading.setValue(false));
        })
      ),
      Box(Custom(loadingWheel())).addClass(loading.map((it) => it ? "loading" : "non-loading"), "loading-box")
    ).setJustifyItems("start").addClass("path-bar")
  ).asRefComponent().removeFromLayout();
}

// pages/hosting/views/uploading/dropHandler.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://cdn.jsdelivr.net/npm/native-file-system-adapter/src/getOriginPrivateDirectory.js
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
if (globalThis.DataTransferItem && !DataTransferItem.prototype.getAsFileSystemHandle) {
  DataTransferItem.prototype.getAsFileSystemHandle = async function() {
    const entry = this.webkitGetAsEntry();
    const [
      { FileHandle: FileHandle2, FolderHandle: FolderHandle2 },
      { FileSystemDirectoryHandle: FileSystemDirectoryHandle3 },
      { FileSystemFileHandle: FileSystemFileHandle2 }
    ] = await Promise.all([
      Promise.resolve().then(() => (init_sandbox(), sandbox_exports)),
      Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports)),
      Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports))
    ]);
    return entry.isFile ? new FileSystemFileHandle2(new FileHandle2(entry, false)) : new FileSystemDirectoryHandle3(new FolderHandle2(entry, false));
  };
}

// esbuild_serve:http-import:https://deno.land/std@0.200.0/streams/readable_stream_from_iterable.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function readableStreamFromIterable(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel(reason) {
      if (typeof iterator.throw == "function") {
        try {
          await iterator.throw(reason);
        } catch {
        }
      }
    }
  });
}

// pages/shared/fileHandler.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
async function* walkFileTree(handle, path2) {
  const realpath = path2 ?? `${handle.name}`;
  if (handle.kind === "file") {
    const file2 = await handle.getFile();
    yield { path: realpath, file: file2 };
  } else if (handle.kind === "directory") {
    const entries = handle.values();
    for await (const entry of entries) {
      const entryPath = `${realpath}/${entry.name}`;
      if (entry.kind == "file") {
        const file2 = await entry.getFile();
        yield { path: entryPath, file: file2 };
      } else if (entry.kind == "directory") {
        yield* walkFileTree(entry, entryPath);
      }
    }
  }
}
async function countFileTree(handle) {
  let count2 = 0;
  if (handle.kind === "file") {
    count2++;
  } else if (handle.kind === "directory") {
    const entries = handle.values();
    for await (const entry of entries) {
      if (entry.kind == "file") {
        count2++;
      } else if (entry.kind == "directory") {
        count2 += await countFileTree(entry);
      }
    }
  }
  return count2;
}
var getFileStream = (handle) => "from" in ReadableStream && ReadableStream.from instanceof Function ? ReadableStream.from(walkFileTree(handle)) : readableStreamFromIterable(walkFileTree(handle));

// pages/hosting/views/uploading/dropHandler.ts
function DropHandler(onData, component) {
  return new class extends Component {
    hovering = asRef(false);
    constructor() {
      super();
      this.addClass(this.hovering.map((it) => it ? "hovering" : "default"), "drop-area");
      this.wrapper.ondragover = (ev) => {
        ev.preventDefault();
        this.hovering.setValue(true);
      };
      this.wrapper.ondragleave = (ev) => {
        ev.preventDefault();
        if (ev.target && !this.wrapper.contains(ev.relatedTarget)) {
          this.hovering.setValue(false);
        }
      };
      this.wrapper.ondrop = async (ev) => {
        ev.preventDefault();
        if (!ev.dataTransfer)
          return;
        this.hovering.setValue(false);
        const files = await Promise.all(
          [...ev.dataTransfer.items].filter((item) => item.kind === "file").map((item) => item.getAsFileSystemHandle())
        );
        const fileSizeCount = sumOf(await Promise.all(files.filter((it) => it).map((it) => countFileTree(it))), (it) => it);
        onData?.(
          getFileStreams(files).pipeThrough(
            new TransformStream({
              async transform(chunk, controller) {
                if (!chunk)
                  return;
                for await (const iterator of getFileStream(chunk)) {
                  controller.enqueue(iterator);
                }
              }
            })
          ),
          fileSizeCount
        );
      };
      this.wrapper.append(component.draw());
    }
  }();
}
var getFileStreams = (handle) => "from" in ReadableStream && ReadableStream.from instanceof Function ? ReadableStream.from(handle) : readableStreamFromIterable(handle);

// pages/hosting/views/uploading/droppingFileHandler.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var droppingFileHandler = async (files, count2) => {
  if (!canWriteInFolder.getValue()) {
    alert("This folder is Read-only. You can't upload files here.");
    return;
  }
  console.log("Uploading", count2, "files");
  for await (const uploadingPath of files) {
    const currentPath = path.getValue();
    const progressTracker = asRef(0);
    uploadingFiles.setValue({
      ...uploadingFiles.getValue(),
      [`${currentPath}${uploadingPath.path}`]: {
        uploadingRatio: progressTracker,
        fileMimeType: `${uploadingPath.file.type};`,
        lastModified: uploadingPath.file.lastModified,
        size: uploadingPath.file.size,
        name: uploadingPath.file.name
      }
    });
    await uploadFile(currentPath + uploadingPath.path, uploadingPath.file, progressTracker);
    uploadingFiles.setValue(Object.fromEntries(Object.entries(uploadingFiles.getValue()).filter(([path2]) => path2 != `${currentPath}${uploadingPath.path}`)));
  }
  loading.setValue(true);
  listFiles(path.getValue()).finally(() => loading.setValue(false));
};

// pages/hosting/views/FileBrowser.ts
var isExporting = asRef(false);
var exportAvaiblable = refMerge({
  uploadingFiles: uploadingFiles.map((it) => Object.keys(it).length !== 0 || !("showDirectoryPicker" in window)),
  isExporting
}).map(({ uploadingFiles: uploadingFiles2, isExporting: isExporting2 }) => !uploadingFiles2 && !isExporting2);
var globalProgress = asRef(0);
var currentFile = asRef("");
var currentFileProgress = asRef(0);
var exportingPhase = asRef("Indexing download tree");
var collectedFiles = asRef(0);
var currentFileIndex = asRef(0);
var exportingDialog = SheetDialog(
  sheetStack,
  "Download Folder",
  Grid(
    Label(ref`Downloading Phase: ${exportingPhase}`),
    exportingPhase.map(
      (phase) => phase === "Indexing download tree" ? Grid(
        Label("Searching for files to download..."),
        Label(ref`We have found ${collectedFiles} files. Please wait.`)
      ) : Grid(
        // Download is in progress and we need to download this many files
        Label("We are downloading your files, please wait."),
        Progress(globalProgress),
        Label(ref`Downloading file ${currentFileIndex} of ${collectedFiles}`),
        Progress(currentFileProgress),
        BasicLabel({
          title: ref`Downloading: ${currentFile}`
        })
      )
    ).asRefComponent().addClass("details-block")
  ).addClass("exporting-dialog")
);
async function getDirectoryHandle(pathIndex, directory, pathArray) {
  return pathIndex === pathArray.length - 1 ? directory : await getDirectoryHandle(pathIndex + 1, await directory.getDirectoryHandle(pathArray[pathIndex], { create: true }), pathArray);
}
function FileBrowser() {
  return DropHandler(
    droppingFileHandler,
    Grid(
      Entry(Grid(
        Grid(
          BasicLabel({
            title: "File Browser",
            subtitle: "Drag and Drop files/folders here to upload and download them faster."
          }).setMargin("0 0 1rem 0"),
          Button("Download Folder").setColor(exportAvaiblable.map((avaiblable) => avaiblable ? "grayscaled" /* Grayscaled */ : "disabled" /* Disabled */)).setStyle("secondary" /* Secondary */).onClick(async () => {
            const picker = await showDirectoryPicker({ mode: "readwrite" });
            exportingDialog.open();
            isExporting.setValue(true);
            const downloadTree = [];
            async function indexDownloadTree(path2) {
              const response = Promise.withResolvers();
              messageQueueSidecar.push({
                request: {
                  type: "list",
                  path: path2
                },
                response
              });
              const data = await response.promise;
              if (data.type === "list") {
                for (const iterator of data.list) {
                  if (iterator.fileMimeType) {
                    downloadTree.push({
                      path: path2 + iterator.name,
                      size: iterator.size
                    });
                    collectedFiles.setValue(collectedFiles.getValue() + 1);
                  } else {
                    await indexDownloadTree(path2 + iterator.name + "/");
                  }
                }
              } else {
                alert("Error while baking download treee");
                return;
              }
            }
            exportingPhase.setValue("Indexing download tree");
            await indexDownloadTree(path.getValue());
            exportingPhase.setValue("Downloading Files");
            for (const [index, { path: path2, size }] of downloadTree.entries()) {
              globalProgress.setValue(index / downloadTree.length * 100);
              currentFileIndex.setValue(index);
              const pathArray = path2.split("/");
              const fileName = pathArray.at(-1);
              const dir = await getDirectoryHandle(1, picker, pathArray);
              const handler = await dir.getFileHandle(fileName, { create: true });
              const writable = await handler.createWritable();
              currentFile.setValue(path2);
              await downloadFile(path2).pipeThrough(ProgressTracker(currentFileProgress, size)).pipeTo(writable);
            }
            isExporting.setValue(false);
            exportingDialog.close();
          })
        ).setRawColumns("auto max-content"),
        pathNavigation(),
        canWriteInFolder.map(
          (writeable) => writeable ? Box() : Box(
            MIcon("warning"),
            Label("This folder is read-only. Change the folder to upload files.")
          ).addClass("read-only-path")
        ).asRefComponent(),
        new Table2(allFiles).addColumn("Name", (data) => Box(
          BIcon(mapFiletoIcon(data)),
          BasicLabel({ title: data.name }).addClass("small-text"),
          ...data.uploadingRatio !== void 0 ? [MIcon("cloud")] : []
        ).addClass("file-item")).addColumn("Last Modified", (data) => data.lastModified !== void 0 ? Label(new Date(data.lastModified).toLocaleString()) : Box()).addColumn("Type", (data) => data.fileMimeType !== void 0 ? Label(fileTypeName(data.fileMimeType)) : Label("Folder")).addColumn("Size", (data) => data.size !== void 0 ? Label(format(data.size)).addClass("text-align-right") : Box()).addColumn("", (data) => Grid(
          data.uploadingRatio !== void 0 ? Progress(data.uploadingRatio).addClass("fileProgressBar") : Empty(),
          data.fileMimeType && ["text/yaml", "application/json", "text/plain"].includes(data.fileMimeType.split(";")[0]) && data.uploadingRatio === void 0 ? IconButton(MIcon("file_open"), "Open file").addClass("table-button").onClick(() => {
            if (!data.fileMimeType)
              return;
            editFileReadOnly.setValue(!data.canWrite);
            editFileLanguage.setValue(
              data.fileMimeType.split(";")[0].split("/")[1]
            );
            editFilePath.setValue(path.getValue() + data.name);
            const stream = downloadFile(editFilePath.getValue());
            editFilestreamingText.setValue(stream.pipeThrough(new TextDecoderStream()));
            setTimeout(() => {
              editFileDialog.open();
            }, 200);
          }) : Box(),
          data.fileMimeType && data.uploadingRatio === void 0 ? IconButton(MIcon("download"), "Download").addClass("table-button").onClick(async () => {
            const stream = downloadFile(path.getValue() + data.name);
            await stream.pipeTo(createDownloadStream(data.name));
          }) : Box(),
          data.fileMimeType && data.canWrite && data.uploadingRatio === void 0 ? IconButton(MIcon("delete"), "Delete").addClass("table-button", "red").onClick(async () => {
            if (!await deleteFileDialog()) {
              return;
            }
            const response = Promise.withResolvers();
            messageQueueSidecar.push({
              request: {
                type: "delete",
                path: path.getValue() + data.name
              },
              response
            });
            loading.setValue(true);
            listFiles(path.getValue()).finally(() => loading.setValue(false));
            setTimeout(() => {
              loading.setValue(true);
              listFiles(path.getValue()).finally(() => loading.setValue(false));
            }, 1e3);
            await response.promise;
          }) : Box()
        ).setEvenColumns(3)).setColumnTemplate("auto auto auto auto min-content").setRowClickEnabled((rowIndex) => !allFiles.getValue()[rowIndex].fileMimeType).setRowClick((rowIndex) => {
          const data = allFiles.getValue()[rowIndex];
          path.setValue(`${path.getValue() + data.name}/`);
          loading.setValue(true);
          listFiles(path.getValue()).finally(() => loading.setValue(false));
        })
      )).addClass("file-browser")
    )
  ).addClass("drop-area");
}

// pages/hosting/views/Loader.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function Loader(object, handler) {
  const isLoading = asRef(false);
  const loadMore = async () => {
    isLoading.setValue(true);
    await object.next();
    isLoading.setValue(false);
  };
  return handler({
    items: object.items,
    hasMore: object.hasMore,
    loadMore,
    isLoading
  });
}

// pages/hosting/views/ServerDetails.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// pages/hosting/views/ServerStaticInfo.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var time = asRef((/* @__PURE__ */ new Date()).getTime());
setInterval(() => time.setValue((/* @__PURE__ */ new Date()).getTime()), 200);
function ServerStaticInfo(mobile, server2, input) {
  const uptime = BasicLabel({
    title: refMerge({
      state: server2.$stateSince,
      time
    }).map(({ state: state2 }) => state2 ? calculateUptime(new Date(state2)) : "---"),
    subtitle: server2.$state.map((it) => it == "running" ? "uptime" : "since")
  });
  const address = BasicLabel({
    title: server2.$address.map((it) => it ?? "---"),
    subtitle: "address"
  });
  const cpu = BasicLabel({
    title: ref`${input.$cpu.map((it) => `${it?.toFixed(2) ?? "---"} %`)} / ${server2.limits.cpu.toString()} %`,
    subtitle: "cpu"
  });
  const ram = BasicLabel({
    title: input.$memory.map((it) => `${it ? format(it * MB) : "---"} / ${format(server2.limits.memory * MB)}`),
    subtitle: "memory"
  });
  const disk = BasicLabel({
    title: input.$disk.map((it) => it ? `${(it / server2.limits.disk * 100).toFixed(0)} %` : "---"),
    subtitle: "disk"
  });
  return mobile ? [
    Entry(Grid(
      ChangeStateButton(server2),
      uptime
    )).addClass("stats-list"),
    Entry(Grid(
      address
    )).addClass("stats-list"),
    Entry(Grid(
      cpu,
      ram,
      disk
    )).addClass("stats-list")
  ] : [
    [
      { width: 2 },
      Entry(Grid(
        ChangeStateButton(server2),
        uptime,
        address,
        cpu,
        ram,
        disk
      )).addClass("stats-list")
    ]
  ];
}

// pages/hosting/views/terminal.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/xterm-addon-fit@0.8.0
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/v135/xterm-addon-fit@0.8.0/denonext/xterm-addon-fit.mjs
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var x4 = Object.create;
var p5 = Object.defineProperty;
var M4 = Object.getOwnPropertyDescriptor;
var P6 = Object.getOwnPropertyNames;
var b4 = Object.getPrototypeOf;
var I6 = Object.prototype.hasOwnProperty;
var V5 = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var A4 = (r, e) => {
  for (var t in e)
    p5(r, t, { get: e[t], enumerable: true });
};
var d4 = (r, e, t, i4) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s2 of P6(e))
      !I6.call(r, s2) && s2 !== t && p5(r, s2, { get: () => e[s2], enumerable: !(i4 = M4(e, s2)) || i4.enumerable });
  return r;
};
var n2 = (r, e, t) => (d4(r, e, "default"), t && d4(t, e, "default"));
var _4 = (r, e, t) => (t = r != null ? x4(b4(r)) : {}, d4(e || !r || !r.__esModule ? p5(t, "default", { value: r, enumerable: true }) : t, r));
var m5 = V5((a2, c3) => {
  (function(r, e) {
    typeof a2 == "object" && typeof c3 == "object" ? c3.exports = e() : typeof define == "function" && define.amd ? define([], e) : typeof a2 == "object" ? a2.FitAddon = e() : r.FitAddon = e();
  })(self, () => (() => {
    "use strict";
    var r = {};
    return (() => {
      var e = r;
      Object.defineProperty(e, "__esModule", { value: true }), e.FitAddon = void 0, e.FitAddon = class {
        activate(t) {
          this._terminal = t;
        }
        dispose() {
        }
        fit() {
          let t = this.proposeDimensions();
          if (!t || !this._terminal || isNaN(t.cols) || isNaN(t.rows))
            return;
          let i4 = this._terminal._core;
          this._terminal.rows === t.rows && this._terminal.cols === t.cols || (i4._renderService.clear(), this._terminal.resize(t.cols, t.rows));
        }
        proposeDimensions() {
          if (!this._terminal || !this._terminal.element || !this._terminal.element.parentElement)
            return;
          let t = this._terminal._core, i4 = t._renderService.dimensions;
          if (i4.css.cell.width === 0 || i4.css.cell.height === 0)
            return;
          let s2 = this._terminal.options.scrollback === 0 ? 0 : t.viewport.scrollBarWidth, h5 = window.getComputedStyle(this._terminal.element.parentElement), g4 = parseInt(h5.getPropertyValue("height")), w4 = Math.max(0, parseInt(h5.getPropertyValue("width"))), l4 = window.getComputedStyle(this._terminal.element), y5 = g4 - (parseInt(l4.getPropertyValue("padding-top")) + parseInt(l4.getPropertyValue("padding-bottom"))), v5 = w4 - (parseInt(l4.getPropertyValue("padding-right")) + parseInt(l4.getPropertyValue("padding-left"))) - s2;
          return { cols: Math.max(2, Math.floor(v5 / i4.css.cell.width)), rows: Math.max(1, Math.floor(y5 / i4.css.cell.height)) };
        }
      };
    })(), r;
  })());
});
var o2 = {};
A4(o2, { FitAddon: () => j6, __esModule: () => F6, default: () => S5 });
var u2 = _4(m5());
n2(o2, _4(m5()));
var { __esModule: F6, FitAddon: j6 } = u2;
var { default: f3, ...N5 } = u2;
var S5 = f3 !== void 0 ? f3 : N5;

// esbuild_serve:http-import:https://esm.sh/xterm-addon-webgl@0.16.0
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/v135/xterm-addon-webgl@0.16.0/denonext/xterm-addon-webgl.mjs
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var Ee2 = Object.create;
var Le2 = Object.defineProperty;
var Se2 = Object.getOwnPropertyDescriptor;
var Te2 = Object.getOwnPropertyNames;
var De2 = Object.getPrototypeOf;
var Pe2 = Object.prototype.hasOwnProperty;
var Fe2 = (q6, U4) => () => (U4 || q6((U4 = { exports: {} }).exports, U4), U4.exports);
var Be2 = (q6, U4) => {
  for (var V6 in U4)
    Le2(q6, V6, { get: U4[V6], enumerable: true });
};
var me2 = (q6, U4, V6, oe2) => {
  if (U4 && typeof U4 == "object" || typeof U4 == "function")
    for (let P7 of Te2(U4))
      !Pe2.call(q6, P7) && P7 !== V6 && Le2(q6, P7, { get: () => U4[P7], enumerable: !(oe2 = Se2(U4, P7)) || oe2.enumerable });
  return q6;
};
var se2 = (q6, U4, V6) => (me2(q6, U4, "default"), V6 && me2(V6, U4, "default"));
var Me2 = (q6, U4, V6) => (V6 = q6 != null ? Ee2(De2(q6)) : {}, me2(U4 || !q6 || !q6.__esModule ? Le2(V6, "default", { value: q6, enumerable: true }) : V6, q6));
var we2 = Fe2((fe2, xe2) => {
  (function(q6, U4) {
    typeof fe2 == "object" && typeof xe2 == "object" ? xe2.exports = U4() : typeof define == "function" && define.amd ? define([], U4) : typeof fe2 == "object" ? fe2.WebglAddon = U4() : q6.WebglAddon = U4();
  })(self, () => (() => {
    "use strict";
    var q6 = { 965: function(P7, e, d5) {
      var l4 = this && this.__decorate || function(E5, r, u3, C5) {
        var s2, n3 = arguments.length, m6 = n3 < 3 ? r : C5 === null ? C5 = Object.getOwnPropertyDescriptor(r, u3) : C5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          m6 = Reflect.decorate(E5, r, u3, C5);
        else
          for (var h5 = E5.length - 1; h5 >= 0; h5--)
            (s2 = E5[h5]) && (m6 = (n3 < 3 ? s2(m6) : n3 > 3 ? s2(r, u3, m6) : s2(r, u3)) || m6);
        return n3 > 3 && m6 && Object.defineProperty(r, u3, m6), m6;
      };
      Object.defineProperty(e, "__esModule", { value: true }), e.GlyphRenderer = void 0;
      let a2 = d5(374), o3 = d5(509), _5 = d5(855), p6 = d5(859), c3 = d5(776), i4 = d5(381), t = 11, g4 = t * Float32Array.BYTES_PER_ELEMENT, L5, x5 = 0, S6 = 0, R4 = 0;
      class A5 extends p6.Disposable {
        constructor(r, u3, C5) {
          super(), this._terminal = r, this._gl = u3, this._dimensions = C5, this._activeBuffer = 0, this._vertices = { count: 0, attributes: new Float32Array(0), attributesBuffers: [new Float32Array(0), new Float32Array(0)] };
          let s2 = this._gl;
          o3.TextureAtlas.maxAtlasPages === void 0 && (o3.TextureAtlas.maxAtlasPages = Math.min(32, (0, a2.throwIfFalsy)(s2.getParameter(s2.MAX_TEXTURE_IMAGE_UNITS))), o3.TextureAtlas.maxTextureSize = (0, a2.throwIfFalsy)(s2.getParameter(s2.MAX_TEXTURE_SIZE))), this._program = (0, a2.throwIfFalsy)((0, i4.createProgram)(s2, `#version 300 es
layout (location = 0) in vec2 a_unitquad;
layout (location = 1) in vec2 a_cellpos;
layout (location = 2) in vec2 a_offset;
layout (location = 3) in vec2 a_size;
layout (location = 4) in float a_texpage;
layout (location = 5) in vec2 a_texcoord;
layout (location = 6) in vec2 a_texsize;

uniform mat4 u_projection;
uniform vec2 u_resolution;

out vec2 v_texcoord;
flat out int v_texpage;

void main() {
  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);
  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);
  v_texpage = int(a_texpage);
  v_texcoord = a_texcoord + a_unitquad * a_texsize;
}`, function(b5) {
            let y5 = "";
            for (let w4 = 1; w4 < b5; w4++)
              y5 += ` else if (v_texpage == ${w4}) { outColor = texture(u_texture[${w4}], v_texcoord); }`;
            return `#version 300 es
precision lowp float;

in vec2 v_texcoord;
flat in int v_texpage;

uniform sampler2D u_texture[${b5}];

out vec4 outColor;

void main() {
  if (v_texpage == 0) {
    outColor = texture(u_texture[0], v_texcoord);
  } ${y5}
}`;
          }(o3.TextureAtlas.maxAtlasPages))), this.register((0, p6.toDisposable)(() => s2.deleteProgram(this._program))), this._projectionLocation = (0, a2.throwIfFalsy)(s2.getUniformLocation(this._program, "u_projection")), this._resolutionLocation = (0, a2.throwIfFalsy)(s2.getUniformLocation(this._program, "u_resolution")), this._textureLocation = (0, a2.throwIfFalsy)(s2.getUniformLocation(this._program, "u_texture")), this._vertexArrayObject = s2.createVertexArray(), s2.bindVertexArray(this._vertexArrayObject);
          let n3 = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), m6 = s2.createBuffer();
          this.register((0, p6.toDisposable)(() => s2.deleteBuffer(m6))), s2.bindBuffer(s2.ARRAY_BUFFER, m6), s2.bufferData(s2.ARRAY_BUFFER, n3, s2.STATIC_DRAW), s2.enableVertexAttribArray(0), s2.vertexAttribPointer(0, 2, this._gl.FLOAT, false, 0, 0);
          let h5 = new Uint8Array([0, 1, 2, 3]), v5 = s2.createBuffer();
          this.register((0, p6.toDisposable)(() => s2.deleteBuffer(v5))), s2.bindBuffer(s2.ELEMENT_ARRAY_BUFFER, v5), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, h5, s2.STATIC_DRAW), this._attributesBuffer = (0, a2.throwIfFalsy)(s2.createBuffer()), this.register((0, p6.toDisposable)(() => s2.deleteBuffer(this._attributesBuffer))), s2.bindBuffer(s2.ARRAY_BUFFER, this._attributesBuffer), s2.enableVertexAttribArray(2), s2.vertexAttribPointer(2, 2, s2.FLOAT, false, g4, 0), s2.vertexAttribDivisor(2, 1), s2.enableVertexAttribArray(3), s2.vertexAttribPointer(3, 2, s2.FLOAT, false, g4, 2 * Float32Array.BYTES_PER_ELEMENT), s2.vertexAttribDivisor(3, 1), s2.enableVertexAttribArray(4), s2.vertexAttribPointer(4, 1, s2.FLOAT, false, g4, 4 * Float32Array.BYTES_PER_ELEMENT), s2.vertexAttribDivisor(4, 1), s2.enableVertexAttribArray(5), s2.vertexAttribPointer(5, 2, s2.FLOAT, false, g4, 5 * Float32Array.BYTES_PER_ELEMENT), s2.vertexAttribDivisor(5, 1), s2.enableVertexAttribArray(6), s2.vertexAttribPointer(6, 2, s2.FLOAT, false, g4, 7 * Float32Array.BYTES_PER_ELEMENT), s2.vertexAttribDivisor(6, 1), s2.enableVertexAttribArray(1), s2.vertexAttribPointer(1, 2, s2.FLOAT, false, g4, 9 * Float32Array.BYTES_PER_ELEMENT), s2.vertexAttribDivisor(1, 1), s2.useProgram(this._program);
          let f4 = new Int32Array(o3.TextureAtlas.maxAtlasPages);
          for (let b5 = 0; b5 < o3.TextureAtlas.maxAtlasPages; b5++)
            f4[b5] = b5;
          s2.uniform1iv(this._textureLocation, f4), s2.uniformMatrix4fv(this._projectionLocation, false, i4.PROJECTION_MATRIX), this._atlasTextures = [];
          for (let b5 = 0; b5 < o3.TextureAtlas.maxAtlasPages; b5++) {
            let y5 = new i4.GLTexture((0, a2.throwIfFalsy)(s2.createTexture()));
            this.register((0, p6.toDisposable)(() => s2.deleteTexture(y5.texture))), s2.activeTexture(s2.TEXTURE0 + b5), s2.bindTexture(s2.TEXTURE_2D, y5.texture), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, s2.CLAMP_TO_EDGE), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, s2.CLAMP_TO_EDGE), s2.texImage2D(s2.TEXTURE_2D, 0, s2.RGBA, 1, 1, 0, s2.RGBA, s2.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255])), this._atlasTextures[b5] = y5;
          }
          s2.enable(s2.BLEND), s2.blendFunc(s2.SRC_ALPHA, s2.ONE_MINUS_SRC_ALPHA), this.handleResize();
        }
        beginFrame() {
          return !this._atlas || this._atlas.beginFrame();
        }
        updateCell(r, u3, C5, s2, n3, m6, h5, v5) {
          this._updateCell(this._vertices.attributes, r, u3, C5, s2, n3, m6, h5, v5);
        }
        _updateCell(r, u3, C5, s2, n3, m6, h5, v5, f4) {
          x5 = (C5 * this._terminal.cols + u3) * t, s2 !== _5.NULL_CELL_CODE && s2 !== void 0 ? this._atlas && (L5 = v5 && v5.length > 1 ? this._atlas.getRasterizedGlyphCombinedChar(v5, n3, m6, h5, false) : this._atlas.getRasterizedGlyph(s2, n3, m6, h5, false), S6 = Math.floor((this._dimensions.device.cell.width - this._dimensions.device.char.width) / 2), n3 !== f4 && L5.offset.x > S6 ? (R4 = L5.offset.x - S6, r[x5] = -(L5.offset.x - R4) + this._dimensions.device.char.left, r[x5 + 1] = -L5.offset.y + this._dimensions.device.char.top, r[x5 + 2] = (L5.size.x - R4) / this._dimensions.device.canvas.width, r[x5 + 3] = L5.size.y / this._dimensions.device.canvas.height, r[x5 + 4] = L5.texturePage, r[x5 + 5] = L5.texturePositionClipSpace.x + R4 / this._atlas.pages[L5.texturePage].canvas.width, r[x5 + 6] = L5.texturePositionClipSpace.y, r[x5 + 7] = L5.sizeClipSpace.x - R4 / this._atlas.pages[L5.texturePage].canvas.width, r[x5 + 8] = L5.sizeClipSpace.y) : (r[x5] = -L5.offset.x + this._dimensions.device.char.left, r[x5 + 1] = -L5.offset.y + this._dimensions.device.char.top, r[x5 + 2] = L5.size.x / this._dimensions.device.canvas.width, r[x5 + 3] = L5.size.y / this._dimensions.device.canvas.height, r[x5 + 4] = L5.texturePage, r[x5 + 5] = L5.texturePositionClipSpace.x, r[x5 + 6] = L5.texturePositionClipSpace.y, r[x5 + 7] = L5.sizeClipSpace.x, r[x5 + 8] = L5.sizeClipSpace.y)) : r.fill(0, x5, x5 + t - 1 - 2);
        }
        clear() {
          let r = this._terminal, u3 = r.cols * r.rows * t;
          this._vertices.count !== u3 ? this._vertices.attributes = new Float32Array(u3) : this._vertices.attributes.fill(0);
          let C5 = 0;
          for (; C5 < this._vertices.attributesBuffers.length; C5++)
            this._vertices.count !== u3 ? this._vertices.attributesBuffers[C5] = new Float32Array(u3) : this._vertices.attributesBuffers[C5].fill(0);
          this._vertices.count = u3, C5 = 0;
          for (let s2 = 0; s2 < r.rows; s2++)
            for (let n3 = 0; n3 < r.cols; n3++)
              this._vertices.attributes[C5 + 9] = n3 / r.cols, this._vertices.attributes[C5 + 10] = s2 / r.rows, C5 += t;
        }
        handleResize() {
          let r = this._gl;
          r.useProgram(this._program), r.viewport(0, 0, r.canvas.width, r.canvas.height), r.uniform2f(this._resolutionLocation, r.canvas.width, r.canvas.height), this.clear();
        }
        render(r) {
          if (!this._atlas)
            return;
          let u3 = this._gl;
          u3.useProgram(this._program), u3.bindVertexArray(this._vertexArrayObject), this._activeBuffer = (this._activeBuffer + 1) % 2;
          let C5 = this._vertices.attributesBuffers[this._activeBuffer], s2 = 0;
          for (let n3 = 0; n3 < r.lineLengths.length; n3++) {
            let m6 = n3 * this._terminal.cols * t, h5 = this._vertices.attributes.subarray(m6, m6 + r.lineLengths[n3] * t);
            C5.set(h5, s2), s2 += h5.length;
          }
          u3.bindBuffer(u3.ARRAY_BUFFER, this._attributesBuffer), u3.bufferData(u3.ARRAY_BUFFER, C5.subarray(0, s2), u3.STREAM_DRAW);
          for (let n3 = 0; n3 < this._atlas.pages.length; n3++)
            this._atlas.pages[n3].version !== this._atlasTextures[n3].version && this._bindAtlasPageTexture(u3, this._atlas, n3);
          u3.drawElementsInstanced(u3.TRIANGLE_STRIP, 4, u3.UNSIGNED_BYTE, 0, s2 / t);
        }
        setAtlas(r) {
          this._atlas = r;
          for (let u3 of this._atlasTextures)
            u3.version = -1;
        }
        _bindAtlasPageTexture(r, u3, C5) {
          r.activeTexture(r.TEXTURE0 + C5), r.bindTexture(r.TEXTURE_2D, this._atlasTextures[C5].texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, u3.pages[C5].canvas), r.generateMipmap(r.TEXTURE_2D), this._atlasTextures[C5].version = u3.pages[C5].version;
        }
        setDimensions(r) {
          this._dimensions = r;
        }
      }
      e.GlyphRenderer = A5, l4([c3.traceCall], A5.prototype, "updateCell", null);
    }, 742: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.RectangleRenderer = void 0;
      let l4 = d5(374), a2 = d5(859), o3 = d5(310), _5 = d5(381), p6 = 8 * Float32Array.BYTES_PER_ELEMENT;
      class c3 {
        constructor() {
          this.attributes = new Float32Array(160), this.count = 0;
        }
      }
      let i4 = 0, t = 0, g4 = 0, L5 = 0, x5 = 0, S6 = 0, R4 = 0;
      class A5 extends a2.Disposable {
        constructor(r, u3, C5, s2) {
          super(), this._terminal = r, this._gl = u3, this._dimensions = C5, this._themeService = s2, this._vertices = new c3(), this._verticesCursor = new c3();
          let n3 = this._gl;
          this._program = (0, l4.throwIfFalsy)((0, _5.createProgram)(n3, `#version 300 es
layout (location = 0) in vec2 a_position;
layout (location = 1) in vec2 a_size;
layout (location = 2) in vec4 a_color;
layout (location = 3) in vec2 a_unitquad;

uniform mat4 u_projection;

out vec4 v_color;

void main() {
  vec2 zeroToOne = a_position + (a_unitquad * a_size);
  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);
  v_color = a_color;
}`, `#version 300 es
precision lowp float;

in vec4 v_color;

out vec4 outColor;

void main() {
  outColor = v_color;
}`)), this.register((0, a2.toDisposable)(() => n3.deleteProgram(this._program))), this._projectionLocation = (0, l4.throwIfFalsy)(n3.getUniformLocation(this._program, "u_projection")), this._vertexArrayObject = n3.createVertexArray(), n3.bindVertexArray(this._vertexArrayObject);
          let m6 = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), h5 = n3.createBuffer();
          this.register((0, a2.toDisposable)(() => n3.deleteBuffer(h5))), n3.bindBuffer(n3.ARRAY_BUFFER, h5), n3.bufferData(n3.ARRAY_BUFFER, m6, n3.STATIC_DRAW), n3.enableVertexAttribArray(3), n3.vertexAttribPointer(3, 2, this._gl.FLOAT, false, 0, 0);
          let v5 = new Uint8Array([0, 1, 2, 3]), f4 = n3.createBuffer();
          this.register((0, a2.toDisposable)(() => n3.deleteBuffer(f4))), n3.bindBuffer(n3.ELEMENT_ARRAY_BUFFER, f4), n3.bufferData(n3.ELEMENT_ARRAY_BUFFER, v5, n3.STATIC_DRAW), this._attributesBuffer = (0, l4.throwIfFalsy)(n3.createBuffer()), this.register((0, a2.toDisposable)(() => n3.deleteBuffer(this._attributesBuffer))), n3.bindBuffer(n3.ARRAY_BUFFER, this._attributesBuffer), n3.enableVertexAttribArray(0), n3.vertexAttribPointer(0, 2, n3.FLOAT, false, p6, 0), n3.vertexAttribDivisor(0, 1), n3.enableVertexAttribArray(1), n3.vertexAttribPointer(1, 2, n3.FLOAT, false, p6, 2 * Float32Array.BYTES_PER_ELEMENT), n3.vertexAttribDivisor(1, 1), n3.enableVertexAttribArray(2), n3.vertexAttribPointer(2, 4, n3.FLOAT, false, p6, 4 * Float32Array.BYTES_PER_ELEMENT), n3.vertexAttribDivisor(2, 1), this._updateCachedColors(s2.colors), this.register(this._themeService.onChangeColors((b5) => {
            this._updateCachedColors(b5), this._updateViewportRectangle();
          }));
        }
        renderBackgrounds() {
          this._renderVertices(this._vertices);
        }
        renderCursor() {
          this._renderVertices(this._verticesCursor);
        }
        _renderVertices(r) {
          let u3 = this._gl;
          u3.useProgram(this._program), u3.bindVertexArray(this._vertexArrayObject), u3.uniformMatrix4fv(this._projectionLocation, false, _5.PROJECTION_MATRIX), u3.bindBuffer(u3.ARRAY_BUFFER, this._attributesBuffer), u3.bufferData(u3.ARRAY_BUFFER, r.attributes, u3.DYNAMIC_DRAW), u3.drawElementsInstanced(this._gl.TRIANGLE_STRIP, 4, u3.UNSIGNED_BYTE, 0, r.count);
        }
        handleResize() {
          this._updateViewportRectangle();
        }
        setDimensions(r) {
          this._dimensions = r;
        }
        _updateCachedColors(r) {
          this._bgFloat = this._colorToFloat32Array(r.background), this._cursorFloat = this._colorToFloat32Array(r.cursor);
        }
        _updateViewportRectangle() {
          this._addRectangleFloat(this._vertices.attributes, 0, 0, 0, this._terminal.cols * this._dimensions.device.cell.width, this._terminal.rows * this._dimensions.device.cell.height, this._bgFloat);
        }
        updateBackgrounds(r) {
          let u3 = this._terminal, C5 = this._vertices, s2, n3, m6, h5, v5, f4, b5, y5, w4, M5, D5, T6 = 1;
          for (s2 = 0; s2 < u3.rows; s2++) {
            for (m6 = -1, h5 = 0, v5 = 0, f4 = false, n3 = 0; n3 < u3.cols; n3++)
              b5 = (s2 * u3.cols + n3) * o3.RENDER_MODEL_INDICIES_PER_CELL, y5 = r.cells[b5 + o3.RENDER_MODEL_BG_OFFSET], w4 = r.cells[b5 + o3.RENDER_MODEL_FG_OFFSET], M5 = !!(67108864 & w4), (y5 !== h5 || w4 !== v5 && (f4 || M5)) && ((h5 !== 0 || f4 && v5 !== 0) && (D5 = 8 * T6++, this._updateRectangle(C5, D5, v5, h5, m6, n3, s2)), m6 = n3, h5 = y5, v5 = w4, f4 = M5);
            (h5 !== 0 || f4 && v5 !== 0) && (D5 = 8 * T6++, this._updateRectangle(C5, D5, v5, h5, m6, u3.cols, s2));
          }
          C5.count = T6;
        }
        updateCursor(r) {
          let u3 = this._verticesCursor, C5 = r.cursor;
          if (!C5 || C5.style === "block")
            return void (u3.count = 0);
          let s2, n3 = 0;
          C5.style !== "bar" && C5.style !== "outline" || (s2 = 8 * n3++, this._addRectangleFloat(u3.attributes, s2, C5.x * this._dimensions.device.cell.width, C5.y * this._dimensions.device.cell.height, C5.style === "bar" ? C5.dpr * C5.cursorWidth : C5.dpr, this._dimensions.device.cell.height, this._cursorFloat)), C5.style !== "underline" && C5.style !== "outline" || (s2 = 8 * n3++, this._addRectangleFloat(u3.attributes, s2, C5.x * this._dimensions.device.cell.width, (C5.y + 1) * this._dimensions.device.cell.height - C5.dpr, C5.width * this._dimensions.device.cell.width, C5.dpr, this._cursorFloat)), C5.style === "outline" && (s2 = 8 * n3++, this._addRectangleFloat(u3.attributes, s2, C5.x * this._dimensions.device.cell.width, C5.y * this._dimensions.device.cell.height, C5.width * this._dimensions.device.cell.width, C5.dpr, this._cursorFloat), s2 = 8 * n3++, this._addRectangleFloat(u3.attributes, s2, (C5.x + C5.width) * this._dimensions.device.cell.width - C5.dpr, C5.y * this._dimensions.device.cell.height, C5.dpr, this._dimensions.device.cell.height, this._cursorFloat)), u3.count = n3;
        }
        _updateRectangle(r, u3, C5, s2, n3, m6, h5) {
          if (67108864 & C5)
            switch (50331648 & C5) {
              case 16777216:
              case 33554432:
                i4 = this._themeService.colors.ansi[255 & C5].rgba;
                break;
              case 50331648:
                i4 = (16777215 & C5) << 8;
                break;
              default:
                i4 = this._themeService.colors.foreground.rgba;
            }
          else
            switch (50331648 & s2) {
              case 16777216:
              case 33554432:
                i4 = this._themeService.colors.ansi[255 & s2].rgba;
                break;
              case 50331648:
                i4 = (16777215 & s2) << 8;
                break;
              default:
                i4 = this._themeService.colors.background.rgba;
            }
          r.attributes.length < u3 + 4 && (r.attributes = (0, _5.expandFloat32Array)(r.attributes, this._terminal.rows * this._terminal.cols * 8)), t = n3 * this._dimensions.device.cell.width, g4 = h5 * this._dimensions.device.cell.height, L5 = (i4 >> 24 & 255) / 255, x5 = (i4 >> 16 & 255) / 255, S6 = (i4 >> 8 & 255) / 255, R4 = 1, this._addRectangle(r.attributes, u3, t, g4, (m6 - n3) * this._dimensions.device.cell.width, this._dimensions.device.cell.height, L5, x5, S6, R4);
        }
        _addRectangle(r, u3, C5, s2, n3, m6, h5, v5, f4, b5) {
          r[u3] = C5 / this._dimensions.device.canvas.width, r[u3 + 1] = s2 / this._dimensions.device.canvas.height, r[u3 + 2] = n3 / this._dimensions.device.canvas.width, r[u3 + 3] = m6 / this._dimensions.device.canvas.height, r[u3 + 4] = h5, r[u3 + 5] = v5, r[u3 + 6] = f4, r[u3 + 7] = b5;
        }
        _addRectangleFloat(r, u3, C5, s2, n3, m6, h5) {
          r[u3] = C5 / this._dimensions.device.canvas.width, r[u3 + 1] = s2 / this._dimensions.device.canvas.height, r[u3 + 2] = n3 / this._dimensions.device.canvas.width, r[u3 + 3] = m6 / this._dimensions.device.canvas.height, r[u3 + 4] = h5[0], r[u3 + 5] = h5[1], r[u3 + 6] = h5[2], r[u3 + 7] = h5[3];
        }
        _colorToFloat32Array(r) {
          return new Float32Array([(r.rgba >> 24 & 255) / 255, (r.rgba >> 16 & 255) / 255, (r.rgba >> 8 & 255) / 255, (255 & r.rgba) / 255]);
        }
      }
      e.RectangleRenderer = A5;
    }, 310: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.RenderModel = e.COMBINED_CHAR_BIT_MASK = e.RENDER_MODEL_EXT_OFFSET = e.RENDER_MODEL_FG_OFFSET = e.RENDER_MODEL_BG_OFFSET = e.RENDER_MODEL_INDICIES_PER_CELL = void 0;
      let l4 = d5(296);
      e.RENDER_MODEL_INDICIES_PER_CELL = 4, e.RENDER_MODEL_BG_OFFSET = 1, e.RENDER_MODEL_FG_OFFSET = 2, e.RENDER_MODEL_EXT_OFFSET = 3, e.COMBINED_CHAR_BIT_MASK = 2147483648, e.RenderModel = class {
        constructor() {
          this.cells = new Uint32Array(0), this.lineLengths = new Uint32Array(0), this.selection = (0, l4.createSelectionRenderModel)();
        }
        resize(a2, o3) {
          let _5 = a2 * o3 * e.RENDER_MODEL_INDICIES_PER_CELL;
          _5 !== this.cells.length && (this.cells = new Uint32Array(_5), this.lineLengths = new Uint32Array(o3));
        }
        clear() {
          this.cells.fill(0, 0), this.lineLengths.fill(0, 0);
        }
      };
    }, 666: function(P7, e, d5) {
      var l4 = this && this.__decorate || function(m6, h5, v5, f4) {
        var b5, y5 = arguments.length, w4 = y5 < 3 ? h5 : f4 === null ? f4 = Object.getOwnPropertyDescriptor(h5, v5) : f4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          w4 = Reflect.decorate(m6, h5, v5, f4);
        else
          for (var M5 = m6.length - 1; M5 >= 0; M5--)
            (b5 = m6[M5]) && (w4 = (y5 < 3 ? b5(w4) : y5 > 3 ? b5(h5, v5, w4) : b5(h5, v5)) || w4);
        return y5 > 3 && w4 && Object.defineProperty(h5, v5, w4), w4;
      };
      Object.defineProperty(e, "__esModule", { value: true }), e.JoinedCellData = e.WebglRenderer = void 0;
      let a2 = d5(820), o3 = d5(274), _5 = d5(627), p6 = d5(457), c3 = d5(56), i4 = d5(374), t = d5(345), g4 = d5(859), L5 = d5(147), x5 = d5(782), S6 = d5(855), R4 = d5(776), A5 = d5(965), E5 = d5(742), r = d5(310), u3 = d5(733);
      class C5 extends g4.Disposable {
        constructor(h5, v5, f4, b5, y5, w4, M5, D5, T6) {
          super(), this._terminal = h5, this._characterJoinerService = v5, this._charSizeService = f4, this._coreBrowserService = b5, this._coreService = y5, this._decorationService = w4, this._optionsService = M5, this._themeService = D5, this._cursorBlinkStateManager = new g4.MutableDisposable(), this._charAtlasDisposable = this.register(new g4.MutableDisposable()), this._model = new r.RenderModel(), this._workCell = new x5.CellData(), this._rectangleRenderer = this.register(new g4.MutableDisposable()), this._glyphRenderer = this.register(new g4.MutableDisposable()), this._onChangeTextureAtlas = this.register(new t.EventEmitter()), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new t.EventEmitter()), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new t.EventEmitter()), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onRequestRedraw = this.register(new t.EventEmitter()), this.onRequestRedraw = this._onRequestRedraw.event, this._onContextLoss = this.register(new t.EventEmitter()), this.onContextLoss = this._onContextLoss.event, this.register(this._themeService.onChangeColors(() => this._handleColorChange())), this._cellColorResolver = new o3.CellColorResolver(this._terminal, this._model.selection, this._decorationService, this._coreBrowserService, this._themeService), this._core = this._terminal._core, this._renderLayers = [new u3.LinkRenderLayer(this._core.screenElement, 2, this._terminal, this._core.linkifier2, this._coreBrowserService, M5, this._themeService)], this.dimensions = (0, i4.createRenderDimensions)(), this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this._updateCursorBlink(), this.register(M5.onOptionChange(() => this._handleOptionsChanged())), this._canvas = document.createElement("canvas");
          let H4 = { antialias: false, depth: false, preserveDrawingBuffer: T6 };
          if (this._gl = this._canvas.getContext("webgl2", H4), !this._gl)
            throw new Error("WebGL2 not supported " + this._gl);
          this.register((0, a2.addDisposableDomListener)(this._canvas, "webglcontextlost", (B4) => {
            console.log("webglcontextlost event received"), B4.preventDefault(), this._contextRestorationTimeout = setTimeout(() => {
              this._contextRestorationTimeout = void 0, console.warn("webgl context not restored; firing onContextLoss"), this._onContextLoss.fire(B4);
            }, 3e3);
          })), this.register((0, a2.addDisposableDomListener)(this._canvas, "webglcontextrestored", (B4) => {
            console.warn("webglcontextrestored event received"), clearTimeout(this._contextRestorationTimeout), this._contextRestorationTimeout = void 0, (0, _5.removeTerminalFromCache)(this._terminal), this._initializeWebGLState(), this._requestRedrawViewport();
          })), this.register((0, c3.observeDevicePixelDimensions)(this._canvas, this._coreBrowserService.window, (B4, G5) => this._setCanvasDevicePixelDimensions(B4, G5))), this._core.screenElement.appendChild(this._canvas), [this._rectangleRenderer.value, this._glyphRenderer.value] = this._initializeWebGLState(), this._isAttached = this._coreBrowserService.window.document.body.contains(this._core.screenElement), this.register((0, g4.toDisposable)(() => {
            var B4;
            for (let G5 of this._renderLayers)
              G5.dispose();
            (B4 = this._canvas.parentElement) === null || B4 === void 0 || B4.removeChild(this._canvas), (0, _5.removeTerminalFromCache)(this._terminal);
          }));
        }
        get textureAtlas() {
          var h5;
          return (h5 = this._charAtlas) === null || h5 === void 0 ? void 0 : h5.pages[0].canvas;
        }
        _handleColorChange() {
          this._refreshCharAtlas(), this._clearModel(true);
        }
        handleDevicePixelRatioChange() {
          this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.handleResize(this._terminal.cols, this._terminal.rows));
        }
        handleResize(h5, v5) {
          var f4, b5, y5, w4;
          this._updateDimensions(), this._model.resize(this._terminal.cols, this._terminal.rows);
          for (let M5 of this._renderLayers)
            M5.resize(this._terminal, this.dimensions);
          this._canvas.width = this.dimensions.device.canvas.width, this._canvas.height = this.dimensions.device.canvas.height, this._canvas.style.width = `${this.dimensions.css.canvas.width}px`, this._canvas.style.height = `${this.dimensions.css.canvas.height}px`, this._core.screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._core.screenElement.style.height = `${this.dimensions.css.canvas.height}px`, (f4 = this._rectangleRenderer.value) === null || f4 === void 0 || f4.setDimensions(this.dimensions), (b5 = this._rectangleRenderer.value) === null || b5 === void 0 || b5.handleResize(), (y5 = this._glyphRenderer.value) === null || y5 === void 0 || y5.setDimensions(this.dimensions), (w4 = this._glyphRenderer.value) === null || w4 === void 0 || w4.handleResize(), this._refreshCharAtlas(), this._clearModel(false);
        }
        handleCharSizeChanged() {
          this.handleResize(this._terminal.cols, this._terminal.rows);
        }
        handleBlur() {
          var h5;
          for (let v5 of this._renderLayers)
            v5.handleBlur(this._terminal);
          (h5 = this._cursorBlinkStateManager.value) === null || h5 === void 0 || h5.pause(), this._requestRedrawViewport();
        }
        handleFocus() {
          var h5;
          for (let v5 of this._renderLayers)
            v5.handleFocus(this._terminal);
          (h5 = this._cursorBlinkStateManager.value) === null || h5 === void 0 || h5.resume(), this._requestRedrawViewport();
        }
        handleSelectionChanged(h5, v5, f4) {
          for (let b5 of this._renderLayers)
            b5.handleSelectionChanged(this._terminal, h5, v5, f4);
          this._model.selection.update(this._terminal, h5, v5, f4), this._requestRedrawViewport();
        }
        handleCursorMove() {
          var h5;
          for (let v5 of this._renderLayers)
            v5.handleCursorMove(this._terminal);
          (h5 = this._cursorBlinkStateManager.value) === null || h5 === void 0 || h5.restartBlinkAnimation();
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._refreshCharAtlas(), this._updateCursorBlink();
        }
        _initializeWebGLState() {
          return this._rectangleRenderer.value = new E5.RectangleRenderer(this._terminal, this._gl, this.dimensions, this._themeService), this._glyphRenderer.value = new A5.GlyphRenderer(this._terminal, this._gl, this.dimensions), this.handleCharSizeChanged(), [this._rectangleRenderer.value, this._glyphRenderer.value];
        }
        _refreshCharAtlas() {
          var h5;
          if (this.dimensions.device.char.width <= 0 && this.dimensions.device.char.height <= 0)
            return void (this._isAttached = false);
          let v5 = (0, _5.acquireTextureAtlas)(this._terminal, this._optionsService.rawOptions, this._themeService.colors, this.dimensions.device.cell.width, this.dimensions.device.cell.height, this.dimensions.device.char.width, this.dimensions.device.char.height, this._coreBrowserService.dpr);
          this._charAtlas !== v5 && (this._onChangeTextureAtlas.fire(v5.pages[0].canvas), this._charAtlasDisposable.value = (0, g4.getDisposeArrayDisposable)([(0, t.forwardEvent)(v5.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas), (0, t.forwardEvent)(v5.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)])), this._charAtlas = v5, this._charAtlas.warmUp(), (h5 = this._glyphRenderer.value) === null || h5 === void 0 || h5.setAtlas(this._charAtlas);
        }
        _clearModel(h5) {
          var v5;
          this._model.clear(), h5 && ((v5 = this._glyphRenderer.value) === null || v5 === void 0 || v5.clear());
        }
        clearTextureAtlas() {
          var h5;
          (h5 = this._charAtlas) === null || h5 === void 0 || h5.clearTexture(), this._clearModel(true), this._requestRedrawViewport();
        }
        clear() {
          var h5;
          this._clearModel(true);
          for (let v5 of this._renderLayers)
            v5.reset(this._terminal);
          (h5 = this._cursorBlinkStateManager.value) === null || h5 === void 0 || h5.restartBlinkAnimation(), this._updateCursorBlink();
        }
        registerCharacterJoiner(h5) {
          return -1;
        }
        deregisterCharacterJoiner(h5) {
          return false;
        }
        renderRows(h5, v5) {
          if (!this._isAttached) {
            if (!(this._coreBrowserService.window.document.body.contains(this._core.screenElement) && this._charSizeService.width && this._charSizeService.height))
              return;
            this._updateDimensions(), this._refreshCharAtlas(), this._isAttached = true;
          }
          for (let f4 of this._renderLayers)
            f4.handleGridChanged(this._terminal, h5, v5);
          this._glyphRenderer.value && this._rectangleRenderer.value && (this._glyphRenderer.value.beginFrame() ? (this._clearModel(true), this._updateModel(0, this._terminal.rows - 1)) : this._updateModel(h5, v5), this._rectangleRenderer.value.renderBackgrounds(), this._glyphRenderer.value.render(this._model), this._cursorBlinkStateManager.value && !this._cursorBlinkStateManager.value.isCursorVisible || this._rectangleRenderer.value.renderCursor());
        }
        _updateCursorBlink() {
          this._terminal.options.cursorBlink ? this._cursorBlinkStateManager.value = new p6.CursorBlinkStateManager(() => {
            this._requestRedrawCursor();
          }, this._coreBrowserService) : this._cursorBlinkStateManager.clear(), this._requestRedrawCursor();
        }
        _updateModel(h5, v5) {
          let f4 = this._core, b5, y5, w4, M5, D5, T6, H4, B4, G5, j7, Y5, $5, X5, z4 = this._workCell;
          h5 = n3(h5, f4.rows - 1, 0), v5 = n3(v5, f4.rows - 1, 0);
          let pe3 = this._terminal.buffer.active.baseY + this._terminal.buffer.active.cursorY, re2 = Math.min(this._terminal.buffer.active.cursorX, f4.cols - 1), ce2 = -1, de2 = this._coreService.isCursorInitialized && !this._coreService.isCursorHidden && (!this._cursorBlinkStateManager.value || this._cursorBlinkStateManager.value.isCursorVisible);
          this._model.cursor = void 0;
          let ie3 = false;
          for (y5 = h5; y5 <= v5; y5++)
            for (w4 = y5 + f4.buffer.ydisp, M5 = f4.buffer.lines.get(w4), this._model.lineLengths[y5] = 0, D5 = this._characterJoinerService.getJoinedCharacters(w4), $5 = 0; $5 < f4.cols; $5++)
              if (b5 = this._cellColorResolver.result.bg, M5.loadCell($5, z4), $5 === 0 && (b5 = this._cellColorResolver.result.bg), T6 = false, H4 = $5, D5.length > 0 && $5 === D5[0][0] && (T6 = true, B4 = D5.shift(), z4 = new s2(z4, M5.translateToString(true, B4[0], B4[1]), B4[1] - B4[0]), H4 = B4[1] - 1), G5 = z4.getChars(), j7 = z4.getCode(), Y5 = (y5 * f4.cols + $5) * r.RENDER_MODEL_INDICIES_PER_CELL, this._cellColorResolver.resolve(z4, $5, w4), de2 && w4 === pe3 && ($5 === re2 && (this._model.cursor = { x: re2, y: this._terminal.buffer.active.cursorY, width: z4.getWidth(), style: this._coreBrowserService.isFocused ? f4.options.cursorStyle || "block" : f4.options.cursorInactiveStyle, cursorWidth: f4.options.cursorWidth, dpr: this._devicePixelRatio }, ce2 = re2 + z4.getWidth() - 1), $5 >= re2 && $5 <= ce2 && (this._coreBrowserService.isFocused && (f4.options.cursorStyle || "block") === "block" || this._coreBrowserService.isFocused === false && f4.options.cursorInactiveStyle === "block") && (this._cellColorResolver.result.fg = 50331648 | this._themeService.colors.cursorAccent.rgba >> 8 & 16777215, this._cellColorResolver.result.bg = 50331648 | this._themeService.colors.cursor.rgba >> 8 & 16777215)), j7 !== S6.NULL_CELL_CODE && (this._model.lineLengths[y5] = $5 + 1), (this._model.cells[Y5] !== j7 || this._model.cells[Y5 + r.RENDER_MODEL_BG_OFFSET] !== this._cellColorResolver.result.bg || this._model.cells[Y5 + r.RENDER_MODEL_FG_OFFSET] !== this._cellColorResolver.result.fg || this._model.cells[Y5 + r.RENDER_MODEL_EXT_OFFSET] !== this._cellColorResolver.result.ext) && (ie3 = true, G5.length > 1 && (j7 |= r.COMBINED_CHAR_BIT_MASK), this._model.cells[Y5] = j7, this._model.cells[Y5 + r.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[Y5 + r.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[Y5 + r.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext, this._glyphRenderer.value.updateCell($5, y5, j7, this._cellColorResolver.result.bg, this._cellColorResolver.result.fg, this._cellColorResolver.result.ext, G5, b5), T6))
                for (z4 = this._workCell, $5++; $5 < H4; $5++)
                  X5 = (y5 * f4.cols + $5) * r.RENDER_MODEL_INDICIES_PER_CELL, this._glyphRenderer.value.updateCell($5, y5, S6.NULL_CELL_CODE, 0, 0, 0, S6.NULL_CELL_CHAR, 0), this._model.cells[X5] = S6.NULL_CELL_CODE, this._model.cells[X5 + r.RENDER_MODEL_BG_OFFSET] = this._cellColorResolver.result.bg, this._model.cells[X5 + r.RENDER_MODEL_FG_OFFSET] = this._cellColorResolver.result.fg, this._model.cells[X5 + r.RENDER_MODEL_EXT_OFFSET] = this._cellColorResolver.result.ext;
          ie3 && this._rectangleRenderer.value.updateBackgrounds(this._model), this._rectangleRenderer.value.updateCursor(this._model);
        }
        _updateDimensions() {
          this._charSizeService.width && this._charSizeService.height && (this.dimensions.device.char.width = Math.floor(this._charSizeService.width * this._devicePixelRatio), this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * this._devicePixelRatio), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.top = this._optionsService.rawOptions.lineHeight === 1 ? 0 : Math.round((this.dimensions.device.cell.height - this.dimensions.device.char.height) / 2), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.char.left = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.device.canvas.height = this._terminal.rows * this.dimensions.device.cell.height, this.dimensions.device.canvas.width = this._terminal.cols * this.dimensions.device.cell.width, this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / this._devicePixelRatio), this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / this._devicePixelRatio), this.dimensions.css.cell.height = this.dimensions.device.cell.height / this._devicePixelRatio, this.dimensions.css.cell.width = this.dimensions.device.cell.width / this._devicePixelRatio);
        }
        _setCanvasDevicePixelDimensions(h5, v5) {
          this._canvas.width === h5 && this._canvas.height === v5 || (this._canvas.width = h5, this._canvas.height = v5, this._requestRedrawViewport());
        }
        _requestRedrawViewport() {
          this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });
        }
        _requestRedrawCursor() {
          let h5 = this._terminal.buffer.active.cursorY;
          this._onRequestRedraw.fire({ start: h5, end: h5 });
        }
      }
      e.WebglRenderer = C5, l4([R4.traceCall], C5.prototype, "renderRows", null);
      class s2 extends L5.AttributeData {
        constructor(h5, v5, f4) {
          super(), this.content = 0, this.combinedData = "", this.fg = h5.fg, this.bg = h5.bg, this.combinedData = v5, this._width = f4;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(h5) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      function n3(m6, h5, v5 = 0) {
        return Math.max(Math.min(m6, h5), v5);
      }
      e.JoinedCellData = s2;
    }, 381: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.GLTexture = e.expandFloat32Array = e.createShader = e.createProgram = e.PROJECTION_MATRIX = void 0;
      let l4 = d5(374);
      function a2(o3, _5, p6) {
        let c3 = (0, l4.throwIfFalsy)(o3.createShader(_5));
        if (o3.shaderSource(c3, p6), o3.compileShader(c3), o3.getShaderParameter(c3, o3.COMPILE_STATUS))
          return c3;
        console.error(o3.getShaderInfoLog(c3)), o3.deleteShader(c3);
      }
      e.PROJECTION_MATRIX = new Float32Array([2, 0, 0, 0, 0, -2, 0, 0, 0, 0, 1, 0, -1, 1, 0, 1]), e.createProgram = function(o3, _5, p6) {
        let c3 = (0, l4.throwIfFalsy)(o3.createProgram());
        if (o3.attachShader(c3, (0, l4.throwIfFalsy)(a2(o3, o3.VERTEX_SHADER, _5))), o3.attachShader(c3, (0, l4.throwIfFalsy)(a2(o3, o3.FRAGMENT_SHADER, p6))), o3.linkProgram(c3), o3.getProgramParameter(c3, o3.LINK_STATUS))
          return c3;
        console.error(o3.getProgramInfoLog(c3)), o3.deleteProgram(c3);
      }, e.createShader = a2, e.expandFloat32Array = function(o3, _5) {
        let p6 = Math.min(2 * o3.length, _5), c3 = new Float32Array(p6);
        for (let i4 = 0; i4 < o3.length; i4++)
          c3[i4] = o3[i4];
        return c3;
      }, e.GLTexture = class {
        constructor(o3) {
          this.texture = o3, this.version = -1;
        }
      };
    }, 592: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.BaseRenderLayer = void 0;
      let l4 = d5(627), a2 = d5(237), o3 = d5(374), _5 = d5(859);
      class p6 extends _5.Disposable {
        constructor(i4, t, g4, L5, x5, S6, R4, A5) {
          super(), this._container = t, this._alpha = x5, this._coreBrowserService = S6, this._optionsService = R4, this._themeService = A5, this._deviceCharWidth = 0, this._deviceCharHeight = 0, this._deviceCellWidth = 0, this._deviceCellHeight = 0, this._deviceCharLeft = 0, this._deviceCharTop = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add(`xterm-${g4}-layer`), this._canvas.style.zIndex = L5.toString(), this._initCanvas(), this._container.appendChild(this._canvas), this.register(this._themeService.onChangeColors((E5) => {
            this._refreshCharAtlas(i4, E5), this.reset(i4);
          })), this.register((0, _5.toDisposable)(() => {
            this._canvas.remove();
          }));
        }
        _initCanvas() {
          this._ctx = (0, o3.throwIfFalsy)(this._canvas.getContext("2d", { alpha: this._alpha })), this._alpha || this._clearAll();
        }
        handleBlur(i4) {
        }
        handleFocus(i4) {
        }
        handleCursorMove(i4) {
        }
        handleGridChanged(i4, t, g4) {
        }
        handleSelectionChanged(i4, t, g4, L5 = false) {
        }
        _setTransparency(i4, t) {
          if (t === this._alpha)
            return;
          let g4 = this._canvas;
          this._alpha = t, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, g4), this._refreshCharAtlas(i4, this._themeService.colors), this.handleGridChanged(i4, 0, i4.rows - 1);
        }
        _refreshCharAtlas(i4, t) {
          this._deviceCharWidth <= 0 && this._deviceCharHeight <= 0 || (this._charAtlas = (0, l4.acquireTextureAtlas)(i4, this._optionsService.rawOptions, t, this._deviceCellWidth, this._deviceCellHeight, this._deviceCharWidth, this._deviceCharHeight, this._coreBrowserService.dpr), this._charAtlas.warmUp());
        }
        resize(i4, t) {
          this._deviceCellWidth = t.device.cell.width, this._deviceCellHeight = t.device.cell.height, this._deviceCharWidth = t.device.char.width, this._deviceCharHeight = t.device.char.height, this._deviceCharLeft = t.device.char.left, this._deviceCharTop = t.device.char.top, this._canvas.width = t.device.canvas.width, this._canvas.height = t.device.canvas.height, this._canvas.style.width = `${t.css.canvas.width}px`, this._canvas.style.height = `${t.css.canvas.height}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(i4, this._themeService.colors);
        }
        _fillBottomLineAtCells(i4, t, g4 = 1) {
          this._ctx.fillRect(i4 * this._deviceCellWidth, (t + 1) * this._deviceCellHeight - this._coreBrowserService.dpr - 1, g4 * this._deviceCellWidth, this._coreBrowserService.dpr);
        }
        _clearAll() {
          this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height));
        }
        _clearCells(i4, t, g4, L5) {
          this._alpha ? this._ctx.clearRect(i4 * this._deviceCellWidth, t * this._deviceCellHeight, g4 * this._deviceCellWidth, L5 * this._deviceCellHeight) : (this._ctx.fillStyle = this._themeService.colors.background.css, this._ctx.fillRect(i4 * this._deviceCellWidth, t * this._deviceCellHeight, g4 * this._deviceCellWidth, L5 * this._deviceCellHeight));
        }
        _fillCharTrueColor(i4, t, g4, L5) {
          this._ctx.font = this._getFont(i4, false, false), this._ctx.textBaseline = a2.TEXT_BASELINE, this._clipCell(g4, L5, t.getWidth()), this._ctx.fillText(t.getChars(), g4 * this._deviceCellWidth + this._deviceCharLeft, L5 * this._deviceCellHeight + this._deviceCharTop + this._deviceCharHeight);
        }
        _clipCell(i4, t, g4) {
          this._ctx.beginPath(), this._ctx.rect(i4 * this._deviceCellWidth, t * this._deviceCellHeight, g4 * this._deviceCellWidth, this._deviceCellHeight), this._ctx.clip();
        }
        _getFont(i4, t, g4) {
          return `${g4 ? "italic" : ""} ${t ? i4.options.fontWeightBold : i4.options.fontWeight} ${i4.options.fontSize * this._coreBrowserService.dpr}px ${i4.options.fontFamily}`;
        }
      }
      e.BaseRenderLayer = p6;
    }, 733: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.LinkRenderLayer = void 0;
      let l4 = d5(197), a2 = d5(237), o3 = d5(592);
      class _5 extends o3.BaseRenderLayer {
        constructor(c3, i4, t, g4, L5, x5, S6) {
          super(t, c3, "link", i4, true, L5, x5, S6), this.register(g4.onShowLinkUnderline((R4) => this._handleShowLinkUnderline(R4))), this.register(g4.onHideLinkUnderline((R4) => this._handleHideLinkUnderline(R4)));
        }
        resize(c3, i4) {
          super.resize(c3, i4), this._state = void 0;
        }
        reset(c3) {
          this._clearCurrentLink();
        }
        _clearCurrentLink() {
          if (this._state) {
            this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);
            let c3 = this._state.y2 - this._state.y1 - 1;
            c3 > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, c3), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = void 0;
          }
        }
        _handleShowLinkUnderline(c3) {
          if (c3.fg === a2.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._themeService.colors.background.css : c3.fg !== void 0 && (0, l4.is256Color)(c3.fg) ? this._ctx.fillStyle = this._themeService.colors.ansi[c3.fg].css : this._ctx.fillStyle = this._themeService.colors.foreground.css, c3.y1 === c3.y2)
            this._fillBottomLineAtCells(c3.x1, c3.y1, c3.x2 - c3.x1);
          else {
            this._fillBottomLineAtCells(c3.x1, c3.y1, c3.cols - c3.x1);
            for (let i4 = c3.y1 + 1; i4 < c3.y2; i4++)
              this._fillBottomLineAtCells(0, i4, c3.cols);
            this._fillBottomLineAtCells(0, c3.y2, c3.x2);
          }
          this._state = c3;
        }
        _handleHideLinkUnderline(c3) {
          this._clearCurrentLink();
        }
      }
      e.LinkRenderLayer = _5;
    }, 820: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.addDisposableDomListener = void 0, e.addDisposableDomListener = function(d5, l4, a2, o3) {
        d5.addEventListener(l4, a2, o3);
        let _5 = false;
        return { dispose: () => {
          _5 || (_5 = true, d5.removeEventListener(l4, a2, o3));
        } };
      };
    }, 274: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.CellColorResolver = void 0;
      let d5, l4 = 0, a2 = 0, o3 = false, _5 = false, p6 = false;
      e.CellColorResolver = class {
        constructor(c3, i4, t, g4, L5) {
          this._terminal = c3, this._selectionRenderModel = i4, this._decorationService = t, this._coreBrowserService = g4, this._themeService = L5, this.result = { fg: 0, bg: 0, ext: 0 };
        }
        resolve(c3, i4, t) {
          this.result.bg = c3.bg, this.result.fg = c3.fg, this.result.ext = 268435456 & c3.bg ? c3.extended.ext : 0, a2 = 0, l4 = 0, _5 = false, o3 = false, p6 = false, d5 = this._themeService.colors, this._decorationService.forEachDecorationAtCell(i4, t, "bottom", (g4) => {
            g4.backgroundColorRGB && (a2 = g4.backgroundColorRGB.rgba >> 8 & 16777215, _5 = true), g4.foregroundColorRGB && (l4 = g4.foregroundColorRGB.rgba >> 8 & 16777215, o3 = true);
          }), p6 = this._selectionRenderModel.isCellSelected(this._terminal, i4, t), p6 && (a2 = (this._coreBrowserService.isFocused ? d5.selectionBackgroundOpaque : d5.selectionInactiveBackgroundOpaque).rgba >> 8 & 16777215, _5 = true, d5.selectionForeground && (l4 = d5.selectionForeground.rgba >> 8 & 16777215, o3 = true)), this._decorationService.forEachDecorationAtCell(i4, t, "top", (g4) => {
            g4.backgroundColorRGB && (a2 = g4.backgroundColorRGB.rgba >> 8 & 16777215, _5 = true), g4.foregroundColorRGB && (l4 = g4.foregroundColorRGB.rgba >> 8 & 16777215, o3 = true);
          }), _5 && (a2 = p6 ? -16777216 & c3.bg & -134217729 | a2 | 50331648 : -16777216 & c3.bg | a2 | 50331648), o3 && (l4 = -16777216 & c3.fg & -67108865 | l4 | 50331648), 67108864 & this.result.fg && (_5 && !o3 && (l4 = 50331648 & this.result.bg ? -134217728 & this.result.fg | 67108863 & this.result.bg : -134217728 & this.result.fg | 16777215 & d5.background.rgba >> 8 | 50331648, o3 = true), !_5 && o3 && (a2 = 50331648 & this.result.fg ? -67108864 & this.result.bg | 67108863 & this.result.fg : -67108864 & this.result.bg | 16777215 & d5.foreground.rgba >> 8 | 50331648, _5 = true)), d5 = void 0, this.result.bg = _5 ? a2 : this.result.bg, this.result.fg = o3 ? l4 : this.result.fg;
        }
      };
    }, 627: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.removeTerminalFromCache = e.acquireTextureAtlas = void 0;
      let l4 = d5(509), a2 = d5(197), o3 = [];
      e.acquireTextureAtlas = function(_5, p6, c3, i4, t, g4, L5, x5) {
        let S6 = (0, a2.generateConfig)(i4, t, g4, L5, p6, c3, x5);
        for (let E5 = 0; E5 < o3.length; E5++) {
          let r = o3[E5], u3 = r.ownedBy.indexOf(_5);
          if (u3 >= 0) {
            if ((0, a2.configEquals)(r.config, S6))
              return r.atlas;
            r.ownedBy.length === 1 ? (r.atlas.dispose(), o3.splice(E5, 1)) : r.ownedBy.splice(u3, 1);
            break;
          }
        }
        for (let E5 = 0; E5 < o3.length; E5++) {
          let r = o3[E5];
          if ((0, a2.configEquals)(r.config, S6))
            return r.ownedBy.push(_5), r.atlas;
        }
        let R4 = _5._core, A5 = { atlas: new l4.TextureAtlas(document, S6, R4.unicodeService), config: S6, ownedBy: [_5] };
        return o3.push(A5), A5.atlas;
      }, e.removeTerminalFromCache = function(_5) {
        for (let p6 = 0; p6 < o3.length; p6++) {
          let c3 = o3[p6].ownedBy.indexOf(_5);
          if (c3 !== -1) {
            o3[p6].ownedBy.length === 1 ? (o3[p6].atlas.dispose(), o3.splice(p6, 1)) : o3[p6].ownedBy.splice(c3, 1);
            break;
          }
        }
      };
    }, 197: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.is256Color = e.configEquals = e.generateConfig = void 0;
      let l4 = d5(160);
      e.generateConfig = function(a2, o3, _5, p6, c3, i4, t) {
        let g4 = { foreground: i4.foreground, background: i4.background, cursor: l4.NULL_COLOR, cursorAccent: l4.NULL_COLOR, selectionForeground: l4.NULL_COLOR, selectionBackgroundTransparent: l4.NULL_COLOR, selectionBackgroundOpaque: l4.NULL_COLOR, selectionInactiveBackgroundTransparent: l4.NULL_COLOR, selectionInactiveBackgroundOpaque: l4.NULL_COLOR, ansi: i4.ansi.slice(), contrastCache: i4.contrastCache, halfContrastCache: i4.halfContrastCache };
        return { customGlyphs: c3.customGlyphs, devicePixelRatio: t, letterSpacing: c3.letterSpacing, lineHeight: c3.lineHeight, deviceCellWidth: a2, deviceCellHeight: o3, deviceCharWidth: _5, deviceCharHeight: p6, fontFamily: c3.fontFamily, fontSize: c3.fontSize, fontWeight: c3.fontWeight, fontWeightBold: c3.fontWeightBold, allowTransparency: c3.allowTransparency, drawBoldTextInBrightColors: c3.drawBoldTextInBrightColors, minimumContrastRatio: c3.minimumContrastRatio, colors: g4 };
      }, e.configEquals = function(a2, o3) {
        for (let _5 = 0; _5 < a2.colors.ansi.length; _5++)
          if (a2.colors.ansi[_5].rgba !== o3.colors.ansi[_5].rgba)
            return false;
        return a2.devicePixelRatio === o3.devicePixelRatio && a2.customGlyphs === o3.customGlyphs && a2.lineHeight === o3.lineHeight && a2.letterSpacing === o3.letterSpacing && a2.fontFamily === o3.fontFamily && a2.fontSize === o3.fontSize && a2.fontWeight === o3.fontWeight && a2.fontWeightBold === o3.fontWeightBold && a2.allowTransparency === o3.allowTransparency && a2.deviceCharWidth === o3.deviceCharWidth && a2.deviceCharHeight === o3.deviceCharHeight && a2.drawBoldTextInBrightColors === o3.drawBoldTextInBrightColors && a2.minimumContrastRatio === o3.minimumContrastRatio && a2.colors.foreground.rgba === o3.colors.foreground.rgba && a2.colors.background.rgba === o3.colors.background.rgba;
      }, e.is256Color = function(a2) {
        return (50331648 & a2) == 16777216 || (50331648 & a2) == 33554432;
      };
    }, 237: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.TEXT_BASELINE = e.DIM_OPACITY = e.INVERTED_DEFAULT_COLOR = void 0;
      let l4 = d5(399);
      e.INVERTED_DEFAULT_COLOR = 257, e.DIM_OPACITY = 0.5, e.TEXT_BASELINE = l4.isFirefox || l4.isLegacyEdge ? "bottom" : "ideographic";
    }, 457: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.CursorBlinkStateManager = void 0, e.CursorBlinkStateManager = class {
        constructor(d5, l4) {
          this._renderCallback = d5, this._coreBrowserService = l4, this.isCursorVisible = true, this._coreBrowserService.isFocused && this._restartInterval();
        }
        get isPaused() {
          return !(this._blinkStartTimeout || this._blinkInterval);
        }
        dispose() {
          this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        restartBlinkAnimation() {
          this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = true, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
            this._renderCallback(), this._animationFrame = void 0;
          })));
        }
        _restartInterval(d5 = 600) {
          this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(() => {
            if (this._animationTimeRestarted) {
              let l4 = 600 - (Date.now() - this._animationTimeRestarted);
              if (this._animationTimeRestarted = void 0, l4 > 0)
                return void this._restartInterval(l4);
            }
            this.isCursorVisible = false, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
              this._renderCallback(), this._animationFrame = void 0;
            }), this._blinkInterval = this._coreBrowserService.window.setInterval(() => {
              if (this._animationTimeRestarted) {
                let l4 = 600 - (Date.now() - this._animationTimeRestarted);
                return this._animationTimeRestarted = void 0, void this._restartInterval(l4);
              }
              this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
                this._renderCallback(), this._animationFrame = void 0;
              });
            }, 600);
          }, d5);
        }
        pause() {
          this.isCursorVisible = true, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        resume() {
          this.pause(), this._animationTimeRestarted = void 0, this._restartInterval(), this.restartBlinkAnimation();
        }
      };
    }, 860: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.tryDrawCustomChar = e.powerlineDefinitions = e.boxDrawingDefinitions = e.blockElementDefinitions = void 0;
      let l4 = d5(374);
      e.blockElementDefinitions = { "\u2580": [{ x: 0, y: 0, w: 8, h: 4 }], "\u2581": [{ x: 0, y: 7, w: 8, h: 1 }], "\u2582": [{ x: 0, y: 6, w: 8, h: 2 }], "\u2583": [{ x: 0, y: 5, w: 8, h: 3 }], "\u2584": [{ x: 0, y: 4, w: 8, h: 4 }], "\u2585": [{ x: 0, y: 3, w: 8, h: 5 }], "\u2586": [{ x: 0, y: 2, w: 8, h: 6 }], "\u2587": [{ x: 0, y: 1, w: 8, h: 7 }], "\u2588": [{ x: 0, y: 0, w: 8, h: 8 }], "\u2589": [{ x: 0, y: 0, w: 7, h: 8 }], "\u258A": [{ x: 0, y: 0, w: 6, h: 8 }], "\u258B": [{ x: 0, y: 0, w: 5, h: 8 }], "\u258C": [{ x: 0, y: 0, w: 4, h: 8 }], "\u258D": [{ x: 0, y: 0, w: 3, h: 8 }], "\u258E": [{ x: 0, y: 0, w: 2, h: 8 }], "\u258F": [{ x: 0, y: 0, w: 1, h: 8 }], "\u2590": [{ x: 4, y: 0, w: 4, h: 8 }], "\u2594": [{ x: 0, y: 0, w: 8, h: 1 }], "\u2595": [{ x: 7, y: 0, w: 1, h: 8 }], "\u2596": [{ x: 0, y: 4, w: 4, h: 4 }], "\u2597": [{ x: 4, y: 4, w: 4, h: 4 }], "\u2598": [{ x: 0, y: 0, w: 4, h: 4 }], "\u2599": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "\u259A": [{ x: 0, y: 0, w: 4, h: 4 }, { x: 4, y: 4, w: 4, h: 4 }], "\u259B": [{ x: 0, y: 0, w: 4, h: 8 }, { x: 4, y: 0, w: 4, h: 4 }], "\u259C": [{ x: 0, y: 0, w: 8, h: 4 }, { x: 4, y: 0, w: 4, h: 8 }], "\u259D": [{ x: 4, y: 0, w: 4, h: 4 }], "\u259E": [{ x: 4, y: 0, w: 4, h: 4 }, { x: 0, y: 4, w: 4, h: 4 }], "\u259F": [{ x: 4, y: 0, w: 4, h: 8 }, { x: 0, y: 4, w: 8, h: 4 }], "\u{1FB70}": [{ x: 1, y: 0, w: 1, h: 8 }], "\u{1FB71}": [{ x: 2, y: 0, w: 1, h: 8 }], "\u{1FB72}": [{ x: 3, y: 0, w: 1, h: 8 }], "\u{1FB73}": [{ x: 4, y: 0, w: 1, h: 8 }], "\u{1FB74}": [{ x: 5, y: 0, w: 1, h: 8 }], "\u{1FB75}": [{ x: 6, y: 0, w: 1, h: 8 }], "\u{1FB76}": [{ x: 0, y: 1, w: 8, h: 1 }], "\u{1FB77}": [{ x: 0, y: 2, w: 8, h: 1 }], "\u{1FB78}": [{ x: 0, y: 3, w: 8, h: 1 }], "\u{1FB79}": [{ x: 0, y: 4, w: 8, h: 1 }], "\u{1FB7A}": [{ x: 0, y: 5, w: 8, h: 1 }], "\u{1FB7B}": [{ x: 0, y: 6, w: 8, h: 1 }], "\u{1FB7C}": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "\u{1FB7D}": [{ x: 0, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "\u{1FB7E}": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 0, w: 8, h: 1 }], "\u{1FB7F}": [{ x: 7, y: 0, w: 1, h: 8 }, { x: 0, y: 7, w: 8, h: 1 }], "\u{1FB80}": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "\u{1FB81}": [{ x: 0, y: 0, w: 8, h: 1 }, { x: 0, y: 2, w: 8, h: 1 }, { x: 0, y: 4, w: 8, h: 1 }, { x: 0, y: 7, w: 8, h: 1 }], "\u{1FB82}": [{ x: 0, y: 0, w: 8, h: 2 }], "\u{1FB83}": [{ x: 0, y: 0, w: 8, h: 3 }], "\u{1FB84}": [{ x: 0, y: 0, w: 8, h: 5 }], "\u{1FB85}": [{ x: 0, y: 0, w: 8, h: 6 }], "\u{1FB86}": [{ x: 0, y: 0, w: 8, h: 7 }], "\u{1FB87}": [{ x: 6, y: 0, w: 2, h: 8 }], "\u{1FB88}": [{ x: 5, y: 0, w: 3, h: 8 }], "\u{1FB89}": [{ x: 3, y: 0, w: 5, h: 8 }], "\u{1FB8A}": [{ x: 2, y: 0, w: 6, h: 8 }], "\u{1FB8B}": [{ x: 1, y: 0, w: 7, h: 8 }], "\u{1FB95}": [{ x: 0, y: 0, w: 2, h: 2 }, { x: 4, y: 0, w: 2, h: 2 }, { x: 2, y: 2, w: 2, h: 2 }, { x: 6, y: 2, w: 2, h: 2 }, { x: 0, y: 4, w: 2, h: 2 }, { x: 4, y: 4, w: 2, h: 2 }, { x: 2, y: 6, w: 2, h: 2 }, { x: 6, y: 6, w: 2, h: 2 }], "\u{1FB96}": [{ x: 2, y: 0, w: 2, h: 2 }, { x: 6, y: 0, w: 2, h: 2 }, { x: 0, y: 2, w: 2, h: 2 }, { x: 4, y: 2, w: 2, h: 2 }, { x: 2, y: 4, w: 2, h: 2 }, { x: 6, y: 4, w: 2, h: 2 }, { x: 0, y: 6, w: 2, h: 2 }, { x: 4, y: 6, w: 2, h: 2 }], "\u{1FB97}": [{ x: 0, y: 2, w: 8, h: 2 }, { x: 0, y: 6, w: 8, h: 2 }] };
      let a2 = { "\u2591": [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]], "\u2592": [[1, 0], [0, 0], [0, 1], [0, 0]], "\u2593": [[0, 1], [1, 1], [1, 0], [1, 1]] };
      e.boxDrawingDefinitions = { "\u2500": { 1: "M0,.5 L1,.5" }, "\u2501": { 3: "M0,.5 L1,.5" }, "\u2502": { 1: "M.5,0 L.5,1" }, "\u2503": { 3: "M.5,0 L.5,1" }, "\u250C": { 1: "M0.5,1 L.5,.5 L1,.5" }, "\u250F": { 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2510": { 1: "M0,.5 L.5,.5 L.5,1" }, "\u2513": { 3: "M0,.5 L.5,.5 L.5,1" }, "\u2514": { 1: "M.5,0 L.5,.5 L1,.5" }, "\u2517": { 3: "M.5,0 L.5,.5 L1,.5" }, "\u2518": { 1: "M.5,0 L.5,.5 L0,.5" }, "\u251B": { 3: "M.5,0 L.5,.5 L0,.5" }, "\u251C": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u2523": { 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u2524": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u252B": { 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u252C": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2533": { 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2534": { 1: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "\u253B": { 3: "M0,.5 L1,.5 M.5,.5 L.5,0" }, "\u253C": { 1: "M0,.5 L1,.5 M.5,0 L.5,1" }, "\u254B": { 3: "M0,.5 L1,.5 M.5,0 L.5,1" }, "\u2574": { 1: "M.5,.5 L0,.5" }, "\u2578": { 3: "M.5,.5 L0,.5" }, "\u2575": { 1: "M.5,.5 L.5,0" }, "\u2579": { 3: "M.5,.5 L.5,0" }, "\u2576": { 1: "M.5,.5 L1,.5" }, "\u257A": { 3: "M.5,.5 L1,.5" }, "\u2577": { 1: "M.5,.5 L.5,1" }, "\u257B": { 3: "M.5,.5 L.5,1" }, "\u2550": { 1: (i4, t) => `M0,${0.5 - t} L1,${0.5 - t} M0,${0.5 + t} L1,${0.5 + t}` }, "\u2551": { 1: (i4, t) => `M${0.5 - i4},0 L${0.5 - i4},1 M${0.5 + i4},0 L${0.5 + i4},1` }, "\u2552": { 1: (i4, t) => `M.5,1 L.5,${0.5 - t} L1,${0.5 - t} M.5,${0.5 + t} L1,${0.5 + t}` }, "\u2553": { 1: (i4, t) => `M${0.5 - i4},1 L${0.5 - i4},.5 L1,.5 M${0.5 + i4},.5 L${0.5 + i4},1` }, "\u2554": { 1: (i4, t) => `M1,${0.5 - t} L${0.5 - i4},${0.5 - t} L${0.5 - i4},1 M1,${0.5 + t} L${0.5 + i4},${0.5 + t} L${0.5 + i4},1` }, "\u2555": { 1: (i4, t) => `M0,${0.5 - t} L.5,${0.5 - t} L.5,1 M0,${0.5 + t} L.5,${0.5 + t}` }, "\u2556": { 1: (i4, t) => `M${0.5 + i4},1 L${0.5 + i4},.5 L0,.5 M${0.5 - i4},.5 L${0.5 - i4},1` }, "\u2557": { 1: (i4, t) => `M0,${0.5 + t} L${0.5 - i4},${0.5 + t} L${0.5 - i4},1 M0,${0.5 - t} L${0.5 + i4},${0.5 - t} L${0.5 + i4},1` }, "\u2558": { 1: (i4, t) => `M.5,0 L.5,${0.5 + t} L1,${0.5 + t} M.5,${0.5 - t} L1,${0.5 - t}` }, "\u2559": { 1: (i4, t) => `M1,.5 L${0.5 - i4},.5 L${0.5 - i4},0 M${0.5 + i4},.5 L${0.5 + i4},0` }, "\u255A": { 1: (i4, t) => `M1,${0.5 - t} L${0.5 + i4},${0.5 - t} L${0.5 + i4},0 M1,${0.5 + t} L${0.5 - i4},${0.5 + t} L${0.5 - i4},0` }, "\u255B": { 1: (i4, t) => `M0,${0.5 + t} L.5,${0.5 + t} L.5,0 M0,${0.5 - t} L.5,${0.5 - t}` }, "\u255C": { 1: (i4, t) => `M0,.5 L${0.5 + i4},.5 L${0.5 + i4},0 M${0.5 - i4},.5 L${0.5 - i4},0` }, "\u255D": { 1: (i4, t) => `M0,${0.5 - t} L${0.5 - i4},${0.5 - t} L${0.5 - i4},0 M0,${0.5 + t} L${0.5 + i4},${0.5 + t} L${0.5 + i4},0` }, "\u255E": { 1: (i4, t) => `M.5,0 L.5,1 M.5,${0.5 - t} L1,${0.5 - t} M.5,${0.5 + t} L1,${0.5 + t}` }, "\u255F": { 1: (i4, t) => `M${0.5 - i4},0 L${0.5 - i4},1 M${0.5 + i4},0 L${0.5 + i4},1 M${0.5 + i4},.5 L1,.5` }, "\u2560": { 1: (i4, t) => `M${0.5 - i4},0 L${0.5 - i4},1 M1,${0.5 + t} L${0.5 + i4},${0.5 + t} L${0.5 + i4},1 M1,${0.5 - t} L${0.5 + i4},${0.5 - t} L${0.5 + i4},0` }, "\u2561": { 1: (i4, t) => `M.5,0 L.5,1 M0,${0.5 - t} L.5,${0.5 - t} M0,${0.5 + t} L.5,${0.5 + t}` }, "\u2562": { 1: (i4, t) => `M0,.5 L${0.5 - i4},.5 M${0.5 - i4},0 L${0.5 - i4},1 M${0.5 + i4},0 L${0.5 + i4},1` }, "\u2563": { 1: (i4, t) => `M${0.5 + i4},0 L${0.5 + i4},1 M0,${0.5 + t} L${0.5 - i4},${0.5 + t} L${0.5 - i4},1 M0,${0.5 - t} L${0.5 - i4},${0.5 - t} L${0.5 - i4},0` }, "\u2564": { 1: (i4, t) => `M0,${0.5 - t} L1,${0.5 - t} M0,${0.5 + t} L1,${0.5 + t} M.5,${0.5 + t} L.5,1` }, "\u2565": { 1: (i4, t) => `M0,.5 L1,.5 M${0.5 - i4},.5 L${0.5 - i4},1 M${0.5 + i4},.5 L${0.5 + i4},1` }, "\u2566": { 1: (i4, t) => `M0,${0.5 - t} L1,${0.5 - t} M0,${0.5 + t} L${0.5 - i4},${0.5 + t} L${0.5 - i4},1 M1,${0.5 + t} L${0.5 + i4},${0.5 + t} L${0.5 + i4},1` }, "\u2567": { 1: (i4, t) => `M.5,0 L.5,${0.5 - t} M0,${0.5 - t} L1,${0.5 - t} M0,${0.5 + t} L1,${0.5 + t}` }, "\u2568": { 1: (i4, t) => `M0,.5 L1,.5 M${0.5 - i4},.5 L${0.5 - i4},0 M${0.5 + i4},.5 L${0.5 + i4},0` }, "\u2569": { 1: (i4, t) => `M0,${0.5 + t} L1,${0.5 + t} M0,${0.5 - t} L${0.5 - i4},${0.5 - t} L${0.5 - i4},0 M1,${0.5 - t} L${0.5 + i4},${0.5 - t} L${0.5 + i4},0` }, "\u256A": { 1: (i4, t) => `M.5,0 L.5,1 M0,${0.5 - t} L1,${0.5 - t} M0,${0.5 + t} L1,${0.5 + t}` }, "\u256B": { 1: (i4, t) => `M0,.5 L1,.5 M${0.5 - i4},0 L${0.5 - i4},1 M${0.5 + i4},0 L${0.5 + i4},1` }, "\u256C": { 1: (i4, t) => `M0,${0.5 + t} L${0.5 - i4},${0.5 + t} L${0.5 - i4},1 M1,${0.5 + t} L${0.5 + i4},${0.5 + t} L${0.5 + i4},1 M0,${0.5 - t} L${0.5 - i4},${0.5 - t} L${0.5 - i4},0 M1,${0.5 - t} L${0.5 + i4},${0.5 - t} L${0.5 + i4},0` }, "\u2571": { 1: "M1,0 L0,1" }, "\u2572": { 1: "M0,0 L1,1" }, "\u2573": { 1: "M1,0 L0,1 M0,0 L1,1" }, "\u257C": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u257D": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L.5,1" }, "\u257E": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u257F": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u250D": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "\u250E": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2511": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L0,.5" }, "\u2512": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "\u2515": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L1,.5" }, "\u2516": { 1: "M.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u2519": { 1: "M.5,.5 L.5,0", 3: "M.5,.5 L0,.5" }, "\u251A": { 1: "M.5,.5 L0,.5", 3: "M.5,.5 L.5,0" }, "\u251D": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L1,.5" }, "\u251E": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u251F": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2520": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1" }, "\u2521": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "\u2522": { 1: "M.5,.5 L.5,0", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2525": { 1: "M.5,0 L.5,1", 3: "M.5,.5 L0,.5" }, "\u2526": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u2527": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L.5,1" }, "\u2528": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1" }, "\u2529": { 1: "M.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L0,.5" }, "\u252A": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L.5,.5 L.5,1" }, "\u252D": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u252E": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,.5 L1,.5" }, "\u252F": { 1: "M.5,.5 L.5,1", 3: "M0,.5 L1,.5" }, "\u2530": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2531": { 1: "M.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "\u2532": { 1: "M.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2535": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u2536": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u2537": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5" }, "\u2538": { 1: "M0,.5 L1,.5", 3: "M.5,.5 L.5,0" }, "\u2539": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "\u253A": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,.5 L1,.5" }, "\u253D": { 1: "M.5,0 L.5,1 M.5,.5 L1,.5", 3: "M.5,.5 L0,.5" }, "\u253E": { 1: "M.5,0 L.5,1 M.5,.5 L0,.5", 3: "M.5,.5 L1,.5" }, "\u253F": { 1: "M.5,0 L.5,1", 3: "M0,.5 L1,.5" }, "\u2540": { 1: "M0,.5 L1,.5 M.5,.5 L.5,1", 3: "M.5,.5 L.5,0" }, "\u2541": { 1: "M.5,.5 L.5,0 M0,.5 L1,.5", 3: "M.5,.5 L.5,1" }, "\u2542": { 1: "M0,.5 L1,.5", 3: "M.5,0 L.5,1" }, "\u2543": { 1: "M0.5,1 L.5,.5 L1,.5", 3: "M.5,0 L.5,.5 L0,.5" }, "\u2544": { 1: "M0,.5 L.5,.5 L.5,1", 3: "M.5,0 L.5,.5 L1,.5" }, "\u2545": { 1: "M.5,0 L.5,.5 L1,.5", 3: "M0,.5 L.5,.5 L.5,1" }, "\u2546": { 1: "M.5,0 L.5,.5 L0,.5", 3: "M0.5,1 L.5,.5 L1,.5" }, "\u2547": { 1: "M.5,.5 L.5,1", 3: "M.5,.5 L.5,0 M0,.5 L1,.5" }, "\u2548": { 1: "M.5,.5 L.5,0", 3: "M0,.5 L1,.5 M.5,.5 L.5,1" }, "\u2549": { 1: "M.5,.5 L1,.5", 3: "M.5,0 L.5,1 M.5,.5 L0,.5" }, "\u254A": { 1: "M.5,.5 L0,.5", 3: "M.5,0 L.5,1 M.5,.5 L1,.5" }, "\u254C": { 1: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "\u254D": { 3: "M.1,.5 L.4,.5 M.6,.5 L.9,.5" }, "\u2504": { 1: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "\u2505": { 3: "M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5" }, "\u2508": { 1: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "\u2509": { 3: "M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5" }, "\u254E": { 1: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "\u254F": { 3: "M.5,.1 L.5,.4 M.5,.6 L.5,.9" }, "\u2506": { 1: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "\u2507": { 3: "M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333" }, "\u250A": { 1: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "\u250B": { 3: "M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95" }, "\u256D": { 1: (i4, t) => `M.5,1 L.5,${0.5 + t / 0.15 * 0.5} C.5,${0.5 + t / 0.15 * 0.5},.5,.5,1,.5` }, "\u256E": { 1: (i4, t) => `M.5,1 L.5,${0.5 + t / 0.15 * 0.5} C.5,${0.5 + t / 0.15 * 0.5},.5,.5,0,.5` }, "\u256F": { 1: (i4, t) => `M.5,0 L.5,${0.5 - t / 0.15 * 0.5} C.5,${0.5 - t / 0.15 * 0.5},.5,.5,0,.5` }, "\u2570": { 1: (i4, t) => `M.5,0 L.5,${0.5 - t / 0.15 * 0.5} C.5,${0.5 - t / 0.15 * 0.5},.5,.5,1,.5` } }, e.powerlineDefinitions = { "\uE0B0": { d: "M0,0 L1,.5 L0,1", type: 0, rightPadding: 2 }, "\uE0B1": { d: "M-1,-.5 L1,.5 L-1,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0B2": { d: "M1,0 L0,.5 L1,1", type: 0, leftPadding: 2 }, "\uE0B3": { d: "M2,-.5 L0,.5 L2,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0B4": { d: "M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0", type: 0, rightPadding: 1 }, "\uE0B5": { d: "M.2,1 C.422,1,.8,.826,.78,.5 C.8,.174,0.422,0,.2,0", type: 1, rightPadding: 1 }, "\uE0B6": { d: "M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0", type: 0, leftPadding: 1 }, "\uE0B7": { d: "M.8,1 C0.578,1,0.2,.826,.22,.5 C0.2,0.174,0.578,0,0.8,0", type: 1, leftPadding: 1 }, "\uE0B8": { d: "M-.5,-.5 L1.5,1.5 L-.5,1.5", type: 0 }, "\uE0B9": { d: "M-.5,-.5 L1.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0BA": { d: "M1.5,-.5 L-.5,1.5 L1.5,1.5", type: 0 }, "\uE0BC": { d: "M1.5,-.5 L-.5,1.5 L-.5,-.5", type: 0 }, "\uE0BD": { d: "M1.5,-.5 L-.5,1.5", type: 1, leftPadding: 1, rightPadding: 1 }, "\uE0BE": { d: "M-.5,-.5 L1.5,1.5 L1.5,-.5", type: 0 } }, e.powerlineDefinitions["\uE0BB"] = e.powerlineDefinitions["\uE0BD"], e.powerlineDefinitions["\uE0BF"] = e.powerlineDefinitions["\uE0B9"], e.tryDrawCustomChar = function(i4, t, g4, L5, x5, S6, R4, A5) {
        let E5 = e.blockElementDefinitions[t];
        if (E5)
          return function(s2, n3, m6, h5, v5, f4) {
            for (let b5 = 0; b5 < n3.length; b5++) {
              let y5 = n3[b5], w4 = v5 / 8, M5 = f4 / 8;
              s2.fillRect(m6 + y5.x * w4, h5 + y5.y * M5, y5.w * w4, y5.h * M5);
            }
          }(i4, E5, g4, L5, x5, S6), true;
        let r = a2[t];
        if (r)
          return function(s2, n3, m6, h5, v5, f4) {
            let b5 = o3.get(n3);
            b5 || (b5 = /* @__PURE__ */ new Map(), o3.set(n3, b5));
            let y5 = s2.fillStyle;
            if (typeof y5 != "string")
              throw new Error(`Unexpected fillStyle type "${y5}"`);
            let w4 = b5.get(y5);
            if (!w4) {
              let M5 = n3[0].length, D5 = n3.length, T6 = document.createElement("canvas");
              T6.width = M5, T6.height = D5;
              let H4 = (0, l4.throwIfFalsy)(T6.getContext("2d")), B4 = new ImageData(M5, D5), G5, j7, Y5, $5;
              if (y5.startsWith("#"))
                G5 = parseInt(y5.slice(1, 3), 16), j7 = parseInt(y5.slice(3, 5), 16), Y5 = parseInt(y5.slice(5, 7), 16), $5 = y5.length > 7 && parseInt(y5.slice(7, 9), 16) || 1;
              else {
                if (!y5.startsWith("rgba"))
                  throw new Error(`Unexpected fillStyle color format "${y5}" when drawing pattern glyph`);
                [G5, j7, Y5, $5] = y5.substring(5, y5.length - 1).split(",").map((X5) => parseFloat(X5));
              }
              for (let X5 = 0; X5 < D5; X5++)
                for (let z4 = 0; z4 < M5; z4++)
                  B4.data[4 * (X5 * M5 + z4)] = G5, B4.data[4 * (X5 * M5 + z4) + 1] = j7, B4.data[4 * (X5 * M5 + z4) + 2] = Y5, B4.data[4 * (X5 * M5 + z4) + 3] = n3[X5][z4] * (255 * $5);
              H4.putImageData(B4, 0, 0), w4 = (0, l4.throwIfFalsy)(s2.createPattern(T6, null)), b5.set(y5, w4);
            }
            s2.fillStyle = w4, s2.fillRect(m6, h5, v5, f4);
          }(i4, r, g4, L5, x5, S6), true;
        let u3 = e.boxDrawingDefinitions[t];
        if (u3)
          return function(s2, n3, m6, h5, v5, f4, b5) {
            s2.strokeStyle = s2.fillStyle;
            for (let [y5, w4] of Object.entries(n3)) {
              let M5;
              s2.beginPath(), s2.lineWidth = b5 * Number.parseInt(y5), M5 = typeof w4 == "function" ? w4(0.15, 0.15 / f4 * v5) : w4;
              for (let D5 of M5.split(" ")) {
                let T6 = D5[0], H4 = p6[T6];
                if (!H4) {
                  console.error(`Could not find drawing instructions for "${T6}"`);
                  continue;
                }
                let B4 = D5.substring(1).split(",");
                B4[0] && B4[1] && H4(s2, c3(B4, v5, f4, m6, h5, true, b5));
              }
              s2.stroke(), s2.closePath();
            }
          }(i4, u3, g4, L5, x5, S6, A5), true;
        let C5 = e.powerlineDefinitions[t];
        return !!C5 && (function(s2, n3, m6, h5, v5, f4, b5, y5) {
          var w4, M5;
          let D5 = new Path2D();
          D5.rect(m6, h5, v5, f4), s2.clip(D5), s2.beginPath();
          let T6 = b5 / 12;
          s2.lineWidth = y5 * T6;
          for (let H4 of n3.d.split(" ")) {
            let B4 = H4[0], G5 = p6[B4];
            if (!G5) {
              console.error(`Could not find drawing instructions for "${B4}"`);
              continue;
            }
            let j7 = H4.substring(1).split(",");
            j7[0] && j7[1] && G5(s2, c3(j7, v5, f4, m6, h5, false, y5, ((w4 = n3.leftPadding) !== null && w4 !== void 0 ? w4 : 0) * (T6 / 2), ((M5 = n3.rightPadding) !== null && M5 !== void 0 ? M5 : 0) * (T6 / 2)));
          }
          n3.type === 1 ? (s2.strokeStyle = s2.fillStyle, s2.stroke()) : s2.fill(), s2.closePath();
        }(i4, C5, g4, L5, x5, S6, R4, A5), true);
      };
      let o3 = /* @__PURE__ */ new Map();
      function _5(i4, t, g4 = 0) {
        return Math.max(Math.min(i4, t), g4);
      }
      let p6 = { C: (i4, t) => i4.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]), L: (i4, t) => i4.lineTo(t[0], t[1]), M: (i4, t) => i4.moveTo(t[0], t[1]) };
      function c3(i4, t, g4, L5, x5, S6, R4, A5 = 0, E5 = 0) {
        let r = i4.map((u3) => parseFloat(u3) || parseInt(u3));
        if (r.length < 2)
          throw new Error("Too few arguments for instruction");
        for (let u3 = 0; u3 < r.length; u3 += 2)
          r[u3] *= t - A5 * R4 - E5 * R4, S6 && r[u3] !== 0 && (r[u3] = _5(Math.round(r[u3] + 0.5) - 0.5, t, 0)), r[u3] += L5 + A5 * R4;
        for (let u3 = 1; u3 < r.length; u3 += 2)
          r[u3] *= g4, S6 && r[u3] !== 0 && (r[u3] = _5(Math.round(r[u3] + 0.5) - 0.5, g4, 0)), r[u3] += x5;
        return r;
      }
    }, 56: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.observeDevicePixelDimensions = void 0;
      let l4 = d5(859);
      e.observeDevicePixelDimensions = function(a2, o3, _5) {
        let p6 = new o3.ResizeObserver((c3) => {
          let i4 = c3.find((L5) => L5.target === a2);
          if (!i4)
            return;
          if (!("devicePixelContentBoxSize" in i4))
            return p6?.disconnect(), void (p6 = void 0);
          let t = i4.devicePixelContentBoxSize[0].inlineSize, g4 = i4.devicePixelContentBoxSize[0].blockSize;
          t > 0 && g4 > 0 && _5(t, g4);
        });
        try {
          p6.observe(a2, { box: ["device-pixel-content-box"] });
        } catch {
          p6.disconnect(), p6 = void 0;
        }
        return (0, l4.toDisposable)(() => p6?.disconnect());
      };
    }, 374: (P7, e) => {
      function d5(l4) {
        return 57508 <= l4 && l4 <= 57558;
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.createRenderDimensions = e.excludeFromContrastRatioDemands = e.isRestrictedPowerlineGlyph = e.isPowerlineGlyph = e.throwIfFalsy = void 0, e.throwIfFalsy = function(l4) {
        if (!l4)
          throw new Error("value must not be falsy");
        return l4;
      }, e.isPowerlineGlyph = d5, e.isRestrictedPowerlineGlyph = function(l4) {
        return 57520 <= l4 && l4 <= 57527;
      }, e.excludeFromContrastRatioDemands = function(l4) {
        return d5(l4) || function(a2) {
          return 9472 <= a2 && a2 <= 9631;
        }(l4);
      }, e.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      };
    }, 296: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.createSelectionRenderModel = void 0;
      class d5 {
        constructor() {
          this.clear();
        }
        clear() {
          this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
        }
        update(a2, o3, _5, p6 = false) {
          if (this.selectionStart = o3, this.selectionEnd = _5, !o3 || !_5 || o3[0] === _5[0] && o3[1] === _5[1])
            return void this.clear();
          let c3 = o3[1] - a2.buffer.active.viewportY, i4 = _5[1] - a2.buffer.active.viewportY, t = Math.max(c3, 0), g4 = Math.min(i4, a2.rows - 1);
          t >= a2.rows || g4 < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = p6, this.viewportStartRow = c3, this.viewportEndRow = i4, this.viewportCappedStartRow = t, this.viewportCappedEndRow = g4, this.startCol = o3[0], this.endCol = _5[0]);
        }
        isCellSelected(a2, o3, _5) {
          return !!this.hasSelection && (_5 -= a2.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? o3 >= this.startCol && _5 >= this.viewportCappedStartRow && o3 < this.endCol && _5 <= this.viewportCappedEndRow : o3 < this.startCol && _5 >= this.viewportCappedStartRow && o3 >= this.endCol && _5 <= this.viewportCappedEndRow : _5 > this.viewportStartRow && _5 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && _5 === this.viewportStartRow && o3 >= this.startCol && o3 < this.endCol || this.viewportStartRow < this.viewportEndRow && _5 === this.viewportEndRow && o3 < this.endCol || this.viewportStartRow < this.viewportEndRow && _5 === this.viewportStartRow && o3 >= this.startCol);
        }
      }
      e.createSelectionRenderModel = function() {
        return new d5();
      };
    }, 509: function(P7, e, d5) {
      var l4 = this && this.__decorate || function(C5, s2, n3, m6) {
        var h5, v5 = arguments.length, f4 = v5 < 3 ? s2 : m6 === null ? m6 = Object.getOwnPropertyDescriptor(s2, n3) : m6;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          f4 = Reflect.decorate(C5, s2, n3, m6);
        else
          for (var b5 = C5.length - 1; b5 >= 0; b5--)
            (h5 = C5[b5]) && (f4 = (v5 < 3 ? h5(f4) : v5 > 3 ? h5(s2, n3, f4) : h5(s2, n3)) || f4);
        return v5 > 3 && f4 && Object.defineProperty(s2, n3, f4), f4;
      };
      Object.defineProperty(e, "__esModule", { value: true }), e.TextureAtlas = void 0;
      let a2 = d5(237), o3 = d5(860), _5 = d5(374), p6 = d5(160), c3 = d5(345), i4 = d5(485), t = d5(385), g4 = d5(147), L5 = d5(855), x5 = d5(776), S6 = { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, size: { x: 0, y: 0 }, sizeClipSpace: { x: 0, y: 0 } }, R4;
      class A5 {
        get pages() {
          return this._pages;
        }
        constructor(s2, n3, m6) {
          this._document = s2, this._config = n3, this._unicodeService = m6, this._didWarmUp = false, this._cacheMap = new i4.FourKeyMap(), this._cacheMapCombined = new i4.FourKeyMap(), this._pages = [], this._activePages = [], this._workBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 }, this._workAttributeData = new g4.AttributeData(), this._textureSize = 512, this._onAddTextureAtlasCanvas = new c3.EventEmitter(), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = new c3.EventEmitter(), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._requestClearModel = false, this._createNewPage(), this._tmpCanvas = u3(s2, 4 * this._config.deviceCellWidth + 4, this._config.deviceCellHeight + 4), this._tmpCtx = (0, _5.throwIfFalsy)(this._tmpCanvas.getContext("2d", { alpha: this._config.allowTransparency, willReadFrequently: true }));
        }
        dispose() {
          for (let s2 of this.pages)
            s2.canvas.remove();
          this._onAddTextureAtlasCanvas.dispose();
        }
        warmUp() {
          this._didWarmUp || (this._doWarmUp(), this._didWarmUp = true);
        }
        _doWarmUp() {
          let s2 = new t.IdleTaskQueue();
          for (let n3 = 33; n3 < 126; n3++)
            s2.enqueue(() => {
              if (!this._cacheMap.get(n3, L5.DEFAULT_COLOR, L5.DEFAULT_COLOR, L5.DEFAULT_EXT)) {
                let m6 = this._drawToCache(n3, L5.DEFAULT_COLOR, L5.DEFAULT_COLOR, L5.DEFAULT_EXT);
                this._cacheMap.set(n3, L5.DEFAULT_COLOR, L5.DEFAULT_COLOR, L5.DEFAULT_EXT, m6);
              }
            });
        }
        beginFrame() {
          return this._requestClearModel;
        }
        clearTexture() {
          if (this._pages[0].currentRow.x !== 0 || this._pages[0].currentRow.y !== 0) {
            for (let s2 of this._pages)
              s2.clear();
            this._cacheMap.clear(), this._cacheMapCombined.clear(), this._didWarmUp = false;
          }
        }
        _createNewPage() {
          if (A5.maxAtlasPages && this._pages.length >= Math.max(4, A5.maxAtlasPages)) {
            let n3 = this._pages.filter((w4) => 2 * w4.canvas.width <= (A5.maxTextureSize || 4096)).sort((w4, M5) => M5.canvas.width !== w4.canvas.width ? M5.canvas.width - w4.canvas.width : M5.percentageUsed - w4.percentageUsed), m6 = -1, h5 = 0;
            for (let w4 = 0; w4 < n3.length; w4++)
              if (n3[w4].canvas.width !== h5)
                m6 = w4, h5 = n3[w4].canvas.width;
              else if (w4 - m6 == 3)
                break;
            let v5 = n3.slice(m6, m6 + 4), f4 = v5.map((w4) => w4.glyphs[0].texturePage).sort((w4, M5) => w4 > M5 ? 1 : -1), b5 = this.pages.length - v5.length, y5 = this._mergePages(v5, b5);
            y5.version++;
            for (let w4 = f4.length - 1; w4 >= 0; w4--)
              this._deletePage(f4[w4]);
            this.pages.push(y5), this._requestClearModel = true, this._onAddTextureAtlasCanvas.fire(y5.canvas);
          }
          let s2 = new E5(this._document, this._textureSize);
          return this._pages.push(s2), this._activePages.push(s2), this._onAddTextureAtlasCanvas.fire(s2.canvas), s2;
        }
        _mergePages(s2, n3) {
          let m6 = 2 * s2[0].canvas.width, h5 = new E5(this._document, m6, s2);
          for (let [v5, f4] of s2.entries()) {
            let b5 = v5 * f4.canvas.width % m6, y5 = Math.floor(v5 / 2) * f4.canvas.height;
            h5.ctx.drawImage(f4.canvas, b5, y5);
            for (let M5 of f4.glyphs)
              M5.texturePage = n3, M5.sizeClipSpace.x = M5.size.x / m6, M5.sizeClipSpace.y = M5.size.y / m6, M5.texturePosition.x += b5, M5.texturePosition.y += y5, M5.texturePositionClipSpace.x = M5.texturePosition.x / m6, M5.texturePositionClipSpace.y = M5.texturePosition.y / m6;
            this._onRemoveTextureAtlasCanvas.fire(f4.canvas);
            let w4 = this._activePages.indexOf(f4);
            w4 !== -1 && this._activePages.splice(w4, 1);
          }
          return h5;
        }
        _deletePage(s2) {
          this._pages.splice(s2, 1);
          for (let n3 = s2; n3 < this._pages.length; n3++) {
            let m6 = this._pages[n3];
            for (let h5 of m6.glyphs)
              h5.texturePage--;
            m6.version++;
          }
        }
        getRasterizedGlyphCombinedChar(s2, n3, m6, h5, v5) {
          return this._getFromCacheMap(this._cacheMapCombined, s2, n3, m6, h5, v5);
        }
        getRasterizedGlyph(s2, n3, m6, h5, v5) {
          return this._getFromCacheMap(this._cacheMap, s2, n3, m6, h5, v5);
        }
        _getFromCacheMap(s2, n3, m6, h5, v5, f4 = false) {
          return R4 = s2.get(n3, m6, h5, v5), R4 || (R4 = this._drawToCache(n3, m6, h5, v5, f4), s2.set(n3, m6, h5, v5, R4)), R4;
        }
        _getColorFromAnsiIndex(s2) {
          if (s2 >= this._config.colors.ansi.length)
            throw new Error("No color found for idx " + s2);
          return this._config.colors.ansi[s2];
        }
        _getBackgroundColor(s2, n3, m6, h5) {
          if (this._config.allowTransparency)
            return p6.NULL_COLOR;
          let v5;
          switch (s2) {
            case 16777216:
            case 33554432:
              v5 = this._getColorFromAnsiIndex(n3);
              break;
            case 50331648:
              let f4 = g4.AttributeData.toColorRGB(n3);
              v5 = p6.rgba.toColor(f4[0], f4[1], f4[2]);
              break;
            default:
              v5 = m6 ? p6.color.opaque(this._config.colors.foreground) : this._config.colors.background;
          }
          return v5;
        }
        _getForegroundColor(s2, n3, m6, h5, v5, f4, b5, y5, w4, M5) {
          let D5 = this._getMinimumContrastColor(s2, n3, m6, h5, v5, f4, false, w4, y5, M5);
          if (D5)
            return D5;
          let T6;
          switch (v5) {
            case 16777216:
            case 33554432:
              this._config.drawBoldTextInBrightColors && w4 && f4 < 8 && (f4 += 8), T6 = this._getColorFromAnsiIndex(f4);
              break;
            case 50331648:
              let H4 = g4.AttributeData.toColorRGB(f4);
              T6 = p6.rgba.toColor(H4[0], H4[1], H4[2]);
              break;
            default:
              T6 = b5 ? this._config.colors.background : this._config.colors.foreground;
          }
          return this._config.allowTransparency && (T6 = p6.color.opaque(T6)), y5 && (T6 = p6.color.multiplyOpacity(T6, a2.DIM_OPACITY)), T6;
        }
        _resolveBackgroundRgba(s2, n3, m6) {
          switch (s2) {
            case 16777216:
            case 33554432:
              return this._getColorFromAnsiIndex(n3).rgba;
            case 50331648:
              return n3 << 8;
            default:
              return m6 ? this._config.colors.foreground.rgba : this._config.colors.background.rgba;
          }
        }
        _resolveForegroundRgba(s2, n3, m6, h5) {
          switch (s2) {
            case 16777216:
            case 33554432:
              return this._config.drawBoldTextInBrightColors && h5 && n3 < 8 && (n3 += 8), this._getColorFromAnsiIndex(n3).rgba;
            case 50331648:
              return n3 << 8;
            default:
              return m6 ? this._config.colors.background.rgba : this._config.colors.foreground.rgba;
          }
        }
        _getMinimumContrastColor(s2, n3, m6, h5, v5, f4, b5, y5, w4, M5) {
          if (this._config.minimumContrastRatio === 1 || M5)
            return;
          let D5 = this._getContrastCache(w4), T6 = D5.getColor(s2, h5);
          if (T6 !== void 0)
            return T6 || void 0;
          let H4 = this._resolveBackgroundRgba(n3, m6, b5), B4 = this._resolveForegroundRgba(v5, f4, b5, y5), G5 = p6.rgba.ensureContrastRatio(H4, B4, this._config.minimumContrastRatio / (w4 ? 2 : 1));
          if (!G5)
            return void D5.setColor(s2, h5, null);
          let j7 = p6.rgba.toColor(G5 >> 24 & 255, G5 >> 16 & 255, G5 >> 8 & 255);
          return D5.setColor(s2, h5, j7), j7;
        }
        _getContrastCache(s2) {
          return s2 ? this._config.colors.halfContrastCache : this._config.colors.contrastCache;
        }
        _drawToCache(s2, n3, m6, h5, v5 = false) {
          let f4 = typeof s2 == "number" ? String.fromCharCode(s2) : s2, b5 = Math.min(this._config.deviceCellWidth * Math.max(f4.length, 2) + 4, this._textureSize);
          this._tmpCanvas.width < b5 && (this._tmpCanvas.width = b5);
          let y5 = Math.min(this._config.deviceCellHeight + 8, this._textureSize);
          if (this._tmpCanvas.height < y5 && (this._tmpCanvas.height = y5), this._tmpCtx.save(), this._workAttributeData.fg = m6, this._workAttributeData.bg = n3, this._workAttributeData.extended.ext = h5, this._workAttributeData.isInvisible())
            return S6;
          let w4 = !!this._workAttributeData.isBold(), M5 = !!this._workAttributeData.isInverse(), D5 = !!this._workAttributeData.isDim(), T6 = !!this._workAttributeData.isItalic(), H4 = !!this._workAttributeData.isUnderline(), B4 = !!this._workAttributeData.isStrikethrough(), G5 = !!this._workAttributeData.isOverline(), j7 = this._workAttributeData.getFgColor(), Y5 = this._workAttributeData.getFgColorMode(), $5 = this._workAttributeData.getBgColor(), X5 = this._workAttributeData.getBgColorMode();
          if (M5) {
            let F7 = j7;
            j7 = $5, $5 = F7;
            let N6 = Y5;
            Y5 = X5, X5 = N6;
          }
          let z4 = this._getBackgroundColor(X5, $5, M5, D5);
          this._tmpCtx.globalCompositeOperation = "copy", this._tmpCtx.fillStyle = z4.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.globalCompositeOperation = "source-over";
          let pe3 = w4 ? this._config.fontWeightBold : this._config.fontWeight, re2 = T6 ? "italic" : "";
          this._tmpCtx.font = `${re2} ${pe3} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = a2.TEXT_BASELINE;
          let ce2 = f4.length === 1 && (0, _5.isPowerlineGlyph)(f4.charCodeAt(0)), de2 = f4.length === 1 && (0, _5.isRestrictedPowerlineGlyph)(f4.charCodeAt(0)), ie3 = this._getForegroundColor(n3, X5, $5, m6, Y5, j7, M5, D5, w4, (0, _5.excludeFromContrastRatioDemands)(f4.charCodeAt(0)));
          this._tmpCtx.fillStyle = ie3.css;
          let W5 = de2 ? 0 : 4, _e2 = false;
          this._config.customGlyphs !== false && (_e2 = (0, o3.tryDrawCustomChar)(this._tmpCtx, f4, W5, W5, this._config.deviceCellWidth, this._config.deviceCellHeight, this._config.fontSize, this._config.devicePixelRatio));
          let ne3, ae2 = !ce2;
          if (ne3 = typeof s2 == "number" ? this._unicodeService.wcwidth(s2) : this._unicodeService.getStringCellWidth(s2), H4) {
            this._tmpCtx.save();
            let F7 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), N6 = F7 % 2 == 1 ? 0.5 : 0;
            if (this._tmpCtx.lineWidth = F7, this._workAttributeData.isUnderlineColorDefault())
              this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle;
            else if (this._workAttributeData.isUnderlineColorRGB())
              ae2 = false, this._tmpCtx.strokeStyle = `rgb(${g4.AttributeData.toColorRGB(this._workAttributeData.getUnderlineColor()).join(",")})`;
            else {
              ae2 = false;
              let Z5 = this._workAttributeData.getUnderlineColor();
              this._config.drawBoldTextInBrightColors && this._workAttributeData.isBold() && Z5 < 8 && (Z5 += 8), this._tmpCtx.strokeStyle = this._getColorFromAnsiIndex(Z5).css;
            }
            this._tmpCtx.beginPath();
            let Q5 = W5, J5 = Math.ceil(W5 + this._config.deviceCharHeight) - N6 - (v5 ? 2 * F7 : 0), he2 = J5 + F7, le2 = J5 + 2 * F7;
            for (let Z5 = 0; Z5 < ne3; Z5++) {
              this._tmpCtx.save();
              let K3 = Q5 + Z5 * this._config.deviceCellWidth, ee3 = Q5 + (Z5 + 1) * this._config.deviceCellWidth, Ce3 = K3 + this._config.deviceCellWidth / 2;
              switch (this._workAttributeData.extended.underlineStyle) {
                case 2:
                  this._tmpCtx.moveTo(K3, J5), this._tmpCtx.lineTo(ee3, J5), this._tmpCtx.moveTo(K3, le2), this._tmpCtx.lineTo(ee3, le2);
                  break;
                case 3:
                  let ge3 = F7 <= 1 ? le2 : Math.ceil(W5 + this._config.deviceCharHeight - F7 / 2) - N6, ve2 = F7 <= 1 ? J5 : Math.ceil(W5 + this._config.deviceCharHeight + F7 / 2) - N6, Re3 = new Path2D();
                  Re3.rect(K3, J5, this._config.deviceCellWidth, le2 - J5), this._tmpCtx.clip(Re3), this._tmpCtx.moveTo(K3 - this._config.deviceCellWidth / 2, he2), this._tmpCtx.bezierCurveTo(K3 - this._config.deviceCellWidth / 2, ve2, K3, ve2, K3, he2), this._tmpCtx.bezierCurveTo(K3, ge3, Ce3, ge3, Ce3, he2), this._tmpCtx.bezierCurveTo(Ce3, ve2, ee3, ve2, ee3, he2), this._tmpCtx.bezierCurveTo(ee3, ge3, ee3 + this._config.deviceCellWidth / 2, ge3, ee3 + this._config.deviceCellWidth / 2, he2);
                  break;
                case 4:
                  this._tmpCtx.setLineDash([Math.round(F7), Math.round(F7)]), this._tmpCtx.moveTo(K3, J5), this._tmpCtx.lineTo(ee3, J5);
                  break;
                case 5:
                  this._tmpCtx.setLineDash([4 * this._config.devicePixelRatio, 3 * this._config.devicePixelRatio]), this._tmpCtx.moveTo(K3, J5), this._tmpCtx.lineTo(ee3, J5);
                  break;
                default:
                  this._tmpCtx.moveTo(K3, J5), this._tmpCtx.lineTo(ee3, J5);
              }
              this._tmpCtx.stroke(), this._tmpCtx.restore();
            }
            if (this._tmpCtx.restore(), !_e2 && this._config.fontSize >= 12 && !this._config.allowTransparency && f4 !== " ") {
              this._tmpCtx.save(), this._tmpCtx.textBaseline = "alphabetic";
              let Z5 = this._tmpCtx.measureText(f4);
              if (this._tmpCtx.restore(), "actualBoundingBoxDescent" in Z5 && Z5.actualBoundingBoxDescent > 0) {
                this._tmpCtx.save();
                let K3 = new Path2D();
                K3.rect(Q5, J5 - Math.ceil(F7 / 2), this._config.deviceCellWidth * ne3, le2 - J5 + Math.ceil(F7 / 2)), this._tmpCtx.clip(K3), this._tmpCtx.lineWidth = 3 * this._config.devicePixelRatio, this._tmpCtx.strokeStyle = z4.css, this._tmpCtx.strokeText(f4, W5, W5 + this._config.deviceCharHeight), this._tmpCtx.restore();
              }
            }
          }
          if (G5) {
            let F7 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 15)), N6 = F7 % 2 == 1 ? 0.5 : 0;
            this._tmpCtx.lineWidth = F7, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(W5, W5 + N6), this._tmpCtx.lineTo(W5 + this._config.deviceCharWidth * ne3, W5 + N6), this._tmpCtx.stroke();
          }
          if (_e2 || this._tmpCtx.fillText(f4, W5, W5 + this._config.deviceCharHeight), f4 === "_" && !this._config.allowTransparency) {
            let F7 = r(this._tmpCtx.getImageData(W5, W5, this._config.deviceCellWidth, this._config.deviceCellHeight), z4, ie3, ae2);
            if (F7)
              for (let N6 = 1; N6 <= 5 && (this._tmpCtx.save(), this._tmpCtx.fillStyle = z4.css, this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), this._tmpCtx.restore(), this._tmpCtx.fillText(f4, W5, W5 + this._config.deviceCharHeight - N6), F7 = r(this._tmpCtx.getImageData(W5, W5, this._config.deviceCellWidth, this._config.deviceCellHeight), z4, ie3, ae2), F7); N6++)
                ;
          }
          if (B4) {
            let F7 = Math.max(1, Math.floor(this._config.fontSize * this._config.devicePixelRatio / 10)), N6 = this._tmpCtx.lineWidth % 2 == 1 ? 0.5 : 0;
            this._tmpCtx.lineWidth = F7, this._tmpCtx.strokeStyle = this._tmpCtx.fillStyle, this._tmpCtx.beginPath(), this._tmpCtx.moveTo(W5, W5 + Math.floor(this._config.deviceCharHeight / 2) - N6), this._tmpCtx.lineTo(W5 + this._config.deviceCharWidth * ne3, W5 + Math.floor(this._config.deviceCharHeight / 2) - N6), this._tmpCtx.stroke();
          }
          this._tmpCtx.restore();
          let ue2 = this._tmpCtx.getImageData(0, 0, this._tmpCanvas.width, this._tmpCanvas.height), be2;
          if (be2 = this._config.allowTransparency ? function(F7) {
            for (let N6 = 0; N6 < F7.data.length; N6 += 4)
              if (F7.data[N6 + 3] > 0)
                return false;
            return true;
          }(ue2) : r(ue2, z4, ie3, ae2), be2)
            return S6;
          let k4 = this._findGlyphBoundingBox(ue2, this._workBoundingBox, b5, de2, _e2, W5), I7, O6;
          for (; ; ) {
            if (this._activePages.length === 0) {
              let F7 = this._createNewPage();
              I7 = F7, O6 = F7.currentRow, O6.height = k4.size.y;
              break;
            }
            I7 = this._activePages[this._activePages.length - 1], O6 = I7.currentRow;
            for (let F7 of this._activePages)
              k4.size.y <= F7.currentRow.height && (I7 = F7, O6 = F7.currentRow);
            for (let F7 = this._activePages.length - 1; F7 >= 0; F7--)
              for (let N6 of this._activePages[F7].fixedRows)
                N6.height <= O6.height && k4.size.y <= N6.height && (I7 = this._activePages[F7], O6 = N6);
            if (O6.y + k4.size.y >= I7.canvas.height || O6.height > k4.size.y + 2) {
              let F7 = false;
              if (I7.currentRow.y + I7.currentRow.height + k4.size.y >= I7.canvas.height) {
                let N6;
                for (let Q5 of this._activePages)
                  if (Q5.currentRow.y + Q5.currentRow.height + k4.size.y < Q5.canvas.height) {
                    N6 = Q5;
                    break;
                  }
                if (N6)
                  I7 = N6;
                else if (A5.maxAtlasPages && this._pages.length >= A5.maxAtlasPages && O6.y + k4.size.y <= I7.canvas.height && O6.height >= k4.size.y && O6.x + k4.size.x <= I7.canvas.width)
                  F7 = true;
                else {
                  let Q5 = this._createNewPage();
                  I7 = Q5, O6 = Q5.currentRow, O6.height = k4.size.y, F7 = true;
                }
              }
              F7 || (I7.currentRow.height > 0 && I7.fixedRows.push(I7.currentRow), O6 = { x: 0, y: I7.currentRow.y + I7.currentRow.height, height: k4.size.y }, I7.fixedRows.push(O6), I7.currentRow = { x: 0, y: O6.y + O6.height, height: 0 });
            }
            if (O6.x + k4.size.x <= I7.canvas.width)
              break;
            O6 === I7.currentRow ? (O6.x = 0, O6.y += O6.height, O6.height = 0) : I7.fixedRows.splice(I7.fixedRows.indexOf(O6), 1);
          }
          return k4.texturePage = this._pages.indexOf(I7), k4.texturePosition.x = O6.x, k4.texturePosition.y = O6.y, k4.texturePositionClipSpace.x = O6.x / I7.canvas.width, k4.texturePositionClipSpace.y = O6.y / I7.canvas.height, k4.sizeClipSpace.x /= I7.canvas.width, k4.sizeClipSpace.y /= I7.canvas.height, O6.height = Math.max(O6.height, k4.size.y), O6.x += k4.size.x, I7.ctx.putImageData(ue2, k4.texturePosition.x - this._workBoundingBox.left, k4.texturePosition.y - this._workBoundingBox.top, this._workBoundingBox.left, this._workBoundingBox.top, k4.size.x, k4.size.y), I7.addGlyph(k4), I7.version++, k4;
        }
        _findGlyphBoundingBox(s2, n3, m6, h5, v5, f4) {
          n3.top = 0;
          let b5 = h5 ? this._config.deviceCellHeight : this._tmpCanvas.height, y5 = h5 ? this._config.deviceCellWidth : m6, w4 = false;
          for (let M5 = 0; M5 < b5; M5++) {
            for (let D5 = 0; D5 < y5; D5++) {
              let T6 = M5 * this._tmpCanvas.width * 4 + 4 * D5 + 3;
              if (s2.data[T6] !== 0) {
                n3.top = M5, w4 = true;
                break;
              }
            }
            if (w4)
              break;
          }
          n3.left = 0, w4 = false;
          for (let M5 = 0; M5 < f4 + y5; M5++) {
            for (let D5 = 0; D5 < b5; D5++) {
              let T6 = D5 * this._tmpCanvas.width * 4 + 4 * M5 + 3;
              if (s2.data[T6] !== 0) {
                n3.left = M5, w4 = true;
                break;
              }
            }
            if (w4)
              break;
          }
          n3.right = y5, w4 = false;
          for (let M5 = f4 + y5 - 1; M5 >= f4; M5--) {
            for (let D5 = 0; D5 < b5; D5++) {
              let T6 = D5 * this._tmpCanvas.width * 4 + 4 * M5 + 3;
              if (s2.data[T6] !== 0) {
                n3.right = M5, w4 = true;
                break;
              }
            }
            if (w4)
              break;
          }
          n3.bottom = b5, w4 = false;
          for (let M5 = b5 - 1; M5 >= 0; M5--) {
            for (let D5 = 0; D5 < y5; D5++) {
              let T6 = M5 * this._tmpCanvas.width * 4 + 4 * D5 + 3;
              if (s2.data[T6] !== 0) {
                n3.bottom = M5, w4 = true;
                break;
              }
            }
            if (w4)
              break;
          }
          return { texturePage: 0, texturePosition: { x: 0, y: 0 }, texturePositionClipSpace: { x: 0, y: 0 }, size: { x: n3.right - n3.left + 1, y: n3.bottom - n3.top + 1 }, sizeClipSpace: { x: n3.right - n3.left + 1, y: n3.bottom - n3.top + 1 }, offset: { x: -n3.left + f4 + (h5 || v5 ? Math.floor((this._config.deviceCellWidth - this._config.deviceCharWidth) / 2) : 0), y: -n3.top + f4 + (h5 || v5 ? this._config.lineHeight === 1 ? 0 : Math.round((this._config.deviceCellHeight - this._config.deviceCharHeight) / 2) : 0) } };
        }
      }
      e.TextureAtlas = A5, l4([x5.traceCall], A5.prototype, "_drawToCache", null);
      class E5 {
        get percentageUsed() {
          return this._usedPixels / (this.canvas.width * this.canvas.height);
        }
        get glyphs() {
          return this._glyphs;
        }
        addGlyph(s2) {
          this._glyphs.push(s2), this._usedPixels += s2.size.x * s2.size.y;
        }
        constructor(s2, n3, m6) {
          if (this._usedPixels = 0, this._glyphs = [], this.version = 0, this.currentRow = { x: 0, y: 0, height: 0 }, this.fixedRows = [], m6)
            for (let h5 of m6)
              this._glyphs.push(...h5.glyphs), this._usedPixels += h5._usedPixels;
          this.canvas = u3(s2, n3, n3), this.ctx = (0, _5.throwIfFalsy)(this.canvas.getContext("2d", { alpha: true }));
        }
        clear() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.currentRow.x = 0, this.currentRow.y = 0, this.currentRow.height = 0, this.fixedRows.length = 0, this.version++;
        }
      }
      function r(C5, s2, n3, m6) {
        let h5 = s2.rgba >>> 24, v5 = s2.rgba >>> 16 & 255, f4 = s2.rgba >>> 8 & 255, b5 = n3.rgba >>> 24, y5 = n3.rgba >>> 16 & 255, w4 = n3.rgba >>> 8 & 255, M5 = Math.floor((Math.abs(h5 - b5) + Math.abs(v5 - y5) + Math.abs(f4 - w4)) / 12), D5 = true;
        for (let T6 = 0; T6 < C5.data.length; T6 += 4)
          C5.data[T6] === h5 && C5.data[T6 + 1] === v5 && C5.data[T6 + 2] === f4 || m6 && Math.abs(C5.data[T6] - h5) + Math.abs(C5.data[T6 + 1] - v5) + Math.abs(C5.data[T6 + 2] - f4) < M5 ? C5.data[T6 + 3] = 0 : D5 = false;
        return D5;
      }
      function u3(C5, s2, n3) {
        let m6 = C5.createElement("canvas");
        return m6.width = s2, m6.height = n3, m6;
      }
    }, 160: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.contrastRatio = e.toPaddedHex = e.rgba = e.rgb = e.css = e.color = e.channels = e.NULL_COLOR = void 0;
      let l4 = d5(399), a2 = 0, o3 = 0, _5 = 0, p6 = 0;
      var c3, i4, t, g4, L5;
      function x5(R4) {
        let A5 = R4.toString(16);
        return A5.length < 2 ? "0" + A5 : A5;
      }
      function S6(R4, A5) {
        return R4 < A5 ? (A5 + 0.05) / (R4 + 0.05) : (R4 + 0.05) / (A5 + 0.05);
      }
      e.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(R4) {
        R4.toCss = function(A5, E5, r, u3) {
          return u3 !== void 0 ? `#${x5(A5)}${x5(E5)}${x5(r)}${x5(u3)}` : `#${x5(A5)}${x5(E5)}${x5(r)}`;
        }, R4.toRgba = function(A5, E5, r, u3 = 255) {
          return (A5 << 24 | E5 << 16 | r << 8 | u3) >>> 0;
        };
      }(c3 || (e.channels = c3 = {})), function(R4) {
        function A5(E5, r) {
          return p6 = Math.round(255 * r), [a2, o3, _5] = L5.toChannels(E5.rgba), { css: c3.toCss(a2, o3, _5, p6), rgba: c3.toRgba(a2, o3, _5, p6) };
        }
        R4.blend = function(E5, r) {
          if (p6 = (255 & r.rgba) / 255, p6 === 1)
            return { css: r.css, rgba: r.rgba };
          let u3 = r.rgba >> 24 & 255, C5 = r.rgba >> 16 & 255, s2 = r.rgba >> 8 & 255, n3 = E5.rgba >> 24 & 255, m6 = E5.rgba >> 16 & 255, h5 = E5.rgba >> 8 & 255;
          return a2 = n3 + Math.round((u3 - n3) * p6), o3 = m6 + Math.round((C5 - m6) * p6), _5 = h5 + Math.round((s2 - h5) * p6), { css: c3.toCss(a2, o3, _5), rgba: c3.toRgba(a2, o3, _5) };
        }, R4.isOpaque = function(E5) {
          return (255 & E5.rgba) == 255;
        }, R4.ensureContrastRatio = function(E5, r, u3) {
          let C5 = L5.ensureContrastRatio(E5.rgba, r.rgba, u3);
          if (C5)
            return L5.toColor(C5 >> 24 & 255, C5 >> 16 & 255, C5 >> 8 & 255);
        }, R4.opaque = function(E5) {
          let r = (255 | E5.rgba) >>> 0;
          return [a2, o3, _5] = L5.toChannels(r), { css: c3.toCss(a2, o3, _5), rgba: r };
        }, R4.opacity = A5, R4.multiplyOpacity = function(E5, r) {
          return p6 = 255 & E5.rgba, A5(E5, p6 * r / 255);
        }, R4.toColorRGB = function(E5) {
          return [E5.rgba >> 24 & 255, E5.rgba >> 16 & 255, E5.rgba >> 8 & 255];
        };
      }(i4 || (e.color = i4 = {})), function(R4) {
        let A5, E5;
        if (!l4.isNode) {
          let r = document.createElement("canvas");
          r.width = 1, r.height = 1;
          let u3 = r.getContext("2d", { willReadFrequently: true });
          u3 && (A5 = u3, A5.globalCompositeOperation = "copy", E5 = A5.createLinearGradient(0, 0, 1, 1));
        }
        R4.toColor = function(r) {
          if (r.match(/#[\da-f]{3,8}/i))
            switch (r.length) {
              case 4:
                return a2 = parseInt(r.slice(1, 2).repeat(2), 16), o3 = parseInt(r.slice(2, 3).repeat(2), 16), _5 = parseInt(r.slice(3, 4).repeat(2), 16), L5.toColor(a2, o3, _5);
              case 5:
                return a2 = parseInt(r.slice(1, 2).repeat(2), 16), o3 = parseInt(r.slice(2, 3).repeat(2), 16), _5 = parseInt(r.slice(3, 4).repeat(2), 16), p6 = parseInt(r.slice(4, 5).repeat(2), 16), L5.toColor(a2, o3, _5, p6);
              case 7:
                return { css: r, rgba: (parseInt(r.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: r, rgba: parseInt(r.slice(1), 16) >>> 0 };
            }
          let u3 = r.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (u3)
            return a2 = parseInt(u3[1]), o3 = parseInt(u3[2]), _5 = parseInt(u3[3]), p6 = Math.round(255 * (u3[5] === void 0 ? 1 : parseFloat(u3[5]))), L5.toColor(a2, o3, _5, p6);
          if (!A5 || !E5)
            throw new Error("css.toColor: Unsupported css format");
          if (A5.fillStyle = E5, A5.fillStyle = r, typeof A5.fillStyle != "string")
            throw new Error("css.toColor: Unsupported css format");
          if (A5.fillRect(0, 0, 1, 1), [a2, o3, _5, p6] = A5.getImageData(0, 0, 1, 1).data, p6 !== 255)
            throw new Error("css.toColor: Unsupported css format");
          return { rgba: c3.toRgba(a2, o3, _5, p6), css: r };
        };
      }(t || (e.css = t = {})), function(R4) {
        function A5(E5, r, u3) {
          let C5 = E5 / 255, s2 = r / 255, n3 = u3 / 255;
          return 0.2126 * (C5 <= 0.03928 ? C5 / 12.92 : Math.pow((C5 + 0.055) / 1.055, 2.4)) + 0.7152 * (s2 <= 0.03928 ? s2 / 12.92 : Math.pow((s2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n3 <= 0.03928 ? n3 / 12.92 : Math.pow((n3 + 0.055) / 1.055, 2.4));
        }
        R4.relativeLuminance = function(E5) {
          return A5(E5 >> 16 & 255, E5 >> 8 & 255, 255 & E5);
        }, R4.relativeLuminance2 = A5;
      }(g4 || (e.rgb = g4 = {})), function(R4) {
        function A5(r, u3, C5) {
          let s2 = r >> 24 & 255, n3 = r >> 16 & 255, m6 = r >> 8 & 255, h5 = u3 >> 24 & 255, v5 = u3 >> 16 & 255, f4 = u3 >> 8 & 255, b5 = S6(g4.relativeLuminance2(h5, v5, f4), g4.relativeLuminance2(s2, n3, m6));
          for (; b5 < C5 && (h5 > 0 || v5 > 0 || f4 > 0); )
            h5 -= Math.max(0, Math.ceil(0.1 * h5)), v5 -= Math.max(0, Math.ceil(0.1 * v5)), f4 -= Math.max(0, Math.ceil(0.1 * f4)), b5 = S6(g4.relativeLuminance2(h5, v5, f4), g4.relativeLuminance2(s2, n3, m6));
          return (h5 << 24 | v5 << 16 | f4 << 8 | 255) >>> 0;
        }
        function E5(r, u3, C5) {
          let s2 = r >> 24 & 255, n3 = r >> 16 & 255, m6 = r >> 8 & 255, h5 = u3 >> 24 & 255, v5 = u3 >> 16 & 255, f4 = u3 >> 8 & 255, b5 = S6(g4.relativeLuminance2(h5, v5, f4), g4.relativeLuminance2(s2, n3, m6));
          for (; b5 < C5 && (h5 < 255 || v5 < 255 || f4 < 255); )
            h5 = Math.min(255, h5 + Math.ceil(0.1 * (255 - h5))), v5 = Math.min(255, v5 + Math.ceil(0.1 * (255 - v5))), f4 = Math.min(255, f4 + Math.ceil(0.1 * (255 - f4))), b5 = S6(g4.relativeLuminance2(h5, v5, f4), g4.relativeLuminance2(s2, n3, m6));
          return (h5 << 24 | v5 << 16 | f4 << 8 | 255) >>> 0;
        }
        R4.ensureContrastRatio = function(r, u3, C5) {
          let s2 = g4.relativeLuminance(r >> 8), n3 = g4.relativeLuminance(u3 >> 8);
          if (S6(s2, n3) < C5) {
            if (n3 < s2) {
              let v5 = A5(r, u3, C5), f4 = S6(s2, g4.relativeLuminance(v5 >> 8));
              if (f4 < C5) {
                let b5 = E5(r, u3, C5);
                return f4 > S6(s2, g4.relativeLuminance(b5 >> 8)) ? v5 : b5;
              }
              return v5;
            }
            let m6 = E5(r, u3, C5), h5 = S6(s2, g4.relativeLuminance(m6 >> 8));
            if (h5 < C5) {
              let v5 = A5(r, u3, C5);
              return h5 > S6(s2, g4.relativeLuminance(v5 >> 8)) ? m6 : v5;
            }
            return m6;
          }
        }, R4.reduceLuminance = A5, R4.increaseLuminance = E5, R4.toChannels = function(r) {
          return [r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r];
        }, R4.toColor = function(r, u3, C5, s2) {
          return { css: c3.toCss(r, u3, C5, s2), rgba: c3.toRgba(r, u3, C5, s2) };
        };
      }(L5 || (e.rgba = L5 = {})), e.toPaddedHex = x5, e.contrastRatio = S6;
    }, 345: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.forwardEvent = e.EventEmitter = void 0, e.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = false;
        }
        get event() {
          return this._event || (this._event = (d5) => (this._listeners.push(d5), { dispose: () => {
            if (!this._disposed) {
              for (let l4 = 0; l4 < this._listeners.length; l4++)
                if (this._listeners[l4] === d5)
                  return void this._listeners.splice(l4, 1);
            }
          } })), this._event;
        }
        fire(d5, l4) {
          let a2 = [];
          for (let o3 = 0; o3 < this._listeners.length; o3++)
            a2.push(this._listeners[o3]);
          for (let o3 = 0; o3 < a2.length; o3++)
            a2[o3].call(void 0, d5, l4);
        }
        dispose() {
          this.clearListeners(), this._disposed = true;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, e.forwardEvent = function(d5, l4) {
        return d5((a2) => l4.fire(a2));
      };
    }, 859: (P7, e) => {
      function d5(l4) {
        for (let a2 of l4)
          a2.dispose();
        l4.length = 0;
      }
      Object.defineProperty(e, "__esModule", { value: true }), e.getDisposeArrayDisposable = e.disposeArray = e.toDisposable = e.MutableDisposable = e.Disposable = void 0, e.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true;
          for (let l4 of this._disposables)
            l4.dispose();
          this._disposables.length = 0;
        }
        register(l4) {
          return this._disposables.push(l4), l4;
        }
        unregister(l4) {
          let a2 = this._disposables.indexOf(l4);
          a2 !== -1 && this._disposables.splice(a2, 1);
        }
      }, e.MutableDisposable = class {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(l4) {
          var a2;
          this._isDisposed || l4 === this._value || ((a2 = this._value) === null || a2 === void 0 || a2.dispose(), this._value = l4);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          var l4;
          this._isDisposed = true, (l4 = this._value) === null || l4 === void 0 || l4.dispose(), this._value = void 0;
        }
      }, e.toDisposable = function(l4) {
        return { dispose: l4 };
      }, e.disposeArray = d5, e.getDisposeArrayDisposable = function(l4) {
        return { dispose: () => d5(l4) };
      };
    }, 485: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.FourKeyMap = e.TwoKeyMap = void 0;
      class d5 {
        constructor() {
          this._data = {};
        }
        set(a2, o3, _5) {
          this._data[a2] || (this._data[a2] = {}), this._data[a2][o3] = _5;
        }
        get(a2, o3) {
          return this._data[a2] ? this._data[a2][o3] : void 0;
        }
        clear() {
          this._data = {};
        }
      }
      e.TwoKeyMap = d5, e.FourKeyMap = class {
        constructor() {
          this._data = new d5();
        }
        set(l4, a2, o3, _5, p6) {
          this._data.get(l4, a2) || this._data.set(l4, a2, new d5()), this._data.get(l4, a2).set(o3, _5, p6);
        }
        get(l4, a2, o3, _5) {
          var p6;
          return (p6 = this._data.get(l4, a2)) === null || p6 === void 0 ? void 0 : p6.get(o3, _5);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 399: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.isChromeOS = e.isLinux = e.isWindows = e.isIphone = e.isIpad = e.isMac = e.getSafariVersion = e.isSafari = e.isLegacyEdge = e.isFirefox = e.isNode = void 0, e.isNode = typeof navigator > "u";
      let d5 = e.isNode ? "node" : navigator.userAgent, l4 = e.isNode ? "node" : navigator.platform;
      e.isFirefox = d5.includes("Firefox"), e.isLegacyEdge = d5.includes("Edge"), e.isSafari = /^((?!chrome|android).)*safari/i.test(d5), e.getSafariVersion = function() {
        if (!e.isSafari)
          return 0;
        let a2 = d5.match(/Version\/(\d+)/);
        return a2 === null || a2.length < 2 ? 0 : parseInt(a2[1]);
      }, e.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(l4), e.isIpad = l4 === "iPad", e.isIphone = l4 === "iPhone", e.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(l4), e.isLinux = l4.indexOf("Linux") >= 0, e.isChromeOS = /\bCrOS\b/.test(d5);
    }, 385: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.DebouncedIdleTask = e.IdleTaskQueue = e.PriorityTaskQueue = void 0;
      let l4 = d5(399);
      class a2 {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(p6) {
          this._tasks.push(p6), this._start();
        }
        flush() {
          for (; this._i < this._tasks.length; )
            this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(p6) {
          this._idleCallback = void 0;
          let c3 = 0, i4 = 0, t = p6.timeRemaining(), g4 = 0;
          for (; this._i < this._tasks.length; ) {
            if (c3 = Date.now(), this._tasks[this._i]() || this._i++, c3 = Math.max(1, Date.now() - c3), i4 = Math.max(c3, i4), g4 = p6.timeRemaining(), 1.5 * i4 > g4)
              return t - c3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(t - c3))}ms`), void this._start();
            t = g4;
          }
          this.clear();
        }
      }
      class o3 extends a2 {
        _requestCallback(p6) {
          return setTimeout(() => p6(this._createDeadline(16)));
        }
        _cancelCallback(p6) {
          clearTimeout(p6);
        }
        _createDeadline(p6) {
          let c3 = Date.now() + p6;
          return { timeRemaining: () => Math.max(0, c3 - Date.now()) };
        }
      }
      e.PriorityTaskQueue = o3, e.IdleTaskQueue = !l4.isNode && "requestIdleCallback" in window ? class extends a2 {
        _requestCallback(_5) {
          return requestIdleCallback(_5);
        }
        _cancelCallback(_5) {
          cancelIdleCallback(_5);
        }
      } : o3, e.DebouncedIdleTask = class {
        constructor() {
          this._queue = new e.IdleTaskQueue();
        }
        set(_5) {
          this._queue.clear(), this._queue.enqueue(_5);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 147: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.ExtendedAttrs = e.AttributeData = void 0;
      class d5 {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new l4();
        }
        static toColorRGB(o3) {
          return [o3 >>> 16 & 255, o3 >>> 8 & 255, 255 & o3];
        }
        static fromColorRGB(o3) {
          return (255 & o3[0]) << 16 | (255 & o3[1]) << 8 | 255 & o3[2];
        }
        clone() {
          let o3 = new d5();
          return o3.fg = this.fg, o3.bg = this.bg, o3.extended = this.extended.clone(), o3;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor)
            switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
      }
      e.AttributeData = d5;
      class l4 {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(o3) {
          this._ext = o3;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(o3) {
          this._ext &= -469762049, this._ext |= o3 << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(o3) {
          this._ext &= -67108864, this._ext |= 67108863 & o3;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(o3) {
          this._urlId = o3;
        }
        constructor(o3 = 0, _5 = 0) {
          this._ext = 0, this._urlId = 0, this._ext = o3, this._urlId = _5;
        }
        clone() {
          return new l4(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      e.ExtendedAttrs = l4;
    }, 782: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.CellData = void 0;
      let l4 = d5(133), a2 = d5(855), o3 = d5(147);
      class _5 extends o3.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new o3.ExtendedAttrs(), this.combinedData = "";
        }
        static fromCharData(c3) {
          let i4 = new _5();
          return i4.setFromCharData(c3), i4;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, l4.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(c3) {
          this.fg = c3[a2.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let i4 = false;
          if (c3[a2.CHAR_DATA_CHAR_INDEX].length > 2)
            i4 = true;
          else if (c3[a2.CHAR_DATA_CHAR_INDEX].length === 2) {
            let t = c3[a2.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= t && t <= 56319) {
              let g4 = c3[a2.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= g4 && g4 <= 57343 ? this.content = 1024 * (t - 55296) + g4 - 56320 + 65536 | c3[a2.CHAR_DATA_WIDTH_INDEX] << 22 : i4 = true;
            } else
              i4 = true;
          } else
            this.content = c3[a2.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | c3[a2.CHAR_DATA_WIDTH_INDEX] << 22;
          i4 && (this.combinedData = c3[a2.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | c3[a2.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      e.CellData = _5;
    }, 855: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.WHITESPACE_CELL_CODE = e.WHITESPACE_CELL_WIDTH = e.WHITESPACE_CELL_CHAR = e.NULL_CELL_CODE = e.NULL_CELL_WIDTH = e.NULL_CELL_CHAR = e.CHAR_DATA_CODE_INDEX = e.CHAR_DATA_WIDTH_INDEX = e.CHAR_DATA_CHAR_INDEX = e.CHAR_DATA_ATTR_INDEX = e.DEFAULT_EXT = e.DEFAULT_ATTR = e.DEFAULT_COLOR = void 0, e.DEFAULT_COLOR = 0, e.DEFAULT_ATTR = 256 | e.DEFAULT_COLOR << 9, e.DEFAULT_EXT = 0, e.CHAR_DATA_ATTR_INDEX = 0, e.CHAR_DATA_CHAR_INDEX = 1, e.CHAR_DATA_WIDTH_INDEX = 2, e.CHAR_DATA_CODE_INDEX = 3, e.NULL_CELL_CHAR = "", e.NULL_CELL_WIDTH = 1, e.NULL_CELL_CODE = 0, e.WHITESPACE_CELL_CHAR = " ", e.WHITESPACE_CELL_WIDTH = 1, e.WHITESPACE_CELL_CODE = 32;
    }, 133: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.Utf8ToUtf32 = e.StringToUtf32 = e.utf32ToString = e.stringFromCodePoint = void 0, e.stringFromCodePoint = function(d5) {
        return d5 > 65535 ? (d5 -= 65536, String.fromCharCode(55296 + (d5 >> 10)) + String.fromCharCode(d5 % 1024 + 56320)) : String.fromCharCode(d5);
      }, e.utf32ToString = function(d5, l4 = 0, a2 = d5.length) {
        let o3 = "";
        for (let _5 = l4; _5 < a2; ++_5) {
          let p6 = d5[_5];
          p6 > 65535 ? (p6 -= 65536, o3 += String.fromCharCode(55296 + (p6 >> 10)) + String.fromCharCode(p6 % 1024 + 56320)) : o3 += String.fromCharCode(p6);
        }
        return o3;
      }, e.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(d5, l4) {
          let a2 = d5.length;
          if (!a2)
            return 0;
          let o3 = 0, _5 = 0;
          if (this._interim) {
            let p6 = d5.charCodeAt(_5++);
            56320 <= p6 && p6 <= 57343 ? l4[o3++] = 1024 * (this._interim - 55296) + p6 - 56320 + 65536 : (l4[o3++] = this._interim, l4[o3++] = p6), this._interim = 0;
          }
          for (let p6 = _5; p6 < a2; ++p6) {
            let c3 = d5.charCodeAt(p6);
            if (55296 <= c3 && c3 <= 56319) {
              if (++p6 >= a2)
                return this._interim = c3, o3;
              let i4 = d5.charCodeAt(p6);
              56320 <= i4 && i4 <= 57343 ? l4[o3++] = 1024 * (c3 - 55296) + i4 - 56320 + 65536 : (l4[o3++] = c3, l4[o3++] = i4);
            } else
              c3 !== 65279 && (l4[o3++] = c3);
          }
          return o3;
        }
      }, e.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(d5, l4) {
          let a2 = d5.length;
          if (!a2)
            return 0;
          let o3, _5, p6, c3, i4 = 0, t = 0, g4 = 0;
          if (this.interim[0]) {
            let S6 = false, R4 = this.interim[0];
            R4 &= (224 & R4) == 192 ? 31 : (240 & R4) == 224 ? 15 : 7;
            let A5, E5 = 0;
            for (; (A5 = 63 & this.interim[++E5]) && E5 < 4; )
              R4 <<= 6, R4 |= A5;
            let r = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, u3 = r - E5;
            for (; g4 < u3; ) {
              if (g4 >= a2)
                return 0;
              if (A5 = d5[g4++], (192 & A5) != 128) {
                g4--, S6 = true;
                break;
              }
              this.interim[E5++] = A5, R4 <<= 6, R4 |= 63 & A5;
            }
            S6 || (r === 2 ? R4 < 128 ? g4-- : l4[i4++] = R4 : r === 3 ? R4 < 2048 || R4 >= 55296 && R4 <= 57343 || R4 === 65279 || (l4[i4++] = R4) : R4 < 65536 || R4 > 1114111 || (l4[i4++] = R4)), this.interim.fill(0);
          }
          let L5 = a2 - 4, x5 = g4;
          for (; x5 < a2; ) {
            for (; !(!(x5 < L5) || 128 & (o3 = d5[x5]) || 128 & (_5 = d5[x5 + 1]) || 128 & (p6 = d5[x5 + 2]) || 128 & (c3 = d5[x5 + 3])); )
              l4[i4++] = o3, l4[i4++] = _5, l4[i4++] = p6, l4[i4++] = c3, x5 += 4;
            if (o3 = d5[x5++], o3 < 128)
              l4[i4++] = o3;
            else if ((224 & o3) == 192) {
              if (x5 >= a2)
                return this.interim[0] = o3, i4;
              if (_5 = d5[x5++], (192 & _5) != 128) {
                x5--;
                continue;
              }
              if (t = (31 & o3) << 6 | 63 & _5, t < 128) {
                x5--;
                continue;
              }
              l4[i4++] = t;
            } else if ((240 & o3) == 224) {
              if (x5 >= a2)
                return this.interim[0] = o3, i4;
              if (_5 = d5[x5++], (192 & _5) != 128) {
                x5--;
                continue;
              }
              if (x5 >= a2)
                return this.interim[0] = o3, this.interim[1] = _5, i4;
              if (p6 = d5[x5++], (192 & p6) != 128) {
                x5--;
                continue;
              }
              if (t = (15 & o3) << 12 | (63 & _5) << 6 | 63 & p6, t < 2048 || t >= 55296 && t <= 57343 || t === 65279)
                continue;
              l4[i4++] = t;
            } else if ((248 & o3) == 240) {
              if (x5 >= a2)
                return this.interim[0] = o3, i4;
              if (_5 = d5[x5++], (192 & _5) != 128) {
                x5--;
                continue;
              }
              if (x5 >= a2)
                return this.interim[0] = o3, this.interim[1] = _5, i4;
              if (p6 = d5[x5++], (192 & p6) != 128) {
                x5--;
                continue;
              }
              if (x5 >= a2)
                return this.interim[0] = o3, this.interim[1] = _5, this.interim[2] = p6, i4;
              if (c3 = d5[x5++], (192 & c3) != 128) {
                x5--;
                continue;
              }
              if (t = (7 & o3) << 18 | (63 & _5) << 12 | (63 & p6) << 6 | 63 & c3, t < 65536 || t > 1114111)
                continue;
              l4[i4++] = t;
            }
          }
          return i4;
        }
      };
    }, 776: function(P7, e, d5) {
      var l4 = this && this.__decorate || function(t, g4, L5, x5) {
        var S6, R4 = arguments.length, A5 = R4 < 3 ? g4 : x5 === null ? x5 = Object.getOwnPropertyDescriptor(g4, L5) : x5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          A5 = Reflect.decorate(t, g4, L5, x5);
        else
          for (var E5 = t.length - 1; E5 >= 0; E5--)
            (S6 = t[E5]) && (A5 = (R4 < 3 ? S6(A5) : R4 > 3 ? S6(g4, L5, A5) : S6(g4, L5)) || A5);
        return R4 > 3 && A5 && Object.defineProperty(g4, L5, A5), A5;
      }, a2 = this && this.__param || function(t, g4) {
        return function(L5, x5) {
          g4(L5, x5, t);
        };
      };
      Object.defineProperty(e, "__esModule", { value: true }), e.traceCall = e.setTraceLogger = e.LogService = void 0;
      let o3 = d5(859), _5 = d5(97), p6 = { trace: _5.LogLevelEnum.TRACE, debug: _5.LogLevelEnum.DEBUG, info: _5.LogLevelEnum.INFO, warn: _5.LogLevelEnum.WARN, error: _5.LogLevelEnum.ERROR, off: _5.LogLevelEnum.OFF }, c3, i4 = e.LogService = class extends o3.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(t) {
          super(), this._optionsService = t, this._logLevel = _5.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), c3 = this;
        }
        _updateLogLevel() {
          this._logLevel = p6[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(t) {
          for (let g4 = 0; g4 < t.length; g4++)
            typeof t[g4] == "function" && (t[g4] = t[g4]());
        }
        _log(t, g4, L5) {
          this._evalLazyOptionalParams(L5), t.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + g4, ...L5);
        }
        trace(t, ...g4) {
          var L5, x5;
          this._logLevel <= _5.LogLevelEnum.TRACE && this._log((x5 = (L5 = this._optionsService.options.logger) === null || L5 === void 0 ? void 0 : L5.trace.bind(this._optionsService.options.logger)) !== null && x5 !== void 0 ? x5 : console.log, t, g4);
        }
        debug(t, ...g4) {
          var L5, x5;
          this._logLevel <= _5.LogLevelEnum.DEBUG && this._log((x5 = (L5 = this._optionsService.options.logger) === null || L5 === void 0 ? void 0 : L5.debug.bind(this._optionsService.options.logger)) !== null && x5 !== void 0 ? x5 : console.log, t, g4);
        }
        info(t, ...g4) {
          var L5, x5;
          this._logLevel <= _5.LogLevelEnum.INFO && this._log((x5 = (L5 = this._optionsService.options.logger) === null || L5 === void 0 ? void 0 : L5.info.bind(this._optionsService.options.logger)) !== null && x5 !== void 0 ? x5 : console.info, t, g4);
        }
        warn(t, ...g4) {
          var L5, x5;
          this._logLevel <= _5.LogLevelEnum.WARN && this._log((x5 = (L5 = this._optionsService.options.logger) === null || L5 === void 0 ? void 0 : L5.warn.bind(this._optionsService.options.logger)) !== null && x5 !== void 0 ? x5 : console.warn, t, g4);
        }
        error(t, ...g4) {
          var L5, x5;
          this._logLevel <= _5.LogLevelEnum.ERROR && this._log((x5 = (L5 = this._optionsService.options.logger) === null || L5 === void 0 ? void 0 : L5.error.bind(this._optionsService.options.logger)) !== null && x5 !== void 0 ? x5 : console.error, t, g4);
        }
      };
      e.LogService = i4 = l4([a2(0, _5.IOptionsService)], i4), e.setTraceLogger = function(t) {
        c3 = t;
      }, e.traceCall = function(t, g4, L5) {
        if (typeof L5.value != "function")
          throw new Error("not supported");
        let x5 = L5.value;
        L5.value = function(...S6) {
          if (c3.logLevel !== _5.LogLevelEnum.TRACE)
            return x5.apply(this, S6);
          c3.trace(`GlyphRenderer#${x5.name}(${S6.map((A5) => JSON.stringify(A5)).join(", ")})`);
          let R4 = x5.apply(this, S6);
          return c3.trace(`GlyphRenderer#${x5.name} return`, R4), R4;
        };
      };
    }, 726: (P7, e) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.createDecorator = e.getServiceDependencies = e.serviceRegistry = void 0;
      let d5 = "di$target", l4 = "di$dependencies";
      e.serviceRegistry = /* @__PURE__ */ new Map(), e.getServiceDependencies = function(a2) {
        return a2[l4] || [];
      }, e.createDecorator = function(a2) {
        if (e.serviceRegistry.has(a2))
          return e.serviceRegistry.get(a2);
        let o3 = function(_5, p6, c3) {
          if (arguments.length !== 3)
            throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(i4, t, g4) {
            t[d5] === t ? t[l4].push({ id: i4, index: g4 }) : (t[l4] = [{ id: i4, index: g4 }], t[d5] = t);
          })(o3, _5, c3);
        };
        return o3.toString = () => a2, e.serviceRegistry.set(a2, o3), o3;
      };
    }, 97: (P7, e, d5) => {
      Object.defineProperty(e, "__esModule", { value: true }), e.IDecorationService = e.IUnicodeService = e.IOscLinkService = e.IOptionsService = e.ILogService = e.LogLevelEnum = e.IInstantiationService = e.ICharsetService = e.ICoreService = e.ICoreMouseService = e.IBufferService = void 0;
      let l4 = d5(726);
      var a2;
      e.IBufferService = (0, l4.createDecorator)("BufferService"), e.ICoreMouseService = (0, l4.createDecorator)("CoreMouseService"), e.ICoreService = (0, l4.createDecorator)("CoreService"), e.ICharsetService = (0, l4.createDecorator)("CharsetService"), e.IInstantiationService = (0, l4.createDecorator)("InstantiationService"), function(o3) {
        o3[o3.TRACE = 0] = "TRACE", o3[o3.DEBUG = 1] = "DEBUG", o3[o3.INFO = 2] = "INFO", o3[o3.WARN = 3] = "WARN", o3[o3.ERROR = 4] = "ERROR", o3[o3.OFF = 5] = "OFF";
      }(a2 || (e.LogLevelEnum = a2 = {})), e.ILogService = (0, l4.createDecorator)("LogService"), e.IOptionsService = (0, l4.createDecorator)("OptionsService"), e.IOscLinkService = (0, l4.createDecorator)("OscLinkService"), e.IUnicodeService = (0, l4.createDecorator)("UnicodeService"), e.IDecorationService = (0, l4.createDecorator)("DecorationService");
    } }, U4 = {};
    function V6(P7) {
      var e = U4[P7];
      if (e !== void 0)
        return e.exports;
      var d5 = U4[P7] = { exports: {} };
      return q6[P7].call(d5.exports, d5, d5.exports, V6), d5.exports;
    }
    var oe2 = {};
    return (() => {
      var P7 = oe2;
      Object.defineProperty(P7, "__esModule", { value: true }), P7.WebglAddon = void 0;
      let e = V6(345), d5 = V6(859), l4 = V6(399), a2 = V6(666), o3 = V6(776);
      class _5 extends d5.Disposable {
        constructor(c3) {
          if (l4.isSafari && (0, l4.getSafariVersion)() < 16)
            throw new Error("Webgl2 is only supported on Safari 16 and above");
          super(), this._preserveDrawingBuffer = c3, this._onChangeTextureAtlas = this.register(new e.EventEmitter()), this.onChangeTextureAtlas = this._onChangeTextureAtlas.event, this._onAddTextureAtlasCanvas = this.register(new e.EventEmitter()), this.onAddTextureAtlasCanvas = this._onAddTextureAtlasCanvas.event, this._onRemoveTextureAtlasCanvas = this.register(new e.EventEmitter()), this.onRemoveTextureAtlasCanvas = this._onRemoveTextureAtlasCanvas.event, this._onContextLoss = this.register(new e.EventEmitter()), this.onContextLoss = this._onContextLoss.event;
        }
        activate(c3) {
          let i4 = c3._core;
          if (!c3.element)
            return void this.register(i4.onWillOpen(() => this.activate(c3)));
          this._terminal = c3;
          let t = i4.coreService, g4 = i4.optionsService, L5 = i4, x5 = L5._renderService, S6 = L5._characterJoinerService, R4 = L5._charSizeService, A5 = L5._coreBrowserService, E5 = L5._decorationService, r = L5._logService, u3 = L5._themeService;
          (0, o3.setTraceLogger)(r), this._renderer = this.register(new a2.WebglRenderer(c3, S6, R4, A5, t, E5, g4, u3, this._preserveDrawingBuffer)), this.register((0, e.forwardEvent)(this._renderer.onContextLoss, this._onContextLoss)), this.register((0, e.forwardEvent)(this._renderer.onChangeTextureAtlas, this._onChangeTextureAtlas)), this.register((0, e.forwardEvent)(this._renderer.onAddTextureAtlasCanvas, this._onAddTextureAtlasCanvas)), this.register((0, e.forwardEvent)(this._renderer.onRemoveTextureAtlasCanvas, this._onRemoveTextureAtlasCanvas)), x5.setRenderer(this._renderer), this.register((0, d5.toDisposable)(() => {
            let C5 = this._terminal._core._renderService;
            C5.setRenderer(this._terminal._core._createRenderer()), C5.handleResize(c3.cols, c3.rows);
          }));
        }
        get textureAtlas() {
          var c3;
          return (c3 = this._renderer) === null || c3 === void 0 ? void 0 : c3.textureAtlas;
        }
        clearTextureAtlas() {
          var c3;
          (c3 = this._renderer) === null || c3 === void 0 || c3.clearTextureAtlas();
        }
      }
      P7.WebglAddon = _5;
    })(), oe2;
  })());
});
var te2 = {};
Be2(te2, { WebglAddon: () => Oe2, __esModule: () => Ie2, default: () => ke2 });
var Ae2 = Me2(we2());
se2(te2, Me2(we2()));
var { __esModule: Ie2, WebglAddon: Oe2 } = Ae2;
var { default: ye2, ...$e2 } = Ae2;
var ke2 = ye2 !== void 0 ? ye2 : $e2;

// esbuild_serve:http-import:https://esm.sh/xterm@5.3.0
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();

// esbuild_serve:http-import:https://esm.sh/v135/xterm@5.3.0/denonext/xterm.mjs
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
var ke3 = Object.create;
var pe2 = Object.defineProperty;
var Le3 = Object.getOwnPropertyDescriptor;
var De3 = Object.getOwnPropertyNames;
var Re2 = Object.getPrototypeOf;
var xe = Object.prototype.hasOwnProperty;
var Ae3 = (G5, z4) => () => (z4 || G5((z4 = { exports: {} }).exports, z4), z4.exports);
var Be3 = (G5, z4) => {
  for (var K3 in z4)
    pe2(G5, K3, { get: z4[K3], enumerable: true });
};
var ge2 = (G5, z4, K3, Q5) => {
  if (z4 && typeof z4 == "object" || typeof z4 == "function")
    for (let P7 of De3(z4))
      !xe.call(G5, P7) && P7 !== K3 && pe2(G5, P7, { get: () => z4[P7], enumerable: !(Q5 = Le3(z4, P7)) || Q5.enumerable });
  return G5;
};
var se3 = (G5, z4, K3) => (ge2(G5, z4, "default"), K3 && ge2(K3, z4, "default"));
var Ce2 = (G5, z4, K3) => (K3 = G5 != null ? ke3(Re2(G5)) : {}, ge2(z4 || !G5 || !G5.__esModule ? pe2(K3, "default", { value: G5, enumerable: true }) : K3, G5));
var Se3 = Ae3((le2, me3) => {
  (function(G5, z4) {
    if (typeof le2 == "object" && typeof me3 == "object")
      me3.exports = z4();
    else if (typeof define == "function" && define.amd)
      define([], z4);
    else {
      var K3 = z4();
      for (var Q5 in K3)
        (typeof le2 == "object" ? le2 : G5)[Q5] = K3[Q5];
    }
  })(self, () => (() => {
    "use strict";
    var G5 = { 4567: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(i4, o3, c3, v5) {
        var m6, h5 = arguments.length, g4 = h5 < 3 ? o3 : v5 === null ? v5 = Object.getOwnPropertyDescriptor(o3, c3) : v5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          g4 = Reflect.decorate(i4, o3, c3, v5);
        else
          for (var b5 = i4.length - 1; b5 >= 0; b5--)
            (m6 = i4[b5]) && (g4 = (h5 < 3 ? m6(g4) : h5 > 3 ? m6(o3, c3, g4) : m6(o3, c3)) || g4);
        return h5 > 3 && g4 && Object.defineProperty(o3, c3, g4), g4;
      }, u3 = this && this.__param || function(i4, o3) {
        return function(c3, v5) {
          o3(c3, v5, i4);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.AccessibilityManager = void 0;
      let n3 = a2(9042), d5 = a2(6114), f4 = a2(9924), p6 = a2(844), _5 = a2(5596), e = a2(4725), s2 = a2(3656), t = r.AccessibilityManager = class extends p6.Disposable {
        constructor(i4, o3) {
          super(), this._terminal = i4, this._renderService = o3, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = document.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = document.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
          for (let c3 = 0; c3 < this._terminal.rows; c3++)
            this._rowElements[c3] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[c3]);
          if (this._topBoundaryFocusListener = (c3) => this._handleBoundaryFocus(c3, 0), this._bottomBoundaryFocusListener = (c3) => this._handleBoundaryFocus(c3, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = document.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new f4.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element)
            throw new Error("Cannot enable accessibility before Terminal.open");
          this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((c3) => this._handleResize(c3.rows))), this.register(this._terminal.onRender((c3) => this._refreshRows(c3.start, c3.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((c3) => this._handleChar(c3))), this.register(this._terminal.onLineFeed(() => this._handleChar(`
`))), this.register(this._terminal.onA11yTab((c3) => this._handleTab(c3))), this.register(this._terminal.onKey((c3) => this._handleKey(c3.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new _5.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, s2.addDisposableDomListener)(window, "resize", () => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, p6.toDisposable)(() => {
            this._accessibilityContainer.remove(), this._rowElements.length = 0;
          }));
        }
        _handleTab(i4) {
          for (let o3 = 0; o3 < i4; o3++)
            this._handleChar(" ");
        }
        _handleChar(i4) {
          this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== i4 && (this._charsToAnnounce += i4) : this._charsToAnnounce += i4, i4 === `
` && (this._liveRegionLineCount++, this._liveRegionLineCount === 21 && (this._liveRegion.textContent += n3.tooMuchOutput)), d5.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {
            this._accessibilityContainer.appendChild(this._liveRegion);
          }, 0));
        }
        _clearLiveRegion() {
          this._liveRegion.textContent = "", this._liveRegionLineCount = 0, d5.isMac && this._liveRegion.remove();
        }
        _handleKey(i4) {
          this._clearLiveRegion(), /\p{Control}/u.test(i4) || this._charsToConsume.push(i4);
        }
        _refreshRows(i4, o3) {
          this._liveRegionDebouncer.refresh(i4, o3, this._terminal.rows);
        }
        _renderRows(i4, o3) {
          let c3 = this._terminal.buffer, v5 = c3.lines.length.toString();
          for (let m6 = i4; m6 <= o3; m6++) {
            let h5 = c3.translateBufferLineToString(c3.ydisp + m6, true), g4 = (c3.ydisp + m6 + 1).toString(), b5 = this._rowElements[m6];
            b5 && (h5.length === 0 ? b5.innerText = "\xA0" : b5.textContent = h5, b5.setAttribute("aria-posinset", g4), b5.setAttribute("aria-setsize", v5));
          }
          this._announceCharacters();
        }
        _announceCharacters() {
          this._charsToAnnounce.length !== 0 && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
        }
        _handleBoundaryFocus(i4, o3) {
          let c3 = i4.target, v5 = this._rowElements[o3 === 0 ? 1 : this._rowElements.length - 2];
          if (c3.getAttribute("aria-posinset") === (o3 === 0 ? "1" : `${this._terminal.buffer.lines.length}`) || i4.relatedTarget !== v5)
            return;
          let m6, h5;
          if (o3 === 0 ? (m6 = c3, h5 = this._rowElements.pop(), this._rowContainer.removeChild(h5)) : (m6 = this._rowElements.shift(), h5 = c3, this._rowContainer.removeChild(m6)), m6.removeEventListener("focus", this._topBoundaryFocusListener), h5.removeEventListener("focus", this._bottomBoundaryFocusListener), o3 === 0) {
            let g4 = this._createAccessibilityTreeNode();
            this._rowElements.unshift(g4), this._rowContainer.insertAdjacentElement("afterbegin", g4);
          } else {
            let g4 = this._createAccessibilityTreeNode();
            this._rowElements.push(g4), this._rowContainer.appendChild(g4);
          }
          this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(o3 === 0 ? -1 : 1), this._rowElements[o3 === 0 ? 1 : this._rowElements.length - 2].focus(), i4.preventDefault(), i4.stopImmediatePropagation();
        }
        _handleResize(i4) {
          this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
          for (let o3 = this._rowContainer.children.length; o3 < this._terminal.rows; o3++)
            this._rowElements[o3] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[o3]);
          for (; this._rowElements.length > i4; )
            this._rowContainer.removeChild(this._rowElements.pop());
          this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
        }
        _createAccessibilityTreeNode() {
          let i4 = document.createElement("div");
          return i4.setAttribute("role", "listitem"), i4.tabIndex = -1, this._refreshRowDimensions(i4), i4;
        }
        _refreshRowsDimensions() {
          if (this._renderService.dimensions.css.cell.height) {
            this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
            for (let i4 = 0; i4 < this._terminal.rows; i4++)
              this._refreshRowDimensions(this._rowElements[i4]);
          }
        }
        _refreshRowDimensions(i4) {
          i4.style.height = `${this._renderService.dimensions.css.cell.height}px`;
        }
      };
      r.AccessibilityManager = t = l4([u3(1, e.IRenderService)], t);
    }, 3614: (P7, r) => {
      function a2(d5) {
        return d5.replace(/\r?\n/g, "\r");
      }
      function l4(d5, f4) {
        return f4 ? "\x1B[200~" + d5 + "\x1B[201~" : d5;
      }
      function u3(d5, f4, p6, _5) {
        d5 = l4(d5 = a2(d5), p6.decPrivateModes.bracketedPasteMode && _5.rawOptions.ignoreBracketedPasteMode !== true), p6.triggerDataEvent(d5, true), f4.value = "";
      }
      function n3(d5, f4, p6) {
        let _5 = p6.getBoundingClientRect(), e = d5.clientX - _5.left - 10, s2 = d5.clientY - _5.top - 10;
        f4.style.width = "20px", f4.style.height = "20px", f4.style.left = `${e}px`, f4.style.top = `${s2}px`, f4.style.zIndex = "1000", f4.focus();
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.rightClickHandler = r.moveTextAreaUnderMouseCursor = r.paste = r.handlePasteEvent = r.copyHandler = r.bracketTextForPaste = r.prepareTextForTerminal = void 0, r.prepareTextForTerminal = a2, r.bracketTextForPaste = l4, r.copyHandler = function(d5, f4) {
        d5.clipboardData && d5.clipboardData.setData("text/plain", f4.selectionText), d5.preventDefault();
      }, r.handlePasteEvent = function(d5, f4, p6, _5) {
        d5.stopPropagation(), d5.clipboardData && u3(d5.clipboardData.getData("text/plain"), f4, p6, _5);
      }, r.paste = u3, r.moveTextAreaUnderMouseCursor = n3, r.rightClickHandler = function(d5, f4, p6, _5, e) {
        n3(d5, f4, p6), e && _5.rightClickSelect(d5), f4.value = _5.selectionText, f4.select();
      };
    }, 7239: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.ColorContrastCache = void 0;
      let l4 = a2(1505);
      r.ColorContrastCache = class {
        constructor() {
          this._color = new l4.TwoKeyMap(), this._css = new l4.TwoKeyMap();
        }
        setCss(u3, n3, d5) {
          this._css.set(u3, n3, d5);
        }
        getCss(u3, n3) {
          return this._css.get(u3, n3);
        }
        setColor(u3, n3, d5) {
          this._color.set(u3, n3, d5);
        }
        getColor(u3, n3) {
          return this._color.get(u3, n3);
        }
        clear() {
          this._color.clear(), this._css.clear();
        }
      };
    }, 3656: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.addDisposableDomListener = void 0, r.addDisposableDomListener = function(a2, l4, u3, n3) {
        a2.addEventListener(l4, u3, n3);
        let d5 = false;
        return { dispose: () => {
          d5 || (d5 = true, a2.removeEventListener(l4, u3, n3));
        } };
      };
    }, 6465: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(e, s2, t, i4) {
        var o3, c3 = arguments.length, v5 = c3 < 3 ? s2 : i4 === null ? i4 = Object.getOwnPropertyDescriptor(s2, t) : i4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          v5 = Reflect.decorate(e, s2, t, i4);
        else
          for (var m6 = e.length - 1; m6 >= 0; m6--)
            (o3 = e[m6]) && (v5 = (c3 < 3 ? o3(v5) : c3 > 3 ? o3(s2, t, v5) : o3(s2, t)) || v5);
        return c3 > 3 && v5 && Object.defineProperty(s2, t, v5), v5;
      }, u3 = this && this.__param || function(e, s2) {
        return function(t, i4) {
          s2(t, i4, e);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.Linkifier2 = void 0;
      let n3 = a2(3656), d5 = a2(8460), f4 = a2(844), p6 = a2(2585), _5 = r.Linkifier2 = class extends f4.Disposable {
        get currentLink() {
          return this._currentLink;
        }
        constructor(e) {
          super(), this._bufferService = e, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new d5.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new d5.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, f4.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, f4.toDisposable)(() => {
            this._lastMouseEvent = void 0;
          })), this.register(this._bufferService.onResize(() => {
            this._clearCurrentLink(), this._wasResized = true;
          }));
        }
        registerLinkProvider(e) {
          return this._linkProviders.push(e), { dispose: () => {
            let s2 = this._linkProviders.indexOf(e);
            s2 !== -1 && this._linkProviders.splice(s2, 1);
          } };
        }
        attachToDom(e, s2, t) {
          this._element = e, this._mouseService = s2, this._renderService = t, this.register((0, n3.addDisposableDomListener)(this._element, "mouseleave", () => {
            this._isMouseOut = true, this._clearCurrentLink();
          })), this.register((0, n3.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n3.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n3.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
        }
        _handleMouseMove(e) {
          if (this._lastMouseEvent = e, !this._element || !this._mouseService)
            return;
          let s2 = this._positionFromMouseEvent(e, this._element, this._mouseService);
          if (!s2)
            return;
          this._isMouseOut = false;
          let t = e.composedPath();
          for (let i4 = 0; i4 < t.length; i4++) {
            let o3 = t[i4];
            if (o3.classList.contains("xterm"))
              break;
            if (o3.classList.contains("xterm-hover"))
              return;
          }
          this._lastBufferCell && s2.x === this._lastBufferCell.x && s2.y === this._lastBufferCell.y || (this._handleHover(s2), this._lastBufferCell = s2);
        }
        _handleHover(e) {
          if (this._activeLine !== e.y || this._wasResized)
            return this._clearCurrentLink(), this._askForLink(e, false), void (this._wasResized = false);
          this._currentLink && this._linkAtPosition(this._currentLink.link, e) || (this._clearCurrentLink(), this._askForLink(e, true));
        }
        _askForLink(e, s2) {
          var t, i4;
          this._activeProviderReplies && s2 || ((t = this._activeProviderReplies) === null || t === void 0 || t.forEach((c3) => {
            c3?.forEach((v5) => {
              v5.link.dispose && v5.link.dispose();
            });
          }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e.y);
          let o3 = false;
          for (let [c3, v5] of this._linkProviders.entries())
            s2 ? !((i4 = this._activeProviderReplies) === null || i4 === void 0) && i4.get(c3) && (o3 = this._checkLinkProviderResult(c3, e, o3)) : v5.provideLinks(e.y, (m6) => {
              var h5, g4;
              if (this._isMouseOut)
                return;
              let b5 = m6?.map((L5) => ({ link: L5 }));
              (h5 = this._activeProviderReplies) === null || h5 === void 0 || h5.set(c3, b5), o3 = this._checkLinkProviderResult(c3, e, o3), ((g4 = this._activeProviderReplies) === null || g4 === void 0 ? void 0 : g4.size) === this._linkProviders.length && this._removeIntersectingLinks(e.y, this._activeProviderReplies);
            });
        }
        _removeIntersectingLinks(e, s2) {
          let t = /* @__PURE__ */ new Set();
          for (let i4 = 0; i4 < s2.size; i4++) {
            let o3 = s2.get(i4);
            if (o3)
              for (let c3 = 0; c3 < o3.length; c3++) {
                let v5 = o3[c3], m6 = v5.link.range.start.y < e ? 0 : v5.link.range.start.x, h5 = v5.link.range.end.y > e ? this._bufferService.cols : v5.link.range.end.x;
                for (let g4 = m6; g4 <= h5; g4++) {
                  if (t.has(g4)) {
                    o3.splice(c3--, 1);
                    break;
                  }
                  t.add(g4);
                }
              }
          }
        }
        _checkLinkProviderResult(e, s2, t) {
          var i4;
          if (!this._activeProviderReplies)
            return t;
          let o3 = this._activeProviderReplies.get(e), c3 = false;
          for (let v5 = 0; v5 < e; v5++)
            this._activeProviderReplies.has(v5) && !this._activeProviderReplies.get(v5) || (c3 = true);
          if (!c3 && o3) {
            let v5 = o3.find((m6) => this._linkAtPosition(m6.link, s2));
            v5 && (t = true, this._handleNewLink(v5));
          }
          if (this._activeProviderReplies.size === this._linkProviders.length && !t)
            for (let v5 = 0; v5 < this._activeProviderReplies.size; v5++) {
              let m6 = (i4 = this._activeProviderReplies.get(v5)) === null || i4 === void 0 ? void 0 : i4.find((h5) => this._linkAtPosition(h5.link, s2));
              if (m6) {
                t = true, this._handleNewLink(m6);
                break;
              }
            }
          return t;
        }
        _handleMouseDown() {
          this._mouseDownLink = this._currentLink;
        }
        _handleMouseUp(e) {
          if (!this._element || !this._mouseService || !this._currentLink)
            return;
          let s2 = this._positionFromMouseEvent(e, this._element, this._mouseService);
          s2 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, s2) && this._currentLink.link.activate(e, this._currentLink.link.text);
        }
        _clearCurrentLink(e, s2) {
          this._element && this._currentLink && this._lastMouseEvent && (!e || !s2 || this._currentLink.link.range.start.y >= e && this._currentLink.link.range.end.y <= s2) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, f4.disposeArray)(this._linkCacheDisposables));
        }
        _handleNewLink(e) {
          if (!this._element || !this._lastMouseEvent || !this._mouseService)
            return;
          let s2 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
          s2 && this._linkAtPosition(e.link, s2) && (this._currentLink = e, this._currentLink.state = { decorations: { underline: e.link.decorations === void 0 || e.link.decorations.underline, pointerCursor: e.link.decorations === void 0 || e.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e.link, this._lastMouseEvent), e.link.decorations = {}, Object.defineProperties(e.link.decorations, { pointerCursor: { get: () => {
            var t, i4;
            return (i4 = (t = this._currentLink) === null || t === void 0 ? void 0 : t.state) === null || i4 === void 0 ? void 0 : i4.decorations.pointerCursor;
          }, set: (t) => {
            var i4, o3;
            !((i4 = this._currentLink) === null || i4 === void 0) && i4.state && this._currentLink.state.decorations.pointerCursor !== t && (this._currentLink.state.decorations.pointerCursor = t, this._currentLink.state.isHovered && ((o3 = this._element) === null || o3 === void 0 || o3.classList.toggle("xterm-cursor-pointer", t)));
          } }, underline: { get: () => {
            var t, i4;
            return (i4 = (t = this._currentLink) === null || t === void 0 ? void 0 : t.state) === null || i4 === void 0 ? void 0 : i4.decorations.underline;
          }, set: (t) => {
            var i4, o3, c3;
            !((i4 = this._currentLink) === null || i4 === void 0) && i4.state && ((c3 = (o3 = this._currentLink) === null || o3 === void 0 ? void 0 : o3.state) === null || c3 === void 0 ? void 0 : c3.decorations.underline) !== t && (this._currentLink.state.decorations.underline = t, this._currentLink.state.isHovered && this._fireUnderlineEvent(e.link, t));
          } } }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((t) => {
            if (!this._currentLink)
              return;
            let i4 = t.start === 0 ? 0 : t.start + 1 + this._bufferService.buffer.ydisp, o3 = this._bufferService.buffer.ydisp + 1 + t.end;
            if (this._currentLink.link.range.start.y >= i4 && this._currentLink.link.range.end.y <= o3 && (this._clearCurrentLink(i4, o3), this._lastMouseEvent && this._element)) {
              let c3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              c3 && this._askForLink(c3, false);
            }
          })));
        }
        _linkHover(e, s2, t) {
          var i4;
          !((i4 = this._currentLink) === null || i4 === void 0) && i4.state && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(s2, true), this._currentLink.state.decorations.pointerCursor && e.classList.add("xterm-cursor-pointer")), s2.hover && s2.hover(t, s2.text);
        }
        _fireUnderlineEvent(e, s2) {
          let t = e.range, i4 = this._bufferService.buffer.ydisp, o3 = this._createLinkUnderlineEvent(t.start.x - 1, t.start.y - i4 - 1, t.end.x, t.end.y - i4 - 1, void 0);
          (s2 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(o3);
        }
        _linkLeave(e, s2, t) {
          var i4;
          !((i4 = this._currentLink) === null || i4 === void 0) && i4.state && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(s2, false), this._currentLink.state.decorations.pointerCursor && e.classList.remove("xterm-cursor-pointer")), s2.leave && s2.leave(t, s2.text);
        }
        _linkAtPosition(e, s2) {
          let t = e.range.start.y * this._bufferService.cols + e.range.start.x, i4 = e.range.end.y * this._bufferService.cols + e.range.end.x, o3 = s2.y * this._bufferService.cols + s2.x;
          return t <= o3 && o3 <= i4;
        }
        _positionFromMouseEvent(e, s2, t) {
          let i4 = t.getCoords(e, s2, this._bufferService.cols, this._bufferService.rows);
          if (i4)
            return { x: i4[0], y: i4[1] + this._bufferService.buffer.ydisp };
        }
        _createLinkUnderlineEvent(e, s2, t, i4, o3) {
          return { x1: e, y1: s2, x2: t, y2: i4, cols: this._bufferService.cols, fg: o3 };
        }
      };
      r.Linkifier2 = _5 = l4([u3(0, p6.IBufferService)], _5);
    }, 9042: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.tooMuchOutput = r.promptLabel = void 0, r.promptLabel = "Terminal input", r.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
    }, 3730: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(_5, e, s2, t) {
        var i4, o3 = arguments.length, c3 = o3 < 3 ? e : t === null ? t = Object.getOwnPropertyDescriptor(e, s2) : t;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          c3 = Reflect.decorate(_5, e, s2, t);
        else
          for (var v5 = _5.length - 1; v5 >= 0; v5--)
            (i4 = _5[v5]) && (c3 = (o3 < 3 ? i4(c3) : o3 > 3 ? i4(e, s2, c3) : i4(e, s2)) || c3);
        return o3 > 3 && c3 && Object.defineProperty(e, s2, c3), c3;
      }, u3 = this && this.__param || function(_5, e) {
        return function(s2, t) {
          e(s2, t, _5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.OscLinkProvider = void 0;
      let n3 = a2(511), d5 = a2(2585), f4 = r.OscLinkProvider = class {
        constructor(_5, e, s2) {
          this._bufferService = _5, this._optionsService = e, this._oscLinkService = s2;
        }
        provideLinks(_5, e) {
          var s2;
          let t = this._bufferService.buffer.lines.get(_5 - 1);
          if (!t)
            return void e(void 0);
          let i4 = [], o3 = this._optionsService.rawOptions.linkHandler, c3 = new n3.CellData(), v5 = t.getTrimmedLength(), m6 = -1, h5 = -1, g4 = false;
          for (let b5 = 0; b5 < v5; b5++)
            if (h5 !== -1 || t.hasContent(b5)) {
              if (t.loadCell(b5, c3), c3.hasExtendedAttrs() && c3.extended.urlId) {
                if (h5 === -1) {
                  h5 = b5, m6 = c3.extended.urlId;
                  continue;
                }
                g4 = c3.extended.urlId !== m6;
              } else
                h5 !== -1 && (g4 = true);
              if (g4 || h5 !== -1 && b5 === v5 - 1) {
                let L5 = (s2 = this._oscLinkService.getLinkData(m6)) === null || s2 === void 0 ? void 0 : s2.uri;
                if (L5) {
                  let y5 = { start: { x: h5 + 1, y: _5 }, end: { x: b5 + (g4 || b5 !== v5 - 1 ? 0 : 1), y: _5 } }, k4 = false;
                  if (!o3?.allowNonHttpProtocols)
                    try {
                      let x5 = new URL(L5);
                      ["http:", "https:"].includes(x5.protocol) || (k4 = true);
                    } catch {
                      k4 = true;
                    }
                  k4 || i4.push({ text: L5, range: y5, activate: (x5, T6) => o3 ? o3.activate(x5, T6, y5) : p6(0, T6), hover: (x5, T6) => {
                    var O6;
                    return (O6 = o3?.hover) === null || O6 === void 0 ? void 0 : O6.call(o3, x5, T6, y5);
                  }, leave: (x5, T6) => {
                    var O6;
                    return (O6 = o3?.leave) === null || O6 === void 0 ? void 0 : O6.call(o3, x5, T6, y5);
                  } });
                }
                g4 = false, c3.hasExtendedAttrs() && c3.extended.urlId ? (h5 = b5, m6 = c3.extended.urlId) : (h5 = -1, m6 = -1);
              }
            }
          e(i4);
        }
      };
      function p6(_5, e) {
        if (confirm(`Do you want to navigate to ${e}?

WARNING: This link could potentially be dangerous`)) {
          let s2 = window.open();
          if (s2) {
            try {
              s2.opener = null;
            } catch {
            }
            s2.location.href = e;
          } else
            console.warn("Opening link blocked as opener could not be cleared");
        }
      }
      r.OscLinkProvider = f4 = l4([u3(0, d5.IBufferService), u3(1, d5.IOptionsService), u3(2, d5.IOscLinkService)], f4);
    }, 6193: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.RenderDebouncer = void 0, r.RenderDebouncer = class {
        constructor(a2, l4) {
          this._parentWindow = a2, this._renderCallback = l4, this._refreshCallbacks = [];
        }
        dispose() {
          this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
        }
        addRefreshCallback(a2) {
          return this._refreshCallbacks.push(a2), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
        }
        refresh(a2, l4, u3) {
          this._rowCount = u3, a2 = a2 !== void 0 ? a2 : 0, l4 = l4 !== void 0 ? l4 : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, a2) : a2, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, l4) : l4, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._animationFrame = void 0, this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
            return void this._runRefreshCallbacks();
          let a2 = Math.max(this._rowStart, 0), l4 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(a2, l4), this._runRefreshCallbacks();
        }
        _runRefreshCallbacks() {
          for (let a2 of this._refreshCallbacks)
            a2(0);
          this._refreshCallbacks = [];
        }
      };
    }, 5596: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.ScreenDprMonitor = void 0;
      let l4 = a2(844);
      class u3 extends l4.Disposable {
        constructor(d5) {
          super(), this._parentWindow = d5, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this.register((0, l4.toDisposable)(() => {
            this.clearListener();
          }));
        }
        setListener(d5) {
          this._listener && this.clearListener(), this._listener = d5, this._outerListener = () => {
            this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());
          }, this._updateDpr();
        }
        _updateDpr() {
          var d5;
          this._outerListener && ((d5 = this._resolutionMediaMatchList) === null || d5 === void 0 || d5.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
        }
        clearListener() {
          this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);
        }
      }
      r.ScreenDprMonitor = u3;
    }, 3236: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.Terminal = void 0;
      let l4 = a2(3614), u3 = a2(3656), n3 = a2(6465), d5 = a2(9042), f4 = a2(3730), p6 = a2(1680), _5 = a2(3107), e = a2(5744), s2 = a2(2950), t = a2(1296), i4 = a2(428), o3 = a2(4269), c3 = a2(5114), v5 = a2(8934), m6 = a2(3230), h5 = a2(9312), g4 = a2(4725), b5 = a2(6731), L5 = a2(8055), y5 = a2(8969), k4 = a2(8460), x5 = a2(844), T6 = a2(6114), O6 = a2(8437), M5 = a2(2584), C5 = a2(7399), w4 = a2(5941), E5 = a2(9074), D5 = a2(2585), I7 = a2(5435), H4 = a2(4567), U4 = typeof window < "u" ? window.document : null;
      class W5 extends y5.CoreTerminal {
        get onFocus() {
          return this._onFocus.event;
        }
        get onBlur() {
          return this._onBlur.event;
        }
        get onA11yChar() {
          return this._onA11yCharEmitter.event;
        }
        get onA11yTab() {
          return this._onA11yTabEmitter.event;
        }
        get onWillOpen() {
          return this._onWillOpen.event;
        }
        constructor(S6 = {}) {
          super(S6), this.browser = T6, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new x5.MutableDisposable()), this._onCursorMove = this.register(new k4.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new k4.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new k4.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new k4.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new k4.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new k4.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new k4.EventEmitter()), this._onBlur = this.register(new k4.EventEmitter()), this._onA11yCharEmitter = this.register(new k4.EventEmitter()), this._onA11yTabEmitter = this.register(new k4.EventEmitter()), this._onWillOpen = this.register(new k4.EventEmitter()), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(n3.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(f4.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(E5.DecorationService), this._instantiationService.setService(D5.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((R4, B4) => this.refresh(R4, B4))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((R4) => this._reportWindowsOptions(R4))), this.register(this._inputHandler.onColor((R4) => this._handleColorEvent(R4))), this.register((0, k4.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, k4.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, k4.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, k4.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((R4) => this._afterResize(R4.cols, R4.rows))), this.register((0, x5.toDisposable)(() => {
            var R4, B4;
            this._customKeyEventHandler = void 0, (B4 = (R4 = this.element) === null || R4 === void 0 ? void 0 : R4.parentNode) === null || B4 === void 0 || B4.removeChild(this.element);
          }));
        }
        _handleColorEvent(S6) {
          if (this._themeService)
            for (let R4 of S6) {
              let B4, A5 = "";
              switch (R4.index) {
                case 256:
                  B4 = "foreground", A5 = "10";
                  break;
                case 257:
                  B4 = "background", A5 = "11";
                  break;
                case 258:
                  B4 = "cursor", A5 = "12";
                  break;
                default:
                  B4 = "ansi", A5 = "4;" + R4.index;
              }
              switch (R4.type) {
                case 0:
                  let N6 = L5.color.toColorRGB(B4 === "ansi" ? this._themeService.colors.ansi[R4.index] : this._themeService.colors[B4]);
                  this.coreService.triggerDataEvent(`${M5.C0.ESC}]${A5};${(0, w4.toRgbString)(N6)}${M5.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if (B4 === "ansi")
                    this._themeService.modifyColors((F7) => F7.ansi[R4.index] = L5.rgba.toColor(...R4.color));
                  else {
                    let F7 = B4;
                    this._themeService.modifyColors((j7) => j7[F7] = L5.rgba.toColor(...R4.color));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(R4.index);
              }
            }
        }
        _setup() {
          super._setup(), this._customKeyEventHandler = void 0;
        }
        get buffer() {
          return this.buffers.active;
        }
        focus() {
          this.textarea && this.textarea.focus({ preventScroll: true });
        }
        _handleScreenReaderModeOptionChange(S6) {
          S6 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(H4.AccessibilityManager, this)) : this._accessibilityManager.clear();
        }
        _handleTextAreaFocus(S6) {
          this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(M5.C0.ESC + "[I"), this.updateCursorStyle(S6), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
        }
        blur() {
          var S6;
          return (S6 = this.textarea) === null || S6 === void 0 ? void 0 : S6.blur();
        }
        _handleTextAreaBlur() {
          this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(M5.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
        }
        _syncTextArea() {
          if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService)
            return;
          let S6 = this.buffer.ybase + this.buffer.y, R4 = this.buffer.lines.get(S6);
          if (!R4)
            return;
          let B4 = Math.min(this.buffer.x, this.cols - 1), A5 = this._renderService.dimensions.css.cell.height, N6 = R4.getWidth(B4), F7 = this._renderService.dimensions.css.cell.width * N6, j7 = this.buffer.y * this._renderService.dimensions.css.cell.height, X5 = B4 * this._renderService.dimensions.css.cell.width;
          this.textarea.style.left = X5 + "px", this.textarea.style.top = j7 + "px", this.textarea.style.width = F7 + "px", this.textarea.style.height = A5 + "px", this.textarea.style.lineHeight = A5 + "px", this.textarea.style.zIndex = "-5";
        }
        _initGlobal() {
          this._bindKeys(), this.register((0, u3.addDisposableDomListener)(this.element, "copy", (R4) => {
            this.hasSelection() && (0, l4.copyHandler)(R4, this._selectionService);
          }));
          let S6 = (R4) => (0, l4.handlePasteEvent)(R4, this.textarea, this.coreService, this.optionsService);
          this.register((0, u3.addDisposableDomListener)(this.textarea, "paste", S6)), this.register((0, u3.addDisposableDomListener)(this.element, "paste", S6)), T6.isFirefox ? this.register((0, u3.addDisposableDomListener)(this.element, "mousedown", (R4) => {
            R4.button === 2 && (0, l4.rightClickHandler)(R4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })) : this.register((0, u3.addDisposableDomListener)(this.element, "contextmenu", (R4) => {
            (0, l4.rightClickHandler)(R4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
          })), T6.isLinux && this.register((0, u3.addDisposableDomListener)(this.element, "auxclick", (R4) => {
            R4.button === 1 && (0, l4.moveTextAreaUnderMouseCursor)(R4, this.textarea, this.screenElement);
          }));
        }
        _bindKeys() {
          this.register((0, u3.addDisposableDomListener)(this.textarea, "keyup", (S6) => this._keyUp(S6), true)), this.register((0, u3.addDisposableDomListener)(this.textarea, "keydown", (S6) => this._keyDown(S6), true)), this.register((0, u3.addDisposableDomListener)(this.textarea, "keypress", (S6) => this._keyPress(S6), true)), this.register((0, u3.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, u3.addDisposableDomListener)(this.textarea, "compositionupdate", (S6) => this._compositionHelper.compositionupdate(S6))), this.register((0, u3.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, u3.addDisposableDomListener)(this.textarea, "input", (S6) => this._inputEvent(S6), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
        }
        open(S6) {
          var R4;
          if (!S6)
            throw new Error("Terminal requires a parent element.");
          S6.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this._document = S6.ownerDocument, this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), S6.appendChild(this.element);
          let B4 = U4.createDocumentFragment();
          this._viewportElement = U4.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), B4.appendChild(this._viewportElement), this._viewportScrollArea = U4.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = U4.createElement("div"), this.screenElement.classList.add("xterm-screen"), this._helperContainer = U4.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), B4.appendChild(this.screenElement), this.textarea = U4.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", d5.promptLabel), T6.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this._instantiationService.createInstance(c3.CoreBrowserService, this.textarea, (R4 = this._document.defaultView) !== null && R4 !== void 0 ? R4 : window), this._instantiationService.setService(g4.ICoreBrowserService, this._coreBrowserService), this.register((0, u3.addDisposableDomListener)(this.textarea, "focus", (A5) => this._handleTextAreaFocus(A5))), this.register((0, u3.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(i4.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(g4.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(b5.ThemeService), this._instantiationService.setService(g4.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(o3.CharacterJoinerService), this._instantiationService.setService(g4.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(m6.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(g4.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((A5) => this._onRender.fire(A5))), this.onResize((A5) => this._renderService.resize(A5.cols, A5.rows)), this._compositionView = U4.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(s2.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(B4);
          try {
            this._onWillOpen.fire(this.element);
          } catch {
          }
          this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this._mouseService = this._instantiationService.createInstance(v5.MouseService), this._instantiationService.setService(g4.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(p6.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((A5) => this.scrollLines(A5.amount, A5.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
            this._renderService.handleCursorMove(), this._syncTextArea();
          })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(h5.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(g4.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((A5) => this.scrollLines(A5.amount, A5.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((A5) => this._renderService.handleSelectionChanged(A5.start, A5.end, A5.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((A5) => {
            this.textarea.value = A5, this.textarea.focus(), this.textarea.select();
          })), this.register(this._onScroll.event((A5) => {
            this.viewport.syncScrollArea(), this._selectionService.refresh();
          })), this.register((0, u3.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(_5.BufferDecorationRenderer, this.screenElement)), this.register((0, u3.addDisposableDomListener)(this.element, "mousedown", (A5) => this._selectionService.handleMouseDown(A5))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(H4.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (A5) => this._handleScreenReaderModeOptionChange(A5))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(e.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (A5) => {
            !this._overviewRulerRenderer && A5 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(e.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
          }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
        }
        _createRenderer() {
          return this._instantiationService.createInstance(t.DomRenderer, this.element, this.screenElement, this._viewportElement, this.linkifier2);
        }
        bindMouse() {
          let S6 = this, R4 = this.element;
          function B4(F7) {
            let j7 = S6._mouseService.getMouseReportCoords(F7, S6.screenElement);
            if (!j7)
              return false;
            let X5, J5;
            switch (F7.overrideType || F7.type) {
              case "mousemove":
                J5 = 32, F7.buttons === void 0 ? (X5 = 3, F7.button !== void 0 && (X5 = F7.button < 3 ? F7.button : 3)) : X5 = 1 & F7.buttons ? 0 : 4 & F7.buttons ? 1 : 2 & F7.buttons ? 2 : 3;
                break;
              case "mouseup":
                J5 = 0, X5 = F7.button < 3 ? F7.button : 3;
                break;
              case "mousedown":
                J5 = 1, X5 = F7.button < 3 ? F7.button : 3;
                break;
              case "wheel":
                if (S6.viewport.getLinesScrolled(F7) === 0)
                  return false;
                J5 = F7.deltaY < 0 ? 0 : 1, X5 = 4;
                break;
              default:
                return false;
            }
            return !(J5 === void 0 || X5 === void 0 || X5 > 4) && S6.coreMouseService.triggerMouseEvent({ col: j7.col, row: j7.row, x: j7.x, y: j7.y, button: X5, action: J5, ctrl: F7.ctrlKey, alt: F7.altKey, shift: F7.shiftKey });
          }
          let A5 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, N6 = { mouseup: (F7) => (B4(F7), F7.buttons || (this._document.removeEventListener("mouseup", A5.mouseup), A5.mousedrag && this._document.removeEventListener("mousemove", A5.mousedrag)), this.cancel(F7)), wheel: (F7) => (B4(F7), this.cancel(F7, true)), mousedrag: (F7) => {
            F7.buttons && B4(F7);
          }, mousemove: (F7) => {
            F7.buttons || B4(F7);
          } };
          this.register(this.coreMouseService.onProtocolChange((F7) => {
            F7 ? (this.optionsService.rawOptions.logLevel === "debug" && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(F7)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & F7 ? A5.mousemove || (R4.addEventListener("mousemove", N6.mousemove), A5.mousemove = N6.mousemove) : (R4.removeEventListener("mousemove", A5.mousemove), A5.mousemove = null), 16 & F7 ? A5.wheel || (R4.addEventListener("wheel", N6.wheel, { passive: false }), A5.wheel = N6.wheel) : (R4.removeEventListener("wheel", A5.wheel), A5.wheel = null), 2 & F7 ? A5.mouseup || (R4.addEventListener("mouseup", N6.mouseup), A5.mouseup = N6.mouseup) : (this._document.removeEventListener("mouseup", A5.mouseup), R4.removeEventListener("mouseup", A5.mouseup), A5.mouseup = null), 4 & F7 ? A5.mousedrag || (A5.mousedrag = N6.mousedrag) : (this._document.removeEventListener("mousemove", A5.mousedrag), A5.mousedrag = null);
          })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, u3.addDisposableDomListener)(R4, "mousedown", (F7) => {
            if (F7.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(F7))
              return B4(F7), A5.mouseup && this._document.addEventListener("mouseup", A5.mouseup), A5.mousedrag && this._document.addEventListener("mousemove", A5.mousedrag), this.cancel(F7);
          })), this.register((0, u3.addDisposableDomListener)(R4, "wheel", (F7) => {
            if (!A5.wheel) {
              if (!this.buffer.hasScrollback) {
                let j7 = this.viewport.getLinesScrolled(F7);
                if (j7 === 0)
                  return;
                let X5 = M5.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (F7.deltaY < 0 ? "A" : "B"), J5 = "";
                for (let re2 = 0; re2 < Math.abs(j7); re2++)
                  J5 += X5;
                return this.coreService.triggerDataEvent(J5, true), this.cancel(F7, true);
              }
              return this.viewport.handleWheel(F7) ? this.cancel(F7) : void 0;
            }
          }, { passive: false })), this.register((0, u3.addDisposableDomListener)(R4, "touchstart", (F7) => {
            if (!this.coreMouseService.areMouseEventsActive)
              return this.viewport.handleTouchStart(F7), this.cancel(F7);
          }, { passive: true })), this.register((0, u3.addDisposableDomListener)(R4, "touchmove", (F7) => {
            if (!this.coreMouseService.areMouseEventsActive)
              return this.viewport.handleTouchMove(F7) ? void 0 : this.cancel(F7);
          }, { passive: false }));
        }
        refresh(S6, R4) {
          var B4;
          (B4 = this._renderService) === null || B4 === void 0 || B4.refreshRows(S6, R4);
        }
        updateCursorStyle(S6) {
          var R4;
          !((R4 = this._selectionService) === null || R4 === void 0) && R4.shouldColumnSelect(S6) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
        }
        _showCursor() {
          this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
        }
        scrollLines(S6, R4, B4 = 0) {
          var A5;
          B4 === 1 ? (super.scrollLines(S6, R4, B4), this.refresh(0, this.rows - 1)) : (A5 = this.viewport) === null || A5 === void 0 || A5.scrollLines(S6);
        }
        paste(S6) {
          (0, l4.paste)(S6, this.textarea, this.coreService, this.optionsService);
        }
        attachCustomKeyEventHandler(S6) {
          this._customKeyEventHandler = S6;
        }
        registerLinkProvider(S6) {
          return this.linkifier2.registerLinkProvider(S6);
        }
        registerCharacterJoiner(S6) {
          if (!this._characterJoinerService)
            throw new Error("Terminal must be opened first");
          let R4 = this._characterJoinerService.register(S6);
          return this.refresh(0, this.rows - 1), R4;
        }
        deregisterCharacterJoiner(S6) {
          if (!this._characterJoinerService)
            throw new Error("Terminal must be opened first");
          this._characterJoinerService.deregister(S6) && this.refresh(0, this.rows - 1);
        }
        get markers() {
          return this.buffer.markers;
        }
        registerMarker(S6) {
          return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + S6);
        }
        registerDecoration(S6) {
          return this._decorationService.registerDecoration(S6);
        }
        hasSelection() {
          return !!this._selectionService && this._selectionService.hasSelection;
        }
        select(S6, R4, B4) {
          this._selectionService.setSelection(S6, R4, B4);
        }
        getSelection() {
          return this._selectionService ? this._selectionService.selectionText : "";
        }
        getSelectionPosition() {
          if (this._selectionService && this._selectionService.hasSelection)
            return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
        }
        clearSelection() {
          var S6;
          (S6 = this._selectionService) === null || S6 === void 0 || S6.clearSelection();
        }
        selectAll() {
          var S6;
          (S6 = this._selectionService) === null || S6 === void 0 || S6.selectAll();
        }
        selectLines(S6, R4) {
          var B4;
          (B4 = this._selectionService) === null || B4 === void 0 || B4.selectLines(S6, R4);
        }
        _keyDown(S6) {
          if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && this._customKeyEventHandler(S6) === false)
            return false;
          let R4 = this.browser.isMac && this.options.macOptionIsMeta && S6.altKey;
          if (!R4 && !this._compositionHelper.keydown(S6))
            return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
          R4 || S6.key !== "Dead" && S6.key !== "AltGraph" || (this._unprocessedDeadKey = true);
          let B4 = (0, C5.evaluateKeyboardEvent)(S6, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
          if (this.updateCursorStyle(S6), B4.type === 3 || B4.type === 2) {
            let A5 = this.rows - 1;
            return this.scrollLines(B4.type === 2 ? -A5 : A5), this.cancel(S6, true);
          }
          return B4.type === 1 && this.selectAll(), !!this._isThirdLevelShift(this.browser, S6) || (B4.cancel && this.cancel(S6, true), !B4.key || !!(S6.key && !S6.ctrlKey && !S6.altKey && !S6.metaKey && S6.key.length === 1 && S6.key.charCodeAt(0) >= 65 && S6.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (B4.key !== M5.C0.ETX && B4.key !== M5.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: B4.key, domEvent: S6 }), this._showCursor(), this.coreService.triggerDataEvent(B4.key, true), !this.optionsService.rawOptions.screenReaderMode || S6.altKey || S6.ctrlKey ? this.cancel(S6, true) : void (this._keyDownHandled = true))));
        }
        _isThirdLevelShift(S6, R4) {
          let B4 = S6.isMac && !this.options.macOptionIsMeta && R4.altKey && !R4.ctrlKey && !R4.metaKey || S6.isWindows && R4.altKey && R4.ctrlKey && !R4.metaKey || S6.isWindows && R4.getModifierState("AltGraph");
          return R4.type === "keypress" ? B4 : B4 && (!R4.keyCode || R4.keyCode > 47);
        }
        _keyUp(S6) {
          this._keyDownSeen = false, this._customKeyEventHandler && this._customKeyEventHandler(S6) === false || (function(R4) {
            return R4.keyCode === 16 || R4.keyCode === 17 || R4.keyCode === 18;
          }(S6) || this.focus(), this.updateCursorStyle(S6), this._keyPressHandled = false);
        }
        _keyPress(S6) {
          let R4;
          if (this._keyPressHandled = false, this._keyDownHandled || this._customKeyEventHandler && this._customKeyEventHandler(S6) === false)
            return false;
          if (this.cancel(S6), S6.charCode)
            R4 = S6.charCode;
          else if (S6.which === null || S6.which === void 0)
            R4 = S6.keyCode;
          else {
            if (S6.which === 0 || S6.charCode === 0)
              return false;
            R4 = S6.which;
          }
          return !(!R4 || (S6.altKey || S6.ctrlKey || S6.metaKey) && !this._isThirdLevelShift(this.browser, S6) || (R4 = String.fromCharCode(R4), this._onKey.fire({ key: R4, domEvent: S6 }), this._showCursor(), this.coreService.triggerDataEvent(R4, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
        }
        _inputEvent(S6) {
          if (S6.data && S6.inputType === "insertText" && (!S6.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
            if (this._keyPressHandled)
              return false;
            this._unprocessedDeadKey = false;
            let R4 = S6.data;
            return this.coreService.triggerDataEvent(R4, true), this.cancel(S6), true;
          }
          return false;
        }
        resize(S6, R4) {
          S6 !== this.cols || R4 !== this.rows ? super.resize(S6, R4) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
        }
        _afterResize(S6, R4) {
          var B4, A5;
          (B4 = this._charSizeService) === null || B4 === void 0 || B4.measure(), (A5 = this.viewport) === null || A5 === void 0 || A5.syncScrollArea(true);
        }
        clear() {
          var S6;
          if (this.buffer.ybase !== 0 || this.buffer.y !== 0) {
            this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
            for (let R4 = 1; R4 < this.rows; R4++)
              this.buffer.lines.push(this.buffer.getBlankLine(O6.DEFAULT_ATTR_DATA));
            this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), (S6 = this.viewport) === null || S6 === void 0 || S6.reset(), this.refresh(0, this.rows - 1);
          }
        }
        reset() {
          var S6, R4;
          this.options.rows = this.rows, this.options.cols = this.cols;
          let B4 = this._customKeyEventHandler;
          this._setup(), super.reset(), (S6 = this._selectionService) === null || S6 === void 0 || S6.reset(), this._decorationService.reset(), (R4 = this.viewport) === null || R4 === void 0 || R4.reset(), this._customKeyEventHandler = B4, this.refresh(0, this.rows - 1);
        }
        clearTextureAtlas() {
          var S6;
          (S6 = this._renderService) === null || S6 === void 0 || S6.clearTextureAtlas();
        }
        _reportFocus() {
          var S6;
          !((S6 = this.element) === null || S6 === void 0) && S6.classList.contains("focus") ? this.coreService.triggerDataEvent(M5.C0.ESC + "[I") : this.coreService.triggerDataEvent(M5.C0.ESC + "[O");
        }
        _reportWindowsOptions(S6) {
          if (this._renderService)
            switch (S6) {
              case I7.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                let R4 = this._renderService.dimensions.css.canvas.width.toFixed(0), B4 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${M5.C0.ESC}[4;${B4};${R4}t`);
                break;
              case I7.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                let A5 = this._renderService.dimensions.css.cell.width.toFixed(0), N6 = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${M5.C0.ESC}[6;${N6};${A5}t`);
            }
        }
        cancel(S6, R4) {
          if (this.options.cancelEvents || R4)
            return S6.preventDefault(), S6.stopPropagation(), false;
        }
      }
      r.Terminal = W5;
    }, 9924: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.TimeBasedDebouncer = void 0, r.TimeBasedDebouncer = class {
        constructor(a2, l4 = 1e3) {
          this._renderCallback = a2, this._debounceThresholdMS = l4, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
        }
        dispose() {
          this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
        }
        refresh(a2, l4, u3) {
          this._rowCount = u3, a2 = a2 !== void 0 ? a2 : 0, l4 = l4 !== void 0 ? l4 : this._rowCount - 1, this._rowStart = this._rowStart !== void 0 ? Math.min(this._rowStart, a2) : a2, this._rowEnd = this._rowEnd !== void 0 ? Math.max(this._rowEnd, l4) : l4;
          let n3 = Date.now();
          if (n3 - this._lastRefreshMs >= this._debounceThresholdMS)
            this._lastRefreshMs = n3, this._innerRefresh();
          else if (!this._additionalRefreshRequested) {
            let d5 = n3 - this._lastRefreshMs, f4 = this._debounceThresholdMS - d5;
            this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
              this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
            }, f4);
          }
        }
        _innerRefresh() {
          if (this._rowStart === void 0 || this._rowEnd === void 0 || this._rowCount === void 0)
            return;
          let a2 = Math.max(this._rowStart, 0), l4 = Math.min(this._rowEnd, this._rowCount - 1);
          this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(a2, l4);
        }
      };
    }, 1680: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(s2, t, i4, o3) {
        var c3, v5 = arguments.length, m6 = v5 < 3 ? t : o3 === null ? o3 = Object.getOwnPropertyDescriptor(t, i4) : o3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          m6 = Reflect.decorate(s2, t, i4, o3);
        else
          for (var h5 = s2.length - 1; h5 >= 0; h5--)
            (c3 = s2[h5]) && (m6 = (v5 < 3 ? c3(m6) : v5 > 3 ? c3(t, i4, m6) : c3(t, i4)) || m6);
        return v5 > 3 && m6 && Object.defineProperty(t, i4, m6), m6;
      }, u3 = this && this.__param || function(s2, t) {
        return function(i4, o3) {
          t(i4, o3, s2);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.Viewport = void 0;
      let n3 = a2(3656), d5 = a2(4725), f4 = a2(8460), p6 = a2(844), _5 = a2(2585), e = r.Viewport = class extends p6.Disposable {
        constructor(s2, t, i4, o3, c3, v5, m6, h5) {
          super(), this._viewportElement = s2, this._scrollArea = t, this._bufferService = i4, this._optionsService = o3, this._charSizeService = c3, this._renderService = v5, this._coreBrowserService = m6, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new f4.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n3.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((g4) => this._activeBuffer = g4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((g4) => this._renderDimensions = g4)), this._handleThemeChange(h5.colors), this.register(h5.onChangeColors((g4) => this._handleThemeChange(g4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
        }
        _handleThemeChange(s2) {
          this._viewportElement.style.backgroundColor = s2.background.css;
        }
        reset() {
          this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
        }
        _refresh(s2) {
          if (s2)
            return this._innerRefresh(), void (this._refreshAnimationFrame !== null && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
          this._refreshAnimationFrame === null && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
        }
        _innerRefresh() {
          if (this._charSizeService.height > 0) {
            this._currentRowHeight = this._renderService.dimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderService.dimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
            let t = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.css.canvas.height);
            this._lastRecordedBufferHeight !== t && (this._lastRecordedBufferHeight = t, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
          }
          let s2 = this._bufferService.buffer.ydisp * this._currentRowHeight;
          this._viewportElement.scrollTop !== s2 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = s2), this._refreshAnimationFrame = null;
        }
        syncScrollArea(s2 = false) {
          if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length)
            return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(s2);
          this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(s2);
        }
        _handleScroll(s2) {
          if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent)
            return;
          if (this._ignoreNextScrollEvent)
            return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
          let t = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
          this._onRequestScrollLines.fire({ amount: t, suppressScrollEvent: true });
        }
        _smoothScroll() {
          if (this._isDisposed || this._smoothScrollState.origin === -1 || this._smoothScrollState.target === -1)
            return;
          let s2 = this._smoothScrollPercent();
          this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(s2 * (this._smoothScrollState.target - this._smoothScrollState.origin)), s2 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
        }
        _smoothScrollPercent() {
          return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
        }
        _clearSmoothScrollState() {
          this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
        }
        _bubbleScroll(s2, t) {
          let i4 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
          return !(t < 0 && this._viewportElement.scrollTop !== 0 || t > 0 && i4 < this._lastRecordedBufferHeight) || (s2.cancelable && s2.preventDefault(), false);
        }
        handleWheel(s2) {
          let t = this._getPixelsScrolled(s2);
          return t !== 0 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target === -1 ? this._smoothScrollState.target = this._viewportElement.scrollTop + t : this._smoothScrollState.target += t, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t, this._bubbleScroll(s2, t));
        }
        scrollLines(s2) {
          if (s2 !== 0)
            if (this._optionsService.rawOptions.smoothScrollDuration) {
              let t = s2 * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else
              this._onRequestScrollLines.fire({ amount: s2, suppressScrollEvent: false });
        }
        _getPixelsScrolled(s2) {
          if (s2.deltaY === 0 || s2.shiftKey)
            return 0;
          let t = this._applyScrollModifier(s2.deltaY, s2);
          return s2.deltaMode === WheelEvent.DOM_DELTA_LINE ? t *= this._currentRowHeight : s2.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._currentRowHeight * this._bufferService.rows), t;
        }
        getBufferElements(s2, t) {
          var i4;
          let o3, c3 = "", v5 = [], m6 = t ?? this._bufferService.buffer.lines.length, h5 = this._bufferService.buffer.lines;
          for (let g4 = s2; g4 < m6; g4++) {
            let b5 = h5.get(g4);
            if (!b5)
              continue;
            let L5 = (i4 = h5.get(g4 + 1)) === null || i4 === void 0 ? void 0 : i4.isWrapped;
            if (c3 += b5.translateToString(!L5), !L5 || g4 === h5.length - 1) {
              let y5 = document.createElement("div");
              y5.textContent = c3, v5.push(y5), c3.length > 0 && (o3 = y5), c3 = "";
            }
          }
          return { bufferElements: v5, cursorElement: o3 };
        }
        getLinesScrolled(s2) {
          if (s2.deltaY === 0 || s2.shiftKey)
            return 0;
          let t = this._applyScrollModifier(s2.deltaY, s2);
          return s2.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t /= this._currentRowHeight + 0, this._wheelPartialScroll += t, t = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : s2.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._bufferService.rows), t;
        }
        _applyScrollModifier(s2, t) {
          let i4 = this._optionsService.rawOptions.fastScrollModifier;
          return i4 === "alt" && t.altKey || i4 === "ctrl" && t.ctrlKey || i4 === "shift" && t.shiftKey ? s2 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : s2 * this._optionsService.rawOptions.scrollSensitivity;
        }
        handleTouchStart(s2) {
          this._lastTouchY = s2.touches[0].pageY;
        }
        handleTouchMove(s2) {
          let t = this._lastTouchY - s2.touches[0].pageY;
          return this._lastTouchY = s2.touches[0].pageY, t !== 0 && (this._viewportElement.scrollTop += t, this._bubbleScroll(s2, t));
        }
      };
      r.Viewport = e = l4([u3(2, _5.IBufferService), u3(3, _5.IOptionsService), u3(4, d5.ICharSizeService), u3(5, d5.IRenderService), u3(6, d5.ICoreBrowserService), u3(7, d5.IThemeService)], e);
    }, 3107: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(e, s2, t, i4) {
        var o3, c3 = arguments.length, v5 = c3 < 3 ? s2 : i4 === null ? i4 = Object.getOwnPropertyDescriptor(s2, t) : i4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          v5 = Reflect.decorate(e, s2, t, i4);
        else
          for (var m6 = e.length - 1; m6 >= 0; m6--)
            (o3 = e[m6]) && (v5 = (c3 < 3 ? o3(v5) : c3 > 3 ? o3(s2, t, v5) : o3(s2, t)) || v5);
        return c3 > 3 && v5 && Object.defineProperty(s2, t, v5), v5;
      }, u3 = this && this.__param || function(e, s2) {
        return function(t, i4) {
          s2(t, i4, e);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferDecorationRenderer = void 0;
      let n3 = a2(3656), d5 = a2(4725), f4 = a2(844), p6 = a2(2585), _5 = r.BufferDecorationRenderer = class extends f4.Disposable {
        constructor(e, s2, t, i4) {
          super(), this._screenElement = e, this._bufferService = s2, this._decorationService = t, this._renderService = i4, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
            this._dimensionsChanged = true, this._queueRefresh();
          })), this.register((0, n3.addDisposableDomListener)(window, "resize", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
          })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((o3) => this._removeDecoration(o3))), this.register((0, f4.toDisposable)(() => {
            this._container.remove(), this._decorationElements.clear();
          }));
        }
        _queueRefresh() {
          this._animationFrame === void 0 && (this._animationFrame = this._renderService.addRefreshCallback(() => {
            this._doRefreshDecorations(), this._animationFrame = void 0;
          }));
        }
        _doRefreshDecorations() {
          for (let e of this._decorationService.decorations)
            this._renderDecoration(e);
          this._dimensionsChanged = false;
        }
        _renderDecoration(e) {
          this._refreshStyle(e), this._dimensionsChanged && this._refreshXPosition(e);
        }
        _createElement(e) {
          var s2, t;
          let i4 = document.createElement("div");
          i4.classList.add("xterm-decoration"), i4.classList.toggle("xterm-decoration-top-layer", ((s2 = e?.options) === null || s2 === void 0 ? void 0 : s2.layer) === "top"), i4.style.width = `${Math.round((e.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, i4.style.height = (e.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", i4.style.top = (e.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", i4.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
          let o3 = (t = e.options.x) !== null && t !== void 0 ? t : 0;
          return o3 && o3 > this._bufferService.cols && (i4.style.display = "none"), this._refreshXPosition(e, i4), i4;
        }
        _refreshStyle(e) {
          let s2 = e.marker.line - this._bufferService.buffers.active.ydisp;
          if (s2 < 0 || s2 >= this._bufferService.rows)
            e.element && (e.element.style.display = "none", e.onRenderEmitter.fire(e.element));
          else {
            let t = this._decorationElements.get(e);
            t || (t = this._createElement(e), e.element = t, this._decorationElements.set(e, t), this._container.appendChild(t), e.onDispose(() => {
              this._decorationElements.delete(e), t.remove();
            })), t.style.top = s2 * this._renderService.dimensions.css.cell.height + "px", t.style.display = this._altBufferIsActive ? "none" : "block", e.onRenderEmitter.fire(t);
          }
        }
        _refreshXPosition(e, s2 = e.element) {
          var t;
          if (!s2)
            return;
          let i4 = (t = e.options.x) !== null && t !== void 0 ? t : 0;
          (e.options.anchor || "left") === "right" ? s2.style.right = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "" : s2.style.left = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "";
        }
        _removeDecoration(e) {
          var s2;
          (s2 = this._decorationElements.get(e)) === null || s2 === void 0 || s2.remove(), this._decorationElements.delete(e), e.dispose();
        }
      };
      r.BufferDecorationRenderer = _5 = l4([u3(1, p6.IBufferService), u3(2, p6.IDecorationService), u3(3, d5.IRenderService)], _5);
    }, 5871: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.ColorZoneStore = void 0, r.ColorZoneStore = class {
        constructor() {
          this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
        }
        get zones() {
          return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
        }
        clear() {
          this._zones.length = 0, this._zonePoolIndex = 0;
        }
        addDecoration(a2) {
          if (a2.options.overviewRulerOptions) {
            for (let l4 of this._zones)
              if (l4.color === a2.options.overviewRulerOptions.color && l4.position === a2.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(l4, a2.marker.line))
                  return;
                if (this._lineAdjacentToZone(l4, a2.marker.line, a2.options.overviewRulerOptions.position))
                  return void this._addLineToZone(l4, a2.marker.line);
              }
            if (this._zonePoolIndex < this._zonePool.length)
              return this._zonePool[this._zonePoolIndex].color = a2.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = a2.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = a2.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = a2.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
            this._zones.push({ color: a2.options.overviewRulerOptions.color, position: a2.options.overviewRulerOptions.position, startBufferLine: a2.marker.line, endBufferLine: a2.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
          }
        }
        setPadding(a2) {
          this._linePadding = a2;
        }
        _lineIntersectsZone(a2, l4) {
          return l4 >= a2.startBufferLine && l4 <= a2.endBufferLine;
        }
        _lineAdjacentToZone(a2, l4, u3) {
          return l4 >= a2.startBufferLine - this._linePadding[u3 || "full"] && l4 <= a2.endBufferLine + this._linePadding[u3 || "full"];
        }
        _addLineToZone(a2, l4) {
          a2.startBufferLine = Math.min(a2.startBufferLine, l4), a2.endBufferLine = Math.max(a2.endBufferLine, l4);
        }
      };
    }, 5744: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(o3, c3, v5, m6) {
        var h5, g4 = arguments.length, b5 = g4 < 3 ? c3 : m6 === null ? m6 = Object.getOwnPropertyDescriptor(c3, v5) : m6;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          b5 = Reflect.decorate(o3, c3, v5, m6);
        else
          for (var L5 = o3.length - 1; L5 >= 0; L5--)
            (h5 = o3[L5]) && (b5 = (g4 < 3 ? h5(b5) : g4 > 3 ? h5(c3, v5, b5) : h5(c3, v5)) || b5);
        return g4 > 3 && b5 && Object.defineProperty(c3, v5, b5), b5;
      }, u3 = this && this.__param || function(o3, c3) {
        return function(v5, m6) {
          c3(v5, m6, o3);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.OverviewRulerRenderer = void 0;
      let n3 = a2(5871), d5 = a2(3656), f4 = a2(4725), p6 = a2(844), _5 = a2(2585), e = { full: 0, left: 0, center: 0, right: 0 }, s2 = { full: 0, left: 0, center: 0, right: 0 }, t = { full: 0, left: 0, center: 0, right: 0 }, i4 = r.OverviewRulerRenderer = class extends p6.Disposable {
        get _width() {
          return this._optionsService.options.overviewRulerWidth || 0;
        }
        constructor(o3, c3, v5, m6, h5, g4, b5) {
          var L5;
          super(), this._viewportElement = o3, this._screenElement = c3, this._bufferService = v5, this._decorationService = m6, this._renderService = h5, this._optionsService = g4, this._coreBrowseService = b5, this._colorZoneStore = new n3.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = document.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (L5 = this._viewportElement.parentElement) === null || L5 === void 0 || L5.insertBefore(this._canvas, this._viewportElement);
          let y5 = this._canvas.getContext("2d");
          if (!y5)
            throw new Error("Ctx cannot be null");
          this._ctx = y5, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, p6.toDisposable)(() => {
            var k4;
            (k4 = this._canvas) === null || k4 === void 0 || k4.remove();
          }));
        }
        _registerDecorationListeners() {
          this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
        }
        _registerBufferChangeListeners() {
          this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
            this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
          })), this.register(this._bufferService.onScroll(() => {
            this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
          }));
        }
        _registerDimensionChangeListeners() {
          this.register(this._renderService.onRender(() => {
            this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
          })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register((0, d5.addDisposableDomListener)(this._coreBrowseService.window, "resize", () => this._queueRefresh(true))), this._queueRefresh(true);
        }
        _refreshDrawConstants() {
          let o3 = Math.floor(this._canvas.width / 3), c3 = Math.ceil(this._canvas.width / 3);
          s2.full = this._canvas.width, s2.left = o3, s2.center = c3, s2.right = o3, this._refreshDrawHeightConstants(), t.full = 0, t.left = 0, t.center = s2.left, t.right = s2.left + s2.center;
        }
        _refreshDrawHeightConstants() {
          e.full = Math.round(2 * this._coreBrowseService.dpr);
          let o3 = this._canvas.height / this._bufferService.buffer.lines.length, c3 = Math.round(Math.max(Math.min(o3, 12), 6) * this._coreBrowseService.dpr);
          e.left = c3, e.center = c3, e.right = c3;
        }
        _refreshColorZonePadding() {
          this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * e.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
        }
        _refreshCanvasDimensions() {
          this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
        }
        _refreshDecorations() {
          this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
          for (let c3 of this._decorationService.decorations)
            this._colorZoneStore.addDecoration(c3);
          this._ctx.lineWidth = 1;
          let o3 = this._colorZoneStore.zones;
          for (let c3 of o3)
            c3.position !== "full" && this._renderColorZone(c3);
          for (let c3 of o3)
            c3.position === "full" && this._renderColorZone(c3);
          this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
        }
        _renderColorZone(o3) {
          this._ctx.fillStyle = o3.color, this._ctx.fillRect(t[o3.position || "full"], Math.round((this._canvas.height - 1) * (o3.startBufferLine / this._bufferService.buffers.active.lines.length) - e[o3.position || "full"] / 2), s2[o3.position || "full"], Math.round((this._canvas.height - 1) * ((o3.endBufferLine - o3.startBufferLine) / this._bufferService.buffers.active.lines.length) + e[o3.position || "full"]));
        }
        _queueRefresh(o3, c3) {
          this._shouldUpdateDimensions = o3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = c3 || this._shouldUpdateAnchor, this._animationFrame === void 0 && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {
            this._refreshDecorations(), this._animationFrame = void 0;
          }));
        }
      };
      r.OverviewRulerRenderer = i4 = l4([u3(2, _5.IBufferService), u3(3, _5.IDecorationService), u3(4, f4.IRenderService), u3(5, _5.IOptionsService), u3(6, f4.ICoreBrowserService)], i4);
    }, 2950: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(_5, e, s2, t) {
        var i4, o3 = arguments.length, c3 = o3 < 3 ? e : t === null ? t = Object.getOwnPropertyDescriptor(e, s2) : t;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          c3 = Reflect.decorate(_5, e, s2, t);
        else
          for (var v5 = _5.length - 1; v5 >= 0; v5--)
            (i4 = _5[v5]) && (c3 = (o3 < 3 ? i4(c3) : o3 > 3 ? i4(e, s2, c3) : i4(e, s2)) || c3);
        return o3 > 3 && c3 && Object.defineProperty(e, s2, c3), c3;
      }, u3 = this && this.__param || function(_5, e) {
        return function(s2, t) {
          e(s2, t, _5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.CompositionHelper = void 0;
      let n3 = a2(4725), d5 = a2(2585), f4 = a2(2584), p6 = r.CompositionHelper = class {
        get isComposing() {
          return this._isComposing;
        }
        constructor(_5, e, s2, t, i4, o3) {
          this._textarea = _5, this._compositionView = e, this._bufferService = s2, this._optionsService = t, this._coreService = i4, this._renderService = o3, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
        }
        compositionstart() {
          this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
        }
        compositionupdate(_5) {
          this._compositionView.textContent = _5.data, this.updateCompositionElements(), setTimeout(() => {
            this._compositionPosition.end = this._textarea.value.length;
          }, 0);
        }
        compositionend() {
          this._finalizeComposition(true);
        }
        keydown(_5) {
          if (this._isComposing || this._isSendingComposition) {
            if (_5.keyCode === 229 || _5.keyCode === 16 || _5.keyCode === 17 || _5.keyCode === 18)
              return false;
            this._finalizeComposition(false);
          }
          return _5.keyCode !== 229 || (this._handleAnyTextareaChanges(), false);
        }
        _finalizeComposition(_5) {
          if (this._compositionView.classList.remove("active"), this._isComposing = false, _5) {
            let e = { start: this._compositionPosition.start, end: this._compositionPosition.end };
            this._isSendingComposition = true, setTimeout(() => {
              if (this._isSendingComposition) {
                let s2;
                this._isSendingComposition = false, e.start += this._dataAlreadySent.length, s2 = this._isComposing ? this._textarea.value.substring(e.start, e.end) : this._textarea.value.substring(e.start), s2.length > 0 && this._coreService.triggerDataEvent(s2, true);
              }
            }, 0);
          } else {
            this._isSendingComposition = false;
            let e = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
            this._coreService.triggerDataEvent(e, true);
          }
        }
        _handleAnyTextareaChanges() {
          let _5 = this._textarea.value;
          setTimeout(() => {
            if (!this._isComposing) {
              let e = this._textarea.value, s2 = e.replace(_5, "");
              this._dataAlreadySent = s2, e.length > _5.length ? this._coreService.triggerDataEvent(s2, true) : e.length < _5.length ? this._coreService.triggerDataEvent(`${f4.C0.DEL}`, true) : e.length === _5.length && e !== _5 && this._coreService.triggerDataEvent(e, true);
            }
          }, 0);
        }
        updateCompositionElements(_5) {
          if (this._isComposing) {
            if (this._bufferService.buffer.isCursorInViewport) {
              let e = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), s2 = this._renderService.dimensions.css.cell.height, t = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, i4 = e * this._renderService.dimensions.css.cell.width;
              this._compositionView.style.left = i4 + "px", this._compositionView.style.top = t + "px", this._compositionView.style.height = s2 + "px", this._compositionView.style.lineHeight = s2 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
              let o3 = this._compositionView.getBoundingClientRect();
              this._textarea.style.left = i4 + "px", this._textarea.style.top = t + "px", this._textarea.style.width = Math.max(o3.width, 1) + "px", this._textarea.style.height = Math.max(o3.height, 1) + "px", this._textarea.style.lineHeight = o3.height + "px";
            }
            _5 || setTimeout(() => this.updateCompositionElements(true), 0);
          }
        }
      };
      r.CompositionHelper = p6 = l4([u3(2, d5.IBufferService), u3(3, d5.IOptionsService), u3(4, d5.ICoreService), u3(5, n3.IRenderService)], p6);
    }, 9806: (P7, r) => {
      function a2(l4, u3, n3) {
        let d5 = n3.getBoundingClientRect(), f4 = l4.getComputedStyle(n3), p6 = parseInt(f4.getPropertyValue("padding-left")), _5 = parseInt(f4.getPropertyValue("padding-top"));
        return [u3.clientX - d5.left - p6, u3.clientY - d5.top - _5];
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.getCoords = r.getCoordsRelativeToElement = void 0, r.getCoordsRelativeToElement = a2, r.getCoords = function(l4, u3, n3, d5, f4, p6, _5, e, s2) {
        if (!p6)
          return;
        let t = a2(l4, u3, n3);
        return t ? (t[0] = Math.ceil((t[0] + (s2 ? _5 / 2 : 0)) / _5), t[1] = Math.ceil(t[1] / e), t[0] = Math.min(Math.max(t[0], 1), d5 + (s2 ? 1 : 0)), t[1] = Math.min(Math.max(t[1], 1), f4), t) : void 0;
      };
    }, 9504: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.moveToCellSequence = void 0;
      let l4 = a2(2584);
      function u3(e, s2, t, i4) {
        let o3 = e - n3(e, t), c3 = s2 - n3(s2, t), v5 = Math.abs(o3 - c3) - function(m6, h5, g4) {
          let b5 = 0, L5 = m6 - n3(m6, g4), y5 = h5 - n3(h5, g4);
          for (let k4 = 0; k4 < Math.abs(L5 - y5); k4++) {
            let x5 = d5(m6, h5) === "A" ? -1 : 1, T6 = g4.buffer.lines.get(L5 + x5 * k4);
            T6?.isWrapped && b5++;
          }
          return b5;
        }(e, s2, t);
        return _5(v5, p6(d5(e, s2), i4));
      }
      function n3(e, s2) {
        let t = 0, i4 = s2.buffer.lines.get(e), o3 = i4?.isWrapped;
        for (; o3 && e >= 0 && e < s2.rows; )
          t++, i4 = s2.buffer.lines.get(--e), o3 = i4?.isWrapped;
        return t;
      }
      function d5(e, s2) {
        return e > s2 ? "A" : "B";
      }
      function f4(e, s2, t, i4, o3, c3) {
        let v5 = e, m6 = s2, h5 = "";
        for (; v5 !== t || m6 !== i4; )
          v5 += o3 ? 1 : -1, o3 && v5 > c3.cols - 1 ? (h5 += c3.buffer.translateBufferLineToString(m6, false, e, v5), v5 = 0, e = 0, m6++) : !o3 && v5 < 0 && (h5 += c3.buffer.translateBufferLineToString(m6, false, 0, e + 1), v5 = c3.cols - 1, e = v5, m6--);
        return h5 + c3.buffer.translateBufferLineToString(m6, false, e, v5);
      }
      function p6(e, s2) {
        let t = s2 ? "O" : "[";
        return l4.C0.ESC + t + e;
      }
      function _5(e, s2) {
        e = Math.floor(e);
        let t = "";
        for (let i4 = 0; i4 < e; i4++)
          t += s2;
        return t;
      }
      r.moveToCellSequence = function(e, s2, t, i4) {
        let o3 = t.buffer.x, c3 = t.buffer.y;
        if (!t.buffer.hasScrollback)
          return function(h5, g4, b5, L5, y5, k4) {
            return u3(g4, L5, y5, k4).length === 0 ? "" : _5(f4(h5, g4, h5, g4 - n3(g4, y5), false, y5).length, p6("D", k4));
          }(o3, c3, 0, s2, t, i4) + u3(c3, s2, t, i4) + function(h5, g4, b5, L5, y5, k4) {
            let x5;
            x5 = u3(g4, L5, y5, k4).length > 0 ? L5 - n3(L5, y5) : g4;
            let T6 = L5, O6 = function(M5, C5, w4, E5, D5, I7) {
              let H4;
              return H4 = u3(w4, E5, D5, I7).length > 0 ? E5 - n3(E5, D5) : C5, M5 < w4 && H4 <= E5 || M5 >= w4 && H4 < E5 ? "C" : "D";
            }(h5, g4, b5, L5, y5, k4);
            return _5(f4(h5, x5, b5, T6, O6 === "C", y5).length, p6(O6, k4));
          }(o3, c3, e, s2, t, i4);
        let v5;
        if (c3 === s2)
          return v5 = o3 > e ? "D" : "C", _5(Math.abs(o3 - e), p6(v5, i4));
        v5 = c3 > s2 ? "D" : "C";
        let m6 = Math.abs(c3 - s2);
        return _5(function(h5, g4) {
          return g4.cols - h5;
        }(c3 > s2 ? e : o3, t) + (m6 - 1) * t.cols + 1 + ((c3 > s2 ? o3 : e) - 1), p6(v5, i4));
      };
    }, 1296: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(y5, k4, x5, T6) {
        var O6, M5 = arguments.length, C5 = M5 < 3 ? k4 : T6 === null ? T6 = Object.getOwnPropertyDescriptor(k4, x5) : T6;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          C5 = Reflect.decorate(y5, k4, x5, T6);
        else
          for (var w4 = y5.length - 1; w4 >= 0; w4--)
            (O6 = y5[w4]) && (C5 = (M5 < 3 ? O6(C5) : M5 > 3 ? O6(k4, x5, C5) : O6(k4, x5)) || C5);
        return M5 > 3 && C5 && Object.defineProperty(k4, x5, C5), C5;
      }, u3 = this && this.__param || function(y5, k4) {
        return function(x5, T6) {
          k4(x5, T6, y5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.DomRenderer = void 0;
      let n3 = a2(3787), d5 = a2(2550), f4 = a2(2223), p6 = a2(6171), _5 = a2(4725), e = a2(8055), s2 = a2(8460), t = a2(844), i4 = a2(2585), o3 = "xterm-dom-renderer-owner-", c3 = "xterm-rows", v5 = "xterm-fg-", m6 = "xterm-bg-", h5 = "xterm-focus", g4 = "xterm-selection", b5 = 1, L5 = r.DomRenderer = class extends t.Disposable {
        constructor(y5, k4, x5, T6, O6, M5, C5, w4, E5, D5) {
          super(), this._element = y5, this._screenElement = k4, this._viewportElement = x5, this._linkifier2 = T6, this._charSizeService = M5, this._optionsService = C5, this._bufferService = w4, this._coreBrowserService = E5, this._themeService = D5, this._terminalClass = b5++, this._rowElements = [], this.onRequestRedraw = this.register(new s2.EventEmitter()).event, this._rowContainer = document.createElement("div"), this._rowContainer.classList.add(c3), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement("div"), this._selectionContainer.classList.add(g4), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, p6.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((I7) => this._injectCss(I7))), this._injectCss(this._themeService.colors), this._rowFactory = O6.createInstance(n3.DomRendererRowFactory, document), this._element.classList.add(o3 + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((I7) => this._handleLinkHover(I7))), this.register(this._linkifier2.onHideLinkUnderline((I7) => this._handleLinkLeave(I7))), this.register((0, t.toDisposable)(() => {
            this._element.classList.remove(o3 + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
          })), this._widthCache = new d5.WidthCache(document), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        _updateDimensions() {
          let y5 = this._coreBrowserService.dpr;
          this.dimensions.device.char.width = this._charSizeService.width * y5, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * y5), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / y5), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / y5), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
          for (let x5 of this._rowElements)
            x5.style.width = `${this.dimensions.css.canvas.width}px`, x5.style.height = `${this.dimensions.css.cell.height}px`, x5.style.lineHeight = `${this.dimensions.css.cell.height}px`, x5.style.overflow = "hidden";
          this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
          let k4 = `${this._terminalSelector} .${c3} span { display: inline-block; height: 100%; vertical-align: top;}`;
          this._dimensionsStyleElement.textContent = k4, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
        }
        _injectCss(y5) {
          this._themeStyleElement || (this._themeStyleElement = document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
          let k4 = `${this._terminalSelector} .${c3} { color: ${y5.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
          k4 += `${this._terminalSelector} .${c3} .xterm-dim { color: ${e.color.multiplyOpacity(y5.foreground, 0.5).css};}`, k4 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`, k4 += "@keyframes blink_box_shadow_" + this._terminalClass + " { 50% {  border-bottom-style: hidden; }}", k4 += "@keyframes blink_block_" + this._terminalClass + ` { 0% {  background-color: ${y5.cursor.css};  color: ${y5.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${y5.cursor.css}; }}`, k4 += `${this._terminalSelector} .${c3}.${h5} .xterm-cursor.xterm-cursor-blink:not(.xterm-cursor-block) { animation: blink_box_shadow_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${c3}.${h5} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: blink_block_` + this._terminalClass + ` 1s step-end infinite;}${this._terminalSelector} .${c3} .xterm-cursor.xterm-cursor-block { background-color: ${y5.cursor.css}; color: ${y5.cursorAccent.css};}${this._terminalSelector} .${c3} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${y5.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${c3} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${y5.cursor.css} inset;}${this._terminalSelector} .${c3} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${y5.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, k4 += `${this._terminalSelector} .${g4} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${g4} div { position: absolute; background-color: ${y5.selectionBackgroundOpaque.css};}${this._terminalSelector} .${g4} div { position: absolute; background-color: ${y5.selectionInactiveBackgroundOpaque.css};}`;
          for (let [x5, T6] of y5.ansi.entries())
            k4 += `${this._terminalSelector} .${v5}${x5} { color: ${T6.css}; }${this._terminalSelector} .${v5}${x5}.xterm-dim { color: ${e.color.multiplyOpacity(T6, 0.5).css}; }${this._terminalSelector} .${m6}${x5} { background-color: ${T6.css}; }`;
          k4 += `${this._terminalSelector} .${v5}${f4.INVERTED_DEFAULT_COLOR} { color: ${e.color.opaque(y5.background).css}; }${this._terminalSelector} .${v5}${f4.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${e.color.multiplyOpacity(e.color.opaque(y5.background), 0.5).css}; }${this._terminalSelector} .${m6}${f4.INVERTED_DEFAULT_COLOR} { background-color: ${y5.foreground.css}; }`, this._themeStyleElement.textContent = k4;
        }
        _setDefaultSpacing() {
          let y5 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
          this._rowContainer.style.letterSpacing = `${y5}px`, this._rowFactory.defaultSpacing = y5;
        }
        handleDevicePixelRatioChange() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        _refreshRowElements(y5, k4) {
          for (let x5 = this._rowElements.length; x5 <= k4; x5++) {
            let T6 = document.createElement("div");
            this._rowContainer.appendChild(T6), this._rowElements.push(T6);
          }
          for (; this._rowElements.length > k4; )
            this._rowContainer.removeChild(this._rowElements.pop());
        }
        handleResize(y5, k4) {
          this._refreshRowElements(y5, k4), this._updateDimensions();
        }
        handleCharSizeChanged() {
          this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
        }
        handleBlur() {
          this._rowContainer.classList.remove(h5);
        }
        handleFocus() {
          this._rowContainer.classList.add(h5), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
        }
        handleSelectionChanged(y5, k4, x5) {
          if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(y5, k4, x5), this.renderRows(0, this._bufferService.rows - 1), !y5 || !k4)
            return;
          let T6 = y5[1] - this._bufferService.buffer.ydisp, O6 = k4[1] - this._bufferService.buffer.ydisp, M5 = Math.max(T6, 0), C5 = Math.min(O6, this._bufferService.rows - 1);
          if (M5 >= this._bufferService.rows || C5 < 0)
            return;
          let w4 = document.createDocumentFragment();
          if (x5) {
            let E5 = y5[0] > k4[0];
            w4.appendChild(this._createSelectionElement(M5, E5 ? k4[0] : y5[0], E5 ? y5[0] : k4[0], C5 - M5 + 1));
          } else {
            let E5 = T6 === M5 ? y5[0] : 0, D5 = M5 === O6 ? k4[0] : this._bufferService.cols;
            w4.appendChild(this._createSelectionElement(M5, E5, D5));
            let I7 = C5 - M5 - 1;
            if (w4.appendChild(this._createSelectionElement(M5 + 1, 0, this._bufferService.cols, I7)), M5 !== C5) {
              let H4 = O6 === C5 ? k4[0] : this._bufferService.cols;
              w4.appendChild(this._createSelectionElement(C5, 0, H4));
            }
          }
          this._selectionContainer.appendChild(w4);
        }
        _createSelectionElement(y5, k4, x5, T6 = 1) {
          let O6 = document.createElement("div");
          return O6.style.height = T6 * this.dimensions.css.cell.height + "px", O6.style.top = y5 * this.dimensions.css.cell.height + "px", O6.style.left = k4 * this.dimensions.css.cell.width + "px", O6.style.width = this.dimensions.css.cell.width * (x5 - k4) + "px", O6;
        }
        handleCursorMove() {
        }
        _handleOptionsChanged() {
          this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
        }
        clear() {
          for (let y5 of this._rowElements)
            y5.replaceChildren();
        }
        renderRows(y5, k4) {
          let x5 = this._bufferService.buffer, T6 = x5.ybase + x5.y, O6 = Math.min(x5.x, this._bufferService.cols - 1), M5 = this._optionsService.rawOptions.cursorBlink, C5 = this._optionsService.rawOptions.cursorStyle, w4 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let E5 = y5; E5 <= k4; E5++) {
            let D5 = E5 + x5.ydisp, I7 = this._rowElements[E5], H4 = x5.lines.get(D5);
            if (!I7 || !H4)
              break;
            I7.replaceChildren(...this._rowFactory.createRow(H4, D5, D5 === T6, C5, w4, O6, M5, this.dimensions.css.cell.width, this._widthCache, -1, -1));
          }
        }
        get _terminalSelector() {
          return `.${o3}${this._terminalClass}`;
        }
        _handleLinkHover(y5) {
          this._setCellUnderline(y5.x1, y5.x2, y5.y1, y5.y2, y5.cols, true);
        }
        _handleLinkLeave(y5) {
          this._setCellUnderline(y5.x1, y5.x2, y5.y1, y5.y2, y5.cols, false);
        }
        _setCellUnderline(y5, k4, x5, T6, O6, M5) {
          x5 < 0 && (y5 = 0), T6 < 0 && (k4 = 0);
          let C5 = this._bufferService.rows - 1;
          x5 = Math.max(Math.min(x5, C5), 0), T6 = Math.max(Math.min(T6, C5), 0), O6 = Math.min(O6, this._bufferService.cols);
          let w4 = this._bufferService.buffer, E5 = w4.ybase + w4.y, D5 = Math.min(w4.x, O6 - 1), I7 = this._optionsService.rawOptions.cursorBlink, H4 = this._optionsService.rawOptions.cursorStyle, U4 = this._optionsService.rawOptions.cursorInactiveStyle;
          for (let W5 = x5; W5 <= T6; ++W5) {
            let q6 = W5 + w4.ydisp, S6 = this._rowElements[W5], R4 = w4.lines.get(q6);
            if (!S6 || !R4)
              break;
            S6.replaceChildren(...this._rowFactory.createRow(R4, q6, q6 === E5, H4, U4, D5, I7, this.dimensions.css.cell.width, this._widthCache, M5 ? W5 === x5 ? y5 : 0 : -1, M5 ? (W5 === T6 ? k4 : O6) - 1 : -1));
          }
        }
      };
      r.DomRenderer = L5 = l4([u3(4, i4.IInstantiationService), u3(5, _5.ICharSizeService), u3(6, i4.IOptionsService), u3(7, i4.IBufferService), u3(8, _5.ICoreBrowserService), u3(9, _5.IThemeService)], L5);
    }, 3787: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(v5, m6, h5, g4) {
        var b5, L5 = arguments.length, y5 = L5 < 3 ? m6 : g4 === null ? g4 = Object.getOwnPropertyDescriptor(m6, h5) : g4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          y5 = Reflect.decorate(v5, m6, h5, g4);
        else
          for (var k4 = v5.length - 1; k4 >= 0; k4--)
            (b5 = v5[k4]) && (y5 = (L5 < 3 ? b5(y5) : L5 > 3 ? b5(m6, h5, y5) : b5(m6, h5)) || y5);
        return L5 > 3 && y5 && Object.defineProperty(m6, h5, y5), y5;
      }, u3 = this && this.__param || function(v5, m6) {
        return function(h5, g4) {
          m6(h5, g4, v5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.DomRendererRowFactory = void 0;
      let n3 = a2(2223), d5 = a2(643), f4 = a2(511), p6 = a2(2585), _5 = a2(8055), e = a2(4725), s2 = a2(4269), t = a2(6171), i4 = a2(3734), o3 = r.DomRendererRowFactory = class {
        constructor(v5, m6, h5, g4, b5, L5, y5) {
          this._document = v5, this._characterJoinerService = m6, this._optionsService = h5, this._coreBrowserService = g4, this._coreService = b5, this._decorationService = L5, this._themeService = y5, this._workCell = new f4.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
        }
        handleSelectionChanged(v5, m6, h5) {
          this._selectionStart = v5, this._selectionEnd = m6, this._columnSelectMode = h5;
        }
        createRow(v5, m6, h5, g4, b5, L5, y5, k4, x5, T6, O6) {
          let M5 = [], C5 = this._characterJoinerService.getJoinedCharacters(m6), w4 = this._themeService.colors, E5, D5 = v5.getNoBgTrimmedLength();
          h5 && D5 < L5 + 1 && (D5 = L5 + 1);
          let I7 = 0, H4 = "", U4 = 0, W5 = 0, q6 = 0, S6 = false, R4 = 0, B4 = false, A5 = 0, N6 = [], F7 = T6 !== -1 && O6 !== -1;
          for (let j7 = 0; j7 < D5; j7++) {
            v5.loadCell(j7, this._workCell);
            let X5 = this._workCell.getWidth();
            if (X5 === 0)
              continue;
            let J5 = false, re2 = j7, $5 = this._workCell;
            if (C5.length > 0 && j7 === C5[0][0]) {
              J5 = true;
              let V6 = C5.shift();
              $5 = new s2.JoinedCellData(this._workCell, v5.translateToString(true, V6[0], V6[1]), V6[1] - V6[0]), re2 = V6[1] - 1, X5 = $5.getWidth();
            }
            let ne3 = this._isCellInSelection(j7, m6), de2 = h5 && j7 === L5, _e2 = F7 && j7 >= T6 && j7 <= O6, ue2 = false;
            this._decorationService.forEachDecorationAtCell(j7, m6, void 0, (V6) => {
              ue2 = true;
            });
            let ce2 = $5.getChars() || d5.WHITESPACE_CELL_CHAR;
            if (ce2 === " " && ($5.isUnderline() || $5.isOverline()) && (ce2 = "\xA0"), A5 = X5 * k4 - x5.get(ce2, $5.isBold(), $5.isItalic()), E5) {
              if (I7 && (ne3 && B4 || !ne3 && !B4 && $5.bg === U4) && (ne3 && B4 && w4.selectionForeground || $5.fg === W5) && $5.extended.ext === q6 && _e2 === S6 && A5 === R4 && !de2 && !J5 && !ue2) {
                H4 += ce2, I7++;
                continue;
              }
              I7 && (E5.textContent = H4), E5 = this._document.createElement("span"), I7 = 0, H4 = "";
            } else
              E5 = this._document.createElement("span");
            if (U4 = $5.bg, W5 = $5.fg, q6 = $5.extended.ext, S6 = _e2, R4 = A5, B4 = ne3, J5 && L5 >= j7 && L5 <= re2 && (L5 = j7), !this._coreService.isCursorHidden && de2) {
              if (N6.push("xterm-cursor"), this._coreBrowserService.isFocused)
                y5 && N6.push("xterm-cursor-blink"), N6.push(g4 === "bar" ? "xterm-cursor-bar" : g4 === "underline" ? "xterm-cursor-underline" : "xterm-cursor-block");
              else if (b5)
                switch (b5) {
                  case "outline":
                    N6.push("xterm-cursor-outline");
                    break;
                  case "block":
                    N6.push("xterm-cursor-block");
                    break;
                  case "bar":
                    N6.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    N6.push("xterm-cursor-underline");
                }
            }
            if ($5.isBold() && N6.push("xterm-bold"), $5.isItalic() && N6.push("xterm-italic"), $5.isDim() && N6.push("xterm-dim"), H4 = $5.isInvisible() ? d5.WHITESPACE_CELL_CHAR : $5.getChars() || d5.WHITESPACE_CELL_CHAR, $5.isUnderline() && (N6.push(`xterm-underline-${$5.extended.underlineStyle}`), H4 === " " && (H4 = "\xA0"), !$5.isUnderlineColorDefault()))
              if ($5.isUnderlineColorRGB())
                E5.style.textDecorationColor = `rgb(${i4.AttributeData.toColorRGB($5.getUnderlineColor()).join(",")})`;
              else {
                let V6 = $5.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && $5.isBold() && V6 < 8 && (V6 += 8), E5.style.textDecorationColor = w4.ansi[V6].css;
              }
            $5.isOverline() && (N6.push("xterm-overline"), H4 === " " && (H4 = "\xA0")), $5.isStrikethrough() && N6.push("xterm-strikethrough"), _e2 && (E5.style.textDecoration = "underline");
            let Y5 = $5.getFgColor(), oe2 = $5.getFgColorMode(), Z5 = $5.getBgColor(), ae2 = $5.getBgColorMode(), fe2 = !!$5.isInverse();
            if (fe2) {
              let V6 = Y5;
              Y5 = Z5, Z5 = V6;
              let Ee3 = oe2;
              oe2 = ae2, ae2 = Ee3;
            }
            let ee3, ve2, te3, he2 = false;
            switch (this._decorationService.forEachDecorationAtCell(j7, m6, void 0, (V6) => {
              V6.options.layer !== "top" && he2 || (V6.backgroundColorRGB && (ae2 = 50331648, Z5 = V6.backgroundColorRGB.rgba >> 8 & 16777215, ee3 = V6.backgroundColorRGB), V6.foregroundColorRGB && (oe2 = 50331648, Y5 = V6.foregroundColorRGB.rgba >> 8 & 16777215, ve2 = V6.foregroundColorRGB), he2 = V6.options.layer === "top");
            }), !he2 && ne3 && (ee3 = this._coreBrowserService.isFocused ? w4.selectionBackgroundOpaque : w4.selectionInactiveBackgroundOpaque, Z5 = ee3.rgba >> 8 & 16777215, ae2 = 50331648, he2 = true, w4.selectionForeground && (oe2 = 50331648, Y5 = w4.selectionForeground.rgba >> 8 & 16777215, ve2 = w4.selectionForeground)), he2 && N6.push("xterm-decoration-top"), ae2) {
              case 16777216:
              case 33554432:
                te3 = w4.ansi[Z5], N6.push(`xterm-bg-${Z5}`);
                break;
              case 50331648:
                te3 = _5.rgba.toColor(Z5 >> 16, Z5 >> 8 & 255, 255 & Z5), this._addStyle(E5, `background-color:#${c3((Z5 >>> 0).toString(16), "0", 6)}`);
                break;
              default:
                fe2 ? (te3 = w4.foreground, N6.push(`xterm-bg-${n3.INVERTED_DEFAULT_COLOR}`)) : te3 = w4.background;
            }
            switch (ee3 || $5.isDim() && (ee3 = _5.color.multiplyOpacity(te3, 0.5)), oe2) {
              case 16777216:
              case 33554432:
                $5.isBold() && Y5 < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (Y5 += 8), this._applyMinimumContrast(E5, te3, w4.ansi[Y5], $5, ee3, void 0) || N6.push(`xterm-fg-${Y5}`);
                break;
              case 50331648:
                let V6 = _5.rgba.toColor(Y5 >> 16 & 255, Y5 >> 8 & 255, 255 & Y5);
                this._applyMinimumContrast(E5, te3, V6, $5, ee3, ve2) || this._addStyle(E5, `color:#${c3(Y5.toString(16), "0", 6)}`);
                break;
              default:
                this._applyMinimumContrast(E5, te3, w4.foreground, $5, ee3, void 0) || fe2 && N6.push(`xterm-fg-${n3.INVERTED_DEFAULT_COLOR}`);
            }
            N6.length && (E5.className = N6.join(" "), N6.length = 0), de2 || J5 || ue2 ? E5.textContent = H4 : I7++, A5 !== this.defaultSpacing && (E5.style.letterSpacing = `${A5}px`), M5.push(E5), j7 = re2;
          }
          return E5 && I7 && (E5.textContent = H4), M5;
        }
        _applyMinimumContrast(v5, m6, h5, g4, b5, L5) {
          if (this._optionsService.rawOptions.minimumContrastRatio === 1 || (0, t.excludeFromContrastRatioDemands)(g4.getCode()))
            return false;
          let y5 = this._getContrastCache(g4), k4;
          if (b5 || L5 || (k4 = y5.getColor(m6.rgba, h5.rgba)), k4 === void 0) {
            let x5 = this._optionsService.rawOptions.minimumContrastRatio / (g4.isDim() ? 2 : 1);
            k4 = _5.color.ensureContrastRatio(b5 || m6, L5 || h5, x5), y5.setColor((b5 || m6).rgba, (L5 || h5).rgba, k4 ?? null);
          }
          return !!k4 && (this._addStyle(v5, `color:${k4.css}`), true);
        }
        _getContrastCache(v5) {
          return v5.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
        }
        _addStyle(v5, m6) {
          v5.setAttribute("style", `${v5.getAttribute("style") || ""}${m6};`);
        }
        _isCellInSelection(v5, m6) {
          let h5 = this._selectionStart, g4 = this._selectionEnd;
          return !(!h5 || !g4) && (this._columnSelectMode ? h5[0] <= g4[0] ? v5 >= h5[0] && m6 >= h5[1] && v5 < g4[0] && m6 <= g4[1] : v5 < h5[0] && m6 >= h5[1] && v5 >= g4[0] && m6 <= g4[1] : m6 > h5[1] && m6 < g4[1] || h5[1] === g4[1] && m6 === h5[1] && v5 >= h5[0] && v5 < g4[0] || h5[1] < g4[1] && m6 === g4[1] && v5 < g4[0] || h5[1] < g4[1] && m6 === h5[1] && v5 >= h5[0]);
        }
      };
      function c3(v5, m6, h5) {
        for (; v5.length < h5; )
          v5 = m6 + v5;
        return v5;
      }
      r.DomRendererRowFactory = o3 = l4([u3(1, e.ICharacterJoinerService), u3(2, p6.IOptionsService), u3(3, e.ICoreBrowserService), u3(4, p6.ICoreService), u3(5, p6.IDecorationService), u3(6, e.IThemeService)], o3);
    }, 2550: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.WidthCache = void 0, r.WidthCache = class {
        constructor(a2) {
          this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = a2.createElement("div"), this._container.style.position = "absolute", this._container.style.top = "-50000px", this._container.style.width = "50000px", this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
          let l4 = a2.createElement("span"), u3 = a2.createElement("span");
          u3.style.fontWeight = "bold";
          let n3 = a2.createElement("span");
          n3.style.fontStyle = "italic";
          let d5 = a2.createElement("span");
          d5.style.fontWeight = "bold", d5.style.fontStyle = "italic", this._measureElements = [l4, u3, n3, d5], this._container.appendChild(l4), this._container.appendChild(u3), this._container.appendChild(n3), this._container.appendChild(d5), a2.body.appendChild(this._container), this.clear();
        }
        dispose() {
          this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
        }
        clear() {
          this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
        }
        setFont(a2, l4, u3, n3) {
          a2 === this._font && l4 === this._fontSize && u3 === this._weight && n3 === this._weightBold || (this._font = a2, this._fontSize = l4, this._weight = u3, this._weightBold = n3, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${u3}`, this._measureElements[1].style.fontWeight = `${n3}`, this._measureElements[2].style.fontWeight = `${u3}`, this._measureElements[3].style.fontWeight = `${n3}`, this.clear());
        }
        get(a2, l4, u3) {
          let n3 = 0;
          if (!l4 && !u3 && a2.length === 1 && (n3 = a2.charCodeAt(0)) < 256)
            return this._flat[n3] !== -9999 ? this._flat[n3] : this._flat[n3] = this._measure(a2, 0);
          let d5 = a2;
          l4 && (d5 += "B"), u3 && (d5 += "I");
          let f4 = this._holey.get(d5);
          if (f4 === void 0) {
            let p6 = 0;
            l4 && (p6 |= 1), u3 && (p6 |= 2), f4 = this._measure(a2, p6), this._holey.set(d5, f4);
          }
          return f4;
        }
        _measure(a2, l4) {
          let u3 = this._measureElements[l4];
          return u3.textContent = a2.repeat(32), u3.offsetWidth / 32;
        }
      };
    }, 2223: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.TEXT_BASELINE = r.DIM_OPACITY = r.INVERTED_DEFAULT_COLOR = void 0;
      let l4 = a2(6114);
      r.INVERTED_DEFAULT_COLOR = 257, r.DIM_OPACITY = 0.5, r.TEXT_BASELINE = l4.isFirefox || l4.isLegacyEdge ? "bottom" : "ideographic";
    }, 6171: (P7, r) => {
      function a2(l4) {
        return 57508 <= l4 && l4 <= 57558;
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.createRenderDimensions = r.excludeFromContrastRatioDemands = r.isRestrictedPowerlineGlyph = r.isPowerlineGlyph = r.throwIfFalsy = void 0, r.throwIfFalsy = function(l4) {
        if (!l4)
          throw new Error("value must not be falsy");
        return l4;
      }, r.isPowerlineGlyph = a2, r.isRestrictedPowerlineGlyph = function(l4) {
        return 57520 <= l4 && l4 <= 57527;
      }, r.excludeFromContrastRatioDemands = function(l4) {
        return a2(l4) || function(u3) {
          return 9472 <= u3 && u3 <= 9631;
        }(l4);
      }, r.createRenderDimensions = function() {
        return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
      };
    }, 456: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.SelectionModel = void 0, r.SelectionModel = class {
        constructor(a2) {
          this._bufferService = a2, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        clearSelection() {
          this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
        }
        get finalSelectionStart() {
          return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
        }
        get finalSelectionEnd() {
          if (this.isSelectAllActive)
            return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
          if (this.selectionStart) {
            if (!this.selectionEnd || this.areSelectionValuesReversed()) {
              let a2 = this.selectionStart[0] + this.selectionStartLength;
              return a2 > this._bufferService.cols ? a2 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(a2 / this._bufferService.cols) - 1] : [a2 % this._bufferService.cols, this.selectionStart[1] + Math.floor(a2 / this._bufferService.cols)] : [a2, this.selectionStart[1]];
            }
            if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
              let a2 = this.selectionStart[0] + this.selectionStartLength;
              return a2 > this._bufferService.cols ? [a2 % this._bufferService.cols, this.selectionStart[1] + Math.floor(a2 / this._bufferService.cols)] : [Math.max(a2, this.selectionEnd[0]), this.selectionEnd[1]];
            }
            return this.selectionEnd;
          }
        }
        areSelectionValuesReversed() {
          let a2 = this.selectionStart, l4 = this.selectionEnd;
          return !(!a2 || !l4) && (a2[1] > l4[1] || a2[1] === l4[1] && a2[0] > l4[0]);
        }
        handleTrim(a2) {
          return this.selectionStart && (this.selectionStart[1] -= a2), this.selectionEnd && (this.selectionEnd[1] -= a2), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
        }
      };
    }, 428: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(e, s2, t, i4) {
        var o3, c3 = arguments.length, v5 = c3 < 3 ? s2 : i4 === null ? i4 = Object.getOwnPropertyDescriptor(s2, t) : i4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          v5 = Reflect.decorate(e, s2, t, i4);
        else
          for (var m6 = e.length - 1; m6 >= 0; m6--)
            (o3 = e[m6]) && (v5 = (c3 < 3 ? o3(v5) : c3 > 3 ? o3(s2, t, v5) : o3(s2, t)) || v5);
        return c3 > 3 && v5 && Object.defineProperty(s2, t, v5), v5;
      }, u3 = this && this.__param || function(e, s2) {
        return function(t, i4) {
          s2(t, i4, e);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.CharSizeService = void 0;
      let n3 = a2(2585), d5 = a2(8460), f4 = a2(844), p6 = r.CharSizeService = class extends f4.Disposable {
        get hasValidSize() {
          return this.width > 0 && this.height > 0;
        }
        constructor(e, s2, t) {
          super(), this._optionsService = t, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new d5.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event, this._measureStrategy = new _5(e, s2, this._optionsService), this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], () => this.measure()));
        }
        measure() {
          let e = this._measureStrategy.measure();
          e.width === this.width && e.height === this.height || (this.width = e.width, this.height = e.height, this._onCharSizeChange.fire());
        }
      };
      r.CharSizeService = p6 = l4([u3(2, n3.IOptionsService)], p6);
      class _5 {
        constructor(s2, t, i4) {
          this._document = s2, this._parentElement = t, this._optionsService = i4, this._result = { width: 0, height: 0 }, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
        }
        measure() {
          this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;
          let s2 = { height: Number(this._measureElement.offsetHeight), width: Number(this._measureElement.offsetWidth) };
          return s2.width !== 0 && s2.height !== 0 && (this._result.width = s2.width / 32, this._result.height = Math.ceil(s2.height)), this._result;
        }
      }
    }, 4269: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(s2, t, i4, o3) {
        var c3, v5 = arguments.length, m6 = v5 < 3 ? t : o3 === null ? o3 = Object.getOwnPropertyDescriptor(t, i4) : o3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          m6 = Reflect.decorate(s2, t, i4, o3);
        else
          for (var h5 = s2.length - 1; h5 >= 0; h5--)
            (c3 = s2[h5]) && (m6 = (v5 < 3 ? c3(m6) : v5 > 3 ? c3(t, i4, m6) : c3(t, i4)) || m6);
        return v5 > 3 && m6 && Object.defineProperty(t, i4, m6), m6;
      }, u3 = this && this.__param || function(s2, t) {
        return function(i4, o3) {
          t(i4, o3, s2);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.CharacterJoinerService = r.JoinedCellData = void 0;
      let n3 = a2(3734), d5 = a2(643), f4 = a2(511), p6 = a2(2585);
      class _5 extends n3.AttributeData {
        constructor(t, i4, o3) {
          super(), this.content = 0, this.combinedData = "", this.fg = t.fg, this.bg = t.bg, this.combinedData = i4, this._width = o3;
        }
        isCombined() {
          return 2097152;
        }
        getWidth() {
          return this._width;
        }
        getChars() {
          return this.combinedData;
        }
        getCode() {
          return 2097151;
        }
        setFromCharData(t) {
          throw new Error("not implemented");
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      r.JoinedCellData = _5;
      let e = r.CharacterJoinerService = class be2 {
        constructor(t) {
          this._bufferService = t, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new f4.CellData();
        }
        register(t) {
          let i4 = { id: this._nextCharacterJoinerId++, handler: t };
          return this._characterJoiners.push(i4), i4.id;
        }
        deregister(t) {
          for (let i4 = 0; i4 < this._characterJoiners.length; i4++)
            if (this._characterJoiners[i4].id === t)
              return this._characterJoiners.splice(i4, 1), true;
          return false;
        }
        getJoinedCharacters(t) {
          if (this._characterJoiners.length === 0)
            return [];
          let i4 = this._bufferService.buffer.lines.get(t);
          if (!i4 || i4.length === 0)
            return [];
          let o3 = [], c3 = i4.translateToString(true), v5 = 0, m6 = 0, h5 = 0, g4 = i4.getFg(0), b5 = i4.getBg(0);
          for (let L5 = 0; L5 < i4.getTrimmedLength(); L5++)
            if (i4.loadCell(L5, this._workCell), this._workCell.getWidth() !== 0) {
              if (this._workCell.fg !== g4 || this._workCell.bg !== b5) {
                if (L5 - v5 > 1) {
                  let y5 = this._getJoinedRanges(c3, h5, m6, i4, v5);
                  for (let k4 = 0; k4 < y5.length; k4++)
                    o3.push(y5[k4]);
                }
                v5 = L5, h5 = m6, g4 = this._workCell.fg, b5 = this._workCell.bg;
              }
              m6 += this._workCell.getChars().length || d5.WHITESPACE_CELL_CHAR.length;
            }
          if (this._bufferService.cols - v5 > 1) {
            let L5 = this._getJoinedRanges(c3, h5, m6, i4, v5);
            for (let y5 = 0; y5 < L5.length; y5++)
              o3.push(L5[y5]);
          }
          return o3;
        }
        _getJoinedRanges(t, i4, o3, c3, v5) {
          let m6 = t.substring(i4, o3), h5 = [];
          try {
            h5 = this._characterJoiners[0].handler(m6);
          } catch (g4) {
            console.error(g4);
          }
          for (let g4 = 1; g4 < this._characterJoiners.length; g4++)
            try {
              let b5 = this._characterJoiners[g4].handler(m6);
              for (let L5 = 0; L5 < b5.length; L5++)
                be2._mergeRanges(h5, b5[L5]);
            } catch (b5) {
              console.error(b5);
            }
          return this._stringRangesToCellRanges(h5, c3, v5), h5;
        }
        _stringRangesToCellRanges(t, i4, o3) {
          let c3 = 0, v5 = false, m6 = 0, h5 = t[c3];
          if (h5) {
            for (let g4 = o3; g4 < this._bufferService.cols; g4++) {
              let b5 = i4.getWidth(g4), L5 = i4.getString(g4).length || d5.WHITESPACE_CELL_CHAR.length;
              if (b5 !== 0) {
                if (!v5 && h5[0] <= m6 && (h5[0] = g4, v5 = true), h5[1] <= m6) {
                  if (h5[1] = g4, h5 = t[++c3], !h5)
                    break;
                  h5[0] <= m6 ? (h5[0] = g4, v5 = true) : v5 = false;
                }
                m6 += L5;
              }
            }
            h5 && (h5[1] = this._bufferService.cols);
          }
        }
        static _mergeRanges(t, i4) {
          let o3 = false;
          for (let c3 = 0; c3 < t.length; c3++) {
            let v5 = t[c3];
            if (o3) {
              if (i4[1] <= v5[0])
                return t[c3 - 1][1] = i4[1], t;
              if (i4[1] <= v5[1])
                return t[c3 - 1][1] = Math.max(i4[1], v5[1]), t.splice(c3, 1), t;
              t.splice(c3, 1), c3--;
            } else {
              if (i4[1] <= v5[0])
                return t.splice(c3, 0, i4), t;
              if (i4[1] <= v5[1])
                return v5[0] = Math.min(i4[0], v5[0]), t;
              i4[0] < v5[1] && (v5[0] = Math.min(i4[0], v5[0]), o3 = true);
            }
          }
          return o3 ? t[t.length - 1][1] = i4[1] : t.push(i4), t;
        }
      };
      r.CharacterJoinerService = e = l4([u3(0, p6.IBufferService)], e);
    }, 5114: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.CoreBrowserService = void 0, r.CoreBrowserService = class {
        constructor(a2, l4) {
          this._textarea = a2, this.window = l4, this._isFocused = false, this._cachedIsFocused = void 0, this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
        }
        get dpr() {
          return this.window.devicePixelRatio;
        }
        get isFocused() {
          return this._cachedIsFocused === void 0 && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
        }
      };
    }, 8934: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(p6, _5, e, s2) {
        var t, i4 = arguments.length, o3 = i4 < 3 ? _5 : s2 === null ? s2 = Object.getOwnPropertyDescriptor(_5, e) : s2;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o3 = Reflect.decorate(p6, _5, e, s2);
        else
          for (var c3 = p6.length - 1; c3 >= 0; c3--)
            (t = p6[c3]) && (o3 = (i4 < 3 ? t(o3) : i4 > 3 ? t(_5, e, o3) : t(_5, e)) || o3);
        return i4 > 3 && o3 && Object.defineProperty(_5, e, o3), o3;
      }, u3 = this && this.__param || function(p6, _5) {
        return function(e, s2) {
          _5(e, s2, p6);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.MouseService = void 0;
      let n3 = a2(4725), d5 = a2(9806), f4 = r.MouseService = class {
        constructor(p6, _5) {
          this._renderService = p6, this._charSizeService = _5;
        }
        getCoords(p6, _5, e, s2, t) {
          return (0, d5.getCoords)(window, p6, _5, e, s2, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, t);
        }
        getMouseReportCoords(p6, _5) {
          let e = (0, d5.getCoordsRelativeToElement)(window, p6, _5);
          if (this._charSizeService.hasValidSize)
            return e[0] = Math.min(Math.max(e[0], 0), this._renderService.dimensions.css.canvas.width - 1), e[1] = Math.min(Math.max(e[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(e[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(e[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(e[0]), y: Math.floor(e[1]) };
        }
      };
      r.MouseService = f4 = l4([u3(0, n3.IRenderService), u3(1, n3.ICharSizeService)], f4);
    }, 3230: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(o3, c3, v5, m6) {
        var h5, g4 = arguments.length, b5 = g4 < 3 ? c3 : m6 === null ? m6 = Object.getOwnPropertyDescriptor(c3, v5) : m6;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          b5 = Reflect.decorate(o3, c3, v5, m6);
        else
          for (var L5 = o3.length - 1; L5 >= 0; L5--)
            (h5 = o3[L5]) && (b5 = (g4 < 3 ? h5(b5) : g4 > 3 ? h5(c3, v5, b5) : h5(c3, v5)) || b5);
        return g4 > 3 && b5 && Object.defineProperty(c3, v5, b5), b5;
      }, u3 = this && this.__param || function(o3, c3) {
        return function(v5, m6) {
          c3(v5, m6, o3);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.RenderService = void 0;
      let n3 = a2(3656), d5 = a2(6193), f4 = a2(5596), p6 = a2(4725), _5 = a2(8460), e = a2(844), s2 = a2(7226), t = a2(2585), i4 = r.RenderService = class extends e.Disposable {
        get dimensions() {
          return this._renderer.value.dimensions;
        }
        constructor(o3, c3, v5, m6, h5, g4, b5, L5) {
          if (super(), this._rowCount = o3, this._charSizeService = m6, this._renderer = this.register(new e.MutableDisposable()), this._pausedResizeTask = new s2.DebouncedIdleTask(), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new _5.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new _5.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new _5.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new _5.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new d5.RenderDebouncer(b5.window, (y5, k4) => this._renderRows(y5, k4)), this.register(this._renderDebouncer), this._screenDprMonitor = new f4.ScreenDprMonitor(b5.window), this._screenDprMonitor.setListener(() => this.handleDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(g4.onResize(() => this._fullRefresh())), this.register(g4.buffers.onBufferActivate(() => {
            var y5;
            return (y5 = this._renderer.value) === null || y5 === void 0 ? void 0 : y5.clear();
          })), this.register(v5.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(h5.onDecorationRegistered(() => this._fullRefresh())), this.register(h5.onDecorationRemoved(() => this._fullRefresh())), this.register(v5.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio"], () => {
            this.clear(), this.handleResize(g4.cols, g4.rows), this._fullRefresh();
          })), this.register(v5.onMultipleOptionChange(["cursorBlink", "cursorStyle"], () => this.refreshRows(g4.buffer.y, g4.buffer.y, true))), this.register((0, n3.addDisposableDomListener)(b5.window, "resize", () => this.handleDevicePixelRatioChange())), this.register(L5.onChangeColors(() => this._fullRefresh())), "IntersectionObserver" in b5.window) {
            let y5 = new b5.window.IntersectionObserver((k4) => this._handleIntersectionChange(k4[k4.length - 1]), { threshold: 0 });
            y5.observe(c3), this.register({ dispose: () => y5.disconnect() });
          }
        }
        _handleIntersectionChange(o3) {
          this._isPaused = o3.isIntersecting === void 0 ? o3.intersectionRatio === 0 : !o3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
        }
        refreshRows(o3, c3, v5 = false) {
          this._isPaused ? this._needsFullRefresh = true : (v5 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(o3, c3, this._rowCount));
        }
        _renderRows(o3, c3) {
          this._renderer.value && (o3 = Math.min(o3, this._rowCount - 1), c3 = Math.min(c3, this._rowCount - 1), this._renderer.value.renderRows(o3, c3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: o3, end: c3 }), this._onRender.fire({ start: o3, end: c3 }), this._isNextRenderRedrawOnly = true);
        }
        resize(o3, c3) {
          this._rowCount = c3, this._fireOnCanvasResize();
        }
        _handleOptionsChanged() {
          this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
        }
        _fireOnCanvasResize() {
          this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
        }
        hasRenderer() {
          return !!this._renderer.value;
        }
        setRenderer(o3) {
          this._renderer.value = o3, this._renderer.value.onRequestRedraw((c3) => this.refreshRows(c3.start, c3.end, true)), this._needsSelectionRefresh = true, this._fullRefresh();
        }
        addRefreshCallback(o3) {
          return this._renderDebouncer.addRefreshCallback(o3);
        }
        _fullRefresh() {
          this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
        }
        clearTextureAtlas() {
          var o3, c3;
          this._renderer.value && ((c3 = (o3 = this._renderer.value).clearTextureAtlas) === null || c3 === void 0 || c3.call(o3), this._fullRefresh());
        }
        handleDevicePixelRatioChange() {
          this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
        }
        handleResize(o3, c3) {
          this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => this._renderer.value.handleResize(o3, c3)) : this._renderer.value.handleResize(o3, c3), this._fullRefresh());
        }
        handleCharSizeChanged() {
          var o3;
          (o3 = this._renderer.value) === null || o3 === void 0 || o3.handleCharSizeChanged();
        }
        handleBlur() {
          var o3;
          (o3 = this._renderer.value) === null || o3 === void 0 || o3.handleBlur();
        }
        handleFocus() {
          var o3;
          (o3 = this._renderer.value) === null || o3 === void 0 || o3.handleFocus();
        }
        handleSelectionChanged(o3, c3, v5) {
          var m6;
          this._selectionState.start = o3, this._selectionState.end = c3, this._selectionState.columnSelectMode = v5, (m6 = this._renderer.value) === null || m6 === void 0 || m6.handleSelectionChanged(o3, c3, v5);
        }
        handleCursorMove() {
          var o3;
          (o3 = this._renderer.value) === null || o3 === void 0 || o3.handleCursorMove();
        }
        clear() {
          var o3;
          (o3 = this._renderer.value) === null || o3 === void 0 || o3.clear();
        }
      };
      r.RenderService = i4 = l4([u3(2, t.IOptionsService), u3(3, p6.ICharSizeService), u3(4, t.IDecorationService), u3(5, t.IBufferService), u3(6, p6.ICoreBrowserService), u3(7, p6.IThemeService)], i4);
    }, 9312: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(h5, g4, b5, L5) {
        var y5, k4 = arguments.length, x5 = k4 < 3 ? g4 : L5 === null ? L5 = Object.getOwnPropertyDescriptor(g4, b5) : L5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          x5 = Reflect.decorate(h5, g4, b5, L5);
        else
          for (var T6 = h5.length - 1; T6 >= 0; T6--)
            (y5 = h5[T6]) && (x5 = (k4 < 3 ? y5(x5) : k4 > 3 ? y5(g4, b5, x5) : y5(g4, b5)) || x5);
        return k4 > 3 && x5 && Object.defineProperty(g4, b5, x5), x5;
      }, u3 = this && this.__param || function(h5, g4) {
        return function(b5, L5) {
          g4(b5, L5, h5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.SelectionService = void 0;
      let n3 = a2(9806), d5 = a2(9504), f4 = a2(456), p6 = a2(4725), _5 = a2(8460), e = a2(844), s2 = a2(6114), t = a2(4841), i4 = a2(511), o3 = a2(2585), c3 = "\xA0", v5 = new RegExp(c3, "g"), m6 = r.SelectionService = class extends e.Disposable {
        constructor(h5, g4, b5, L5, y5, k4, x5, T6, O6) {
          super(), this._element = h5, this._screenElement = g4, this._linkifier = b5, this._bufferService = L5, this._coreService = y5, this._mouseService = k4, this._optionsService = x5, this._renderService = T6, this._coreBrowserService = O6, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new i4.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new _5.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new _5.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new _5.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new _5.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (M5) => this._handleMouseMove(M5), this._mouseUpListener = (M5) => this._handleMouseUp(M5), this._coreService.onUserInput(() => {
            this.hasSelection && this.clearSelection();
          }), this._trimListener = this._bufferService.buffer.lines.onTrim((M5) => this._handleTrim(M5)), this.register(this._bufferService.buffers.onBufferActivate((M5) => this._handleBufferActivate(M5))), this.enable(), this._model = new f4.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, e.toDisposable)(() => {
            this._removeMouseDownListeners();
          }));
        }
        reset() {
          this.clearSelection();
        }
        disable() {
          this.clearSelection(), this._enabled = false;
        }
        enable() {
          this._enabled = true;
        }
        get selectionStart() {
          return this._model.finalSelectionStart;
        }
        get selectionEnd() {
          return this._model.finalSelectionEnd;
        }
        get hasSelection() {
          let h5 = this._model.finalSelectionStart, g4 = this._model.finalSelectionEnd;
          return !(!h5 || !g4 || h5[0] === g4[0] && h5[1] === g4[1]);
        }
        get selectionText() {
          let h5 = this._model.finalSelectionStart, g4 = this._model.finalSelectionEnd;
          if (!h5 || !g4)
            return "";
          let b5 = this._bufferService.buffer, L5 = [];
          if (this._activeSelectionMode === 3) {
            if (h5[0] === g4[0])
              return "";
            let y5 = h5[0] < g4[0] ? h5[0] : g4[0], k4 = h5[0] < g4[0] ? g4[0] : h5[0];
            for (let x5 = h5[1]; x5 <= g4[1]; x5++) {
              let T6 = b5.translateBufferLineToString(x5, true, y5, k4);
              L5.push(T6);
            }
          } else {
            let y5 = h5[1] === g4[1] ? g4[0] : void 0;
            L5.push(b5.translateBufferLineToString(h5[1], true, h5[0], y5));
            for (let k4 = h5[1] + 1; k4 <= g4[1] - 1; k4++) {
              let x5 = b5.lines.get(k4), T6 = b5.translateBufferLineToString(k4, true);
              x5?.isWrapped ? L5[L5.length - 1] += T6 : L5.push(T6);
            }
            if (h5[1] !== g4[1]) {
              let k4 = b5.lines.get(g4[1]), x5 = b5.translateBufferLineToString(g4[1], true, 0, g4[0]);
              k4 && k4.isWrapped ? L5[L5.length - 1] += x5 : L5.push(x5);
            }
          }
          return L5.map((y5) => y5.replace(v5, " ")).join(s2.isWindows ? `\r
` : `
`);
        }
        clearSelection() {
          this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
        }
        refresh(h5) {
          this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), s2.isLinux && h5 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
        }
        _refresh() {
          this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: this._activeSelectionMode === 3 });
        }
        _isClickInSelection(h5) {
          let g4 = this._getMouseBufferCoords(h5), b5 = this._model.finalSelectionStart, L5 = this._model.finalSelectionEnd;
          return !!(b5 && L5 && g4) && this._areCoordsInSelection(g4, b5, L5);
        }
        isCellInSelection(h5, g4) {
          let b5 = this._model.finalSelectionStart, L5 = this._model.finalSelectionEnd;
          return !(!b5 || !L5) && this._areCoordsInSelection([h5, g4], b5, L5);
        }
        _areCoordsInSelection(h5, g4, b5) {
          return h5[1] > g4[1] && h5[1] < b5[1] || g4[1] === b5[1] && h5[1] === g4[1] && h5[0] >= g4[0] && h5[0] < b5[0] || g4[1] < b5[1] && h5[1] === b5[1] && h5[0] < b5[0] || g4[1] < b5[1] && h5[1] === g4[1] && h5[0] >= g4[0];
        }
        _selectWordAtCursor(h5, g4) {
          var b5, L5;
          let y5 = (L5 = (b5 = this._linkifier.currentLink) === null || b5 === void 0 ? void 0 : b5.link) === null || L5 === void 0 ? void 0 : L5.range;
          if (y5)
            return this._model.selectionStart = [y5.start.x - 1, y5.start.y - 1], this._model.selectionStartLength = (0, t.getRangeLength)(y5, this._bufferService.cols), this._model.selectionEnd = void 0, true;
          let k4 = this._getMouseBufferCoords(h5);
          return !!k4 && (this._selectWordAt(k4, g4), this._model.selectionEnd = void 0, true);
        }
        selectAll() {
          this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
        }
        selectLines(h5, g4) {
          this._model.clearSelection(), h5 = Math.max(h5, 0), g4 = Math.min(g4, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, h5], this._model.selectionEnd = [this._bufferService.cols, g4], this.refresh(), this._onSelectionChange.fire();
        }
        _handleTrim(h5) {
          this._model.handleTrim(h5) && this.refresh();
        }
        _getMouseBufferCoords(h5) {
          let g4 = this._mouseService.getCoords(h5, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
          if (g4)
            return g4[0]--, g4[1]--, g4[1] += this._bufferService.buffer.ydisp, g4;
        }
        _getMouseEventScrollAmount(h5) {
          let g4 = (0, n3.getCoordsRelativeToElement)(this._coreBrowserService.window, h5, this._screenElement)[1], b5 = this._renderService.dimensions.css.canvas.height;
          return g4 >= 0 && g4 <= b5 ? 0 : (g4 > b5 && (g4 -= b5), g4 = Math.min(Math.max(g4, -50), 50), g4 /= 50, g4 / Math.abs(g4) + Math.round(14 * g4));
        }
        shouldForceSelection(h5) {
          return s2.isMac ? h5.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : h5.shiftKey;
        }
        handleMouseDown(h5) {
          if (this._mouseDownTimeStamp = h5.timeStamp, (h5.button !== 2 || !this.hasSelection) && h5.button === 0) {
            if (!this._enabled) {
              if (!this.shouldForceSelection(h5))
                return;
              h5.stopPropagation();
            }
            h5.preventDefault(), this._dragScrollAmount = 0, this._enabled && h5.shiftKey ? this._handleIncrementalClick(h5) : h5.detail === 1 ? this._handleSingleClick(h5) : h5.detail === 2 ? this._handleDoubleClick(h5) : h5.detail === 3 && this._handleTripleClick(h5), this._addMouseDownListeners(), this.refresh(true);
          }
        }
        _addMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
        }
        _removeMouseDownListeners() {
          this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
        }
        _handleIncrementalClick(h5) {
          this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(h5));
        }
        _handleSingleClick(h5) {
          if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(h5) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(h5), !this._model.selectionStart)
            return;
          this._model.selectionEnd = void 0;
          let g4 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
          g4 && g4.length !== this._model.selectionStart[0] && g4.hasWidth(this._model.selectionStart[0]) === 0 && this._model.selectionStart[0]++;
        }
        _handleDoubleClick(h5) {
          this._selectWordAtCursor(h5, true) && (this._activeSelectionMode = 1);
        }
        _handleTripleClick(h5) {
          let g4 = this._getMouseBufferCoords(h5);
          g4 && (this._activeSelectionMode = 2, this._selectLineAt(g4[1]));
        }
        shouldColumnSelect(h5) {
          return h5.altKey && !(s2.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
        }
        _handleMouseMove(h5) {
          if (h5.stopImmediatePropagation(), !this._model.selectionStart)
            return;
          let g4 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
          if (this._model.selectionEnd = this._getMouseBufferCoords(h5), !this._model.selectionEnd)
            return void this.refresh(true);
          this._activeSelectionMode === 2 ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : this._activeSelectionMode === 1 && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(h5), this._activeSelectionMode !== 3 && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
          let b5 = this._bufferService.buffer;
          if (this._model.selectionEnd[1] < b5.lines.length) {
            let L5 = b5.lines.get(this._model.selectionEnd[1]);
            L5 && L5.hasWidth(this._model.selectionEnd[0]) === 0 && this._model.selectionEnd[0]++;
          }
          g4 && g4[0] === this._model.selectionEnd[0] && g4[1] === this._model.selectionEnd[1] || this.refresh(true);
        }
        _dragScroll() {
          if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
            this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
            let h5 = this._bufferService.buffer;
            this._dragScrollAmount > 0 ? (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(h5.ydisp + this._bufferService.rows, h5.lines.length - 1)) : (this._activeSelectionMode !== 3 && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = h5.ydisp), this.refresh();
          }
        }
        _handleMouseUp(h5) {
          let g4 = h5.timeStamp - this._mouseDownTimeStamp;
          if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && g4 < 500 && h5.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
            if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
              let b5 = this._mouseService.getCoords(h5, this._element, this._bufferService.cols, this._bufferService.rows, false);
              if (b5 && b5[0] !== void 0 && b5[1] !== void 0) {
                let L5 = (0, d5.moveToCellSequence)(b5[0] - 1, b5[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                this._coreService.triggerDataEvent(L5, true);
              }
            }
          } else
            this._fireEventIfSelectionChanged();
        }
        _fireEventIfSelectionChanged() {
          let h5 = this._model.finalSelectionStart, g4 = this._model.finalSelectionEnd, b5 = !(!h5 || !g4 || h5[0] === g4[0] && h5[1] === g4[1]);
          b5 ? h5 && g4 && (this._oldSelectionStart && this._oldSelectionEnd && h5[0] === this._oldSelectionStart[0] && h5[1] === this._oldSelectionStart[1] && g4[0] === this._oldSelectionEnd[0] && g4[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(h5, g4, b5)) : this._oldHasSelection && this._fireOnSelectionChange(h5, g4, b5);
        }
        _fireOnSelectionChange(h5, g4, b5) {
          this._oldSelectionStart = h5, this._oldSelectionEnd = g4, this._oldHasSelection = b5, this._onSelectionChange.fire();
        }
        _handleBufferActivate(h5) {
          this.clearSelection(), this._trimListener.dispose(), this._trimListener = h5.activeBuffer.lines.onTrim((g4) => this._handleTrim(g4));
        }
        _convertViewportColToCharacterIndex(h5, g4) {
          let b5 = g4;
          for (let L5 = 0; g4 >= L5; L5++) {
            let y5 = h5.loadCell(L5, this._workCell).getChars().length;
            this._workCell.getWidth() === 0 ? b5-- : y5 > 1 && g4 !== L5 && (b5 += y5 - 1);
          }
          return b5;
        }
        setSelection(h5, g4, b5) {
          this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [h5, g4], this._model.selectionStartLength = b5, this.refresh(), this._fireEventIfSelectionChanged();
        }
        rightClickSelect(h5) {
          this._isClickInSelection(h5) || (this._selectWordAtCursor(h5, false) && this.refresh(true), this._fireEventIfSelectionChanged());
        }
        _getWordAt(h5, g4, b5 = true, L5 = true) {
          if (h5[0] >= this._bufferService.cols)
            return;
          let y5 = this._bufferService.buffer, k4 = y5.lines.get(h5[1]);
          if (!k4)
            return;
          let x5 = y5.translateBufferLineToString(h5[1], false), T6 = this._convertViewportColToCharacterIndex(k4, h5[0]), O6 = T6, M5 = h5[0] - T6, C5 = 0, w4 = 0, E5 = 0, D5 = 0;
          if (x5.charAt(T6) === " ") {
            for (; T6 > 0 && x5.charAt(T6 - 1) === " "; )
              T6--;
            for (; O6 < x5.length && x5.charAt(O6 + 1) === " "; )
              O6++;
          } else {
            let U4 = h5[0], W5 = h5[0];
            k4.getWidth(U4) === 0 && (C5++, U4--), k4.getWidth(W5) === 2 && (w4++, W5++);
            let q6 = k4.getString(W5).length;
            for (q6 > 1 && (D5 += q6 - 1, O6 += q6 - 1); U4 > 0 && T6 > 0 && !this._isCharWordSeparator(k4.loadCell(U4 - 1, this._workCell)); ) {
              k4.loadCell(U4 - 1, this._workCell);
              let S6 = this._workCell.getChars().length;
              this._workCell.getWidth() === 0 ? (C5++, U4--) : S6 > 1 && (E5 += S6 - 1, T6 -= S6 - 1), T6--, U4--;
            }
            for (; W5 < k4.length && O6 + 1 < x5.length && !this._isCharWordSeparator(k4.loadCell(W5 + 1, this._workCell)); ) {
              k4.loadCell(W5 + 1, this._workCell);
              let S6 = this._workCell.getChars().length;
              this._workCell.getWidth() === 2 ? (w4++, W5++) : S6 > 1 && (D5 += S6 - 1, O6 += S6 - 1), O6++, W5++;
            }
          }
          O6++;
          let I7 = T6 + M5 - C5 + E5, H4 = Math.min(this._bufferService.cols, O6 - T6 + C5 + w4 - E5 - D5);
          if (g4 || x5.slice(T6, O6).trim() !== "") {
            if (b5 && I7 === 0 && k4.getCodePoint(0) !== 32) {
              let U4 = y5.lines.get(h5[1] - 1);
              if (U4 && k4.isWrapped && U4.getCodePoint(this._bufferService.cols - 1) !== 32) {
                let W5 = this._getWordAt([this._bufferService.cols - 1, h5[1] - 1], false, true, false);
                if (W5) {
                  let q6 = this._bufferService.cols - W5.start;
                  I7 -= q6, H4 += q6;
                }
              }
            }
            if (L5 && I7 + H4 === this._bufferService.cols && k4.getCodePoint(this._bufferService.cols - 1) !== 32) {
              let U4 = y5.lines.get(h5[1] + 1);
              if (U4?.isWrapped && U4.getCodePoint(0) !== 32) {
                let W5 = this._getWordAt([0, h5[1] + 1], false, false, true);
                W5 && (H4 += W5.length);
              }
            }
            return { start: I7, length: H4 };
          }
        }
        _selectWordAt(h5, g4) {
          let b5 = this._getWordAt(h5, g4);
          if (b5) {
            for (; b5.start < 0; )
              b5.start += this._bufferService.cols, h5[1]--;
            this._model.selectionStart = [b5.start, h5[1]], this._model.selectionStartLength = b5.length;
          }
        }
        _selectToWordAt(h5) {
          let g4 = this._getWordAt(h5, true);
          if (g4) {
            let b5 = h5[1];
            for (; g4.start < 0; )
              g4.start += this._bufferService.cols, b5--;
            if (!this._model.areSelectionValuesReversed())
              for (; g4.start + g4.length > this._bufferService.cols; )
                g4.length -= this._bufferService.cols, b5++;
            this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? g4.start : g4.start + g4.length, b5];
          }
        }
        _isCharWordSeparator(h5) {
          return h5.getWidth() !== 0 && this._optionsService.rawOptions.wordSeparator.indexOf(h5.getChars()) >= 0;
        }
        _selectLineAt(h5) {
          let g4 = this._bufferService.buffer.getWrappedRangeForLine(h5), b5 = { start: { x: 0, y: g4.first }, end: { x: this._bufferService.cols - 1, y: g4.last } };
          this._model.selectionStart = [0, g4.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, t.getRangeLength)(b5, this._bufferService.cols);
        }
      };
      r.SelectionService = m6 = l4([u3(3, o3.IBufferService), u3(4, o3.ICoreService), u3(5, p6.IMouseService), u3(6, o3.IOptionsService), u3(7, p6.IRenderService), u3(8, p6.ICoreBrowserService)], m6);
    }, 4725: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.IThemeService = r.ICharacterJoinerService = r.ISelectionService = r.IRenderService = r.IMouseService = r.ICoreBrowserService = r.ICharSizeService = void 0;
      let l4 = a2(8343);
      r.ICharSizeService = (0, l4.createDecorator)("CharSizeService"), r.ICoreBrowserService = (0, l4.createDecorator)("CoreBrowserService"), r.IMouseService = (0, l4.createDecorator)("MouseService"), r.IRenderService = (0, l4.createDecorator)("RenderService"), r.ISelectionService = (0, l4.createDecorator)("SelectionService"), r.ICharacterJoinerService = (0, l4.createDecorator)("CharacterJoinerService"), r.IThemeService = (0, l4.createDecorator)("ThemeService");
    }, 6731: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(m6, h5, g4, b5) {
        var L5, y5 = arguments.length, k4 = y5 < 3 ? h5 : b5 === null ? b5 = Object.getOwnPropertyDescriptor(h5, g4) : b5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          k4 = Reflect.decorate(m6, h5, g4, b5);
        else
          for (var x5 = m6.length - 1; x5 >= 0; x5--)
            (L5 = m6[x5]) && (k4 = (y5 < 3 ? L5(k4) : y5 > 3 ? L5(h5, g4, k4) : L5(h5, g4)) || k4);
        return y5 > 3 && k4 && Object.defineProperty(h5, g4, k4), k4;
      }, u3 = this && this.__param || function(m6, h5) {
        return function(g4, b5) {
          h5(g4, b5, m6);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.ThemeService = r.DEFAULT_ANSI_COLORS = void 0;
      let n3 = a2(7239), d5 = a2(8055), f4 = a2(8460), p6 = a2(844), _5 = a2(2585), e = d5.css.toColor("#ffffff"), s2 = d5.css.toColor("#000000"), t = d5.css.toColor("#ffffff"), i4 = d5.css.toColor("#000000"), o3 = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
      r.DEFAULT_ANSI_COLORS = Object.freeze((() => {
        let m6 = [d5.css.toColor("#2e3436"), d5.css.toColor("#cc0000"), d5.css.toColor("#4e9a06"), d5.css.toColor("#c4a000"), d5.css.toColor("#3465a4"), d5.css.toColor("#75507b"), d5.css.toColor("#06989a"), d5.css.toColor("#d3d7cf"), d5.css.toColor("#555753"), d5.css.toColor("#ef2929"), d5.css.toColor("#8ae234"), d5.css.toColor("#fce94f"), d5.css.toColor("#729fcf"), d5.css.toColor("#ad7fa8"), d5.css.toColor("#34e2e2"), d5.css.toColor("#eeeeec")], h5 = [0, 95, 135, 175, 215, 255];
        for (let g4 = 0; g4 < 216; g4++) {
          let b5 = h5[g4 / 36 % 6 | 0], L5 = h5[g4 / 6 % 6 | 0], y5 = h5[g4 % 6];
          m6.push({ css: d5.channels.toCss(b5, L5, y5), rgba: d5.channels.toRgba(b5, L5, y5) });
        }
        for (let g4 = 0; g4 < 24; g4++) {
          let b5 = 8 + 10 * g4;
          m6.push({ css: d5.channels.toCss(b5, b5, b5), rgba: d5.channels.toRgba(b5, b5, b5) });
        }
        return m6;
      })());
      let c3 = r.ThemeService = class extends p6.Disposable {
        get colors() {
          return this._colors;
        }
        constructor(m6) {
          super(), this._optionsService = m6, this._contrastCache = new n3.ColorContrastCache(), this._halfContrastCache = new n3.ColorContrastCache(), this._onChangeColors = this.register(new f4.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: e, background: s2, cursor: t, cursorAccent: i4, selectionForeground: void 0, selectionBackgroundTransparent: o3, selectionBackgroundOpaque: d5.color.blend(s2, o3), selectionInactiveBackgroundTransparent: o3, selectionInactiveBackgroundOpaque: d5.color.blend(s2, o3), ansi: r.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
        }
        _setTheme(m6 = {}) {
          let h5 = this._colors;
          if (h5.foreground = v5(m6.foreground, e), h5.background = v5(m6.background, s2), h5.cursor = v5(m6.cursor, t), h5.cursorAccent = v5(m6.cursorAccent, i4), h5.selectionBackgroundTransparent = v5(m6.selectionBackground, o3), h5.selectionBackgroundOpaque = d5.color.blend(h5.background, h5.selectionBackgroundTransparent), h5.selectionInactiveBackgroundTransparent = v5(m6.selectionInactiveBackground, h5.selectionBackgroundTransparent), h5.selectionInactiveBackgroundOpaque = d5.color.blend(h5.background, h5.selectionInactiveBackgroundTransparent), h5.selectionForeground = m6.selectionForeground ? v5(m6.selectionForeground, d5.NULL_COLOR) : void 0, h5.selectionForeground === d5.NULL_COLOR && (h5.selectionForeground = void 0), d5.color.isOpaque(h5.selectionBackgroundTransparent) && (h5.selectionBackgroundTransparent = d5.color.opacity(h5.selectionBackgroundTransparent, 0.3)), d5.color.isOpaque(h5.selectionInactiveBackgroundTransparent) && (h5.selectionInactiveBackgroundTransparent = d5.color.opacity(h5.selectionInactiveBackgroundTransparent, 0.3)), h5.ansi = r.DEFAULT_ANSI_COLORS.slice(), h5.ansi[0] = v5(m6.black, r.DEFAULT_ANSI_COLORS[0]), h5.ansi[1] = v5(m6.red, r.DEFAULT_ANSI_COLORS[1]), h5.ansi[2] = v5(m6.green, r.DEFAULT_ANSI_COLORS[2]), h5.ansi[3] = v5(m6.yellow, r.DEFAULT_ANSI_COLORS[3]), h5.ansi[4] = v5(m6.blue, r.DEFAULT_ANSI_COLORS[4]), h5.ansi[5] = v5(m6.magenta, r.DEFAULT_ANSI_COLORS[5]), h5.ansi[6] = v5(m6.cyan, r.DEFAULT_ANSI_COLORS[6]), h5.ansi[7] = v5(m6.white, r.DEFAULT_ANSI_COLORS[7]), h5.ansi[8] = v5(m6.brightBlack, r.DEFAULT_ANSI_COLORS[8]), h5.ansi[9] = v5(m6.brightRed, r.DEFAULT_ANSI_COLORS[9]), h5.ansi[10] = v5(m6.brightGreen, r.DEFAULT_ANSI_COLORS[10]), h5.ansi[11] = v5(m6.brightYellow, r.DEFAULT_ANSI_COLORS[11]), h5.ansi[12] = v5(m6.brightBlue, r.DEFAULT_ANSI_COLORS[12]), h5.ansi[13] = v5(m6.brightMagenta, r.DEFAULT_ANSI_COLORS[13]), h5.ansi[14] = v5(m6.brightCyan, r.DEFAULT_ANSI_COLORS[14]), h5.ansi[15] = v5(m6.brightWhite, r.DEFAULT_ANSI_COLORS[15]), m6.extendedAnsi) {
            let g4 = Math.min(h5.ansi.length - 16, m6.extendedAnsi.length);
            for (let b5 = 0; b5 < g4; b5++)
              h5.ansi[b5 + 16] = v5(m6.extendedAnsi[b5], r.DEFAULT_ANSI_COLORS[b5 + 16]);
          }
          this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
        }
        restoreColor(m6) {
          this._restoreColor(m6), this._onChangeColors.fire(this.colors);
        }
        _restoreColor(m6) {
          if (m6 !== void 0)
            switch (m6) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[m6] = this._restoreColors.ansi[m6];
            }
          else
            for (let h5 = 0; h5 < this._restoreColors.ansi.length; ++h5)
              this._colors.ansi[h5] = this._restoreColors.ansi[h5];
        }
        modifyColors(m6) {
          m6(this._colors), this._onChangeColors.fire(this.colors);
        }
        _updateRestoreColors() {
          this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
        }
      };
      function v5(m6, h5) {
        if (m6 !== void 0)
          try {
            return d5.css.toColor(m6);
          } catch {
          }
        return h5;
      }
      r.ThemeService = c3 = l4([u3(0, _5.IOptionsService)], c3);
    }, 6349: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.CircularList = void 0;
      let l4 = a2(8460), u3 = a2(844);
      class n3 extends u3.Disposable {
        constructor(f4) {
          super(), this._maxLength = f4, this.onDeleteEmitter = this.register(new l4.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new l4.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new l4.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
        }
        get maxLength() {
          return this._maxLength;
        }
        set maxLength(f4) {
          if (this._maxLength === f4)
            return;
          let p6 = new Array(f4);
          for (let _5 = 0; _5 < Math.min(f4, this.length); _5++)
            p6[_5] = this._array[this._getCyclicIndex(_5)];
          this._array = p6, this._maxLength = f4, this._startIndex = 0;
        }
        get length() {
          return this._length;
        }
        set length(f4) {
          if (f4 > this._length)
            for (let p6 = this._length; p6 < f4; p6++)
              this._array[p6] = void 0;
          this._length = f4;
        }
        get(f4) {
          return this._array[this._getCyclicIndex(f4)];
        }
        set(f4, p6) {
          this._array[this._getCyclicIndex(f4)] = p6;
        }
        push(f4) {
          this._array[this._getCyclicIndex(this._length)] = f4, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
        }
        recycle() {
          if (this._length !== this._maxLength)
            throw new Error("Can only recycle when the buffer is full");
          return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
        }
        get isFull() {
          return this._length === this._maxLength;
        }
        pop() {
          return this._array[this._getCyclicIndex(this._length-- - 1)];
        }
        splice(f4, p6, ..._5) {
          if (p6) {
            for (let e = f4; e < this._length - p6; e++)
              this._array[this._getCyclicIndex(e)] = this._array[this._getCyclicIndex(e + p6)];
            this._length -= p6, this.onDeleteEmitter.fire({ index: f4, amount: p6 });
          }
          for (let e = this._length - 1; e >= f4; e--)
            this._array[this._getCyclicIndex(e + _5.length)] = this._array[this._getCyclicIndex(e)];
          for (let e = 0; e < _5.length; e++)
            this._array[this._getCyclicIndex(f4 + e)] = _5[e];
          if (_5.length && this.onInsertEmitter.fire({ index: f4, amount: _5.length }), this._length + _5.length > this._maxLength) {
            let e = this._length + _5.length - this._maxLength;
            this._startIndex += e, this._length = this._maxLength, this.onTrimEmitter.fire(e);
          } else
            this._length += _5.length;
        }
        trimStart(f4) {
          f4 > this._length && (f4 = this._length), this._startIndex += f4, this._length -= f4, this.onTrimEmitter.fire(f4);
        }
        shiftElements(f4, p6, _5) {
          if (!(p6 <= 0)) {
            if (f4 < 0 || f4 >= this._length)
              throw new Error("start argument out of range");
            if (f4 + _5 < 0)
              throw new Error("Cannot shift elements in list beyond index 0");
            if (_5 > 0) {
              for (let s2 = p6 - 1; s2 >= 0; s2--)
                this.set(f4 + s2 + _5, this.get(f4 + s2));
              let e = f4 + p6 + _5 - this._length;
              if (e > 0)
                for (this._length += e; this._length > this._maxLength; )
                  this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
            } else
              for (let e = 0; e < p6; e++)
                this.set(f4 + e + _5, this.get(f4 + e));
          }
        }
        _getCyclicIndex(f4) {
          return (this._startIndex + f4) % this._maxLength;
        }
      }
      r.CircularList = n3;
    }, 1439: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.clone = void 0, r.clone = function a2(l4, u3 = 5) {
        if (typeof l4 != "object")
          return l4;
        let n3 = Array.isArray(l4) ? [] : {};
        for (let d5 in l4)
          n3[d5] = u3 <= 1 ? l4[d5] : l4[d5] && a2(l4[d5], u3 - 1);
        return n3;
      };
    }, 8055: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.contrastRatio = r.toPaddedHex = r.rgba = r.rgb = r.css = r.color = r.channels = r.NULL_COLOR = void 0;
      let l4 = a2(6114), u3 = 0, n3 = 0, d5 = 0, f4 = 0;
      var p6, _5, e, s2, t;
      function i4(c3) {
        let v5 = c3.toString(16);
        return v5.length < 2 ? "0" + v5 : v5;
      }
      function o3(c3, v5) {
        return c3 < v5 ? (v5 + 0.05) / (c3 + 0.05) : (c3 + 0.05) / (v5 + 0.05);
      }
      r.NULL_COLOR = { css: "#00000000", rgba: 0 }, function(c3) {
        c3.toCss = function(v5, m6, h5, g4) {
          return g4 !== void 0 ? `#${i4(v5)}${i4(m6)}${i4(h5)}${i4(g4)}` : `#${i4(v5)}${i4(m6)}${i4(h5)}`;
        }, c3.toRgba = function(v5, m6, h5, g4 = 255) {
          return (v5 << 24 | m6 << 16 | h5 << 8 | g4) >>> 0;
        };
      }(p6 || (r.channels = p6 = {})), function(c3) {
        function v5(m6, h5) {
          return f4 = Math.round(255 * h5), [u3, n3, d5] = t.toChannels(m6.rgba), { css: p6.toCss(u3, n3, d5, f4), rgba: p6.toRgba(u3, n3, d5, f4) };
        }
        c3.blend = function(m6, h5) {
          if (f4 = (255 & h5.rgba) / 255, f4 === 1)
            return { css: h5.css, rgba: h5.rgba };
          let g4 = h5.rgba >> 24 & 255, b5 = h5.rgba >> 16 & 255, L5 = h5.rgba >> 8 & 255, y5 = m6.rgba >> 24 & 255, k4 = m6.rgba >> 16 & 255, x5 = m6.rgba >> 8 & 255;
          return u3 = y5 + Math.round((g4 - y5) * f4), n3 = k4 + Math.round((b5 - k4) * f4), d5 = x5 + Math.round((L5 - x5) * f4), { css: p6.toCss(u3, n3, d5), rgba: p6.toRgba(u3, n3, d5) };
        }, c3.isOpaque = function(m6) {
          return (255 & m6.rgba) == 255;
        }, c3.ensureContrastRatio = function(m6, h5, g4) {
          let b5 = t.ensureContrastRatio(m6.rgba, h5.rgba, g4);
          if (b5)
            return t.toColor(b5 >> 24 & 255, b5 >> 16 & 255, b5 >> 8 & 255);
        }, c3.opaque = function(m6) {
          let h5 = (255 | m6.rgba) >>> 0;
          return [u3, n3, d5] = t.toChannels(h5), { css: p6.toCss(u3, n3, d5), rgba: h5 };
        }, c3.opacity = v5, c3.multiplyOpacity = function(m6, h5) {
          return f4 = 255 & m6.rgba, v5(m6, f4 * h5 / 255);
        }, c3.toColorRGB = function(m6) {
          return [m6.rgba >> 24 & 255, m6.rgba >> 16 & 255, m6.rgba >> 8 & 255];
        };
      }(_5 || (r.color = _5 = {})), function(c3) {
        let v5, m6;
        if (!l4.isNode) {
          let h5 = document.createElement("canvas");
          h5.width = 1, h5.height = 1;
          let g4 = h5.getContext("2d", { willReadFrequently: true });
          g4 && (v5 = g4, v5.globalCompositeOperation = "copy", m6 = v5.createLinearGradient(0, 0, 1, 1));
        }
        c3.toColor = function(h5) {
          if (h5.match(/#[\da-f]{3,8}/i))
            switch (h5.length) {
              case 4:
                return u3 = parseInt(h5.slice(1, 2).repeat(2), 16), n3 = parseInt(h5.slice(2, 3).repeat(2), 16), d5 = parseInt(h5.slice(3, 4).repeat(2), 16), t.toColor(u3, n3, d5);
              case 5:
                return u3 = parseInt(h5.slice(1, 2).repeat(2), 16), n3 = parseInt(h5.slice(2, 3).repeat(2), 16), d5 = parseInt(h5.slice(3, 4).repeat(2), 16), f4 = parseInt(h5.slice(4, 5).repeat(2), 16), t.toColor(u3, n3, d5, f4);
              case 7:
                return { css: h5, rgba: (parseInt(h5.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: h5, rgba: parseInt(h5.slice(1), 16) >>> 0 };
            }
          let g4 = h5.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
          if (g4)
            return u3 = parseInt(g4[1]), n3 = parseInt(g4[2]), d5 = parseInt(g4[3]), f4 = Math.round(255 * (g4[5] === void 0 ? 1 : parseFloat(g4[5]))), t.toColor(u3, n3, d5, f4);
          if (!v5 || !m6)
            throw new Error("css.toColor: Unsupported css format");
          if (v5.fillStyle = m6, v5.fillStyle = h5, typeof v5.fillStyle != "string")
            throw new Error("css.toColor: Unsupported css format");
          if (v5.fillRect(0, 0, 1, 1), [u3, n3, d5, f4] = v5.getImageData(0, 0, 1, 1).data, f4 !== 255)
            throw new Error("css.toColor: Unsupported css format");
          return { rgba: p6.toRgba(u3, n3, d5, f4), css: h5 };
        };
      }(e || (r.css = e = {})), function(c3) {
        function v5(m6, h5, g4) {
          let b5 = m6 / 255, L5 = h5 / 255, y5 = g4 / 255;
          return 0.2126 * (b5 <= 0.03928 ? b5 / 12.92 : Math.pow((b5 + 0.055) / 1.055, 2.4)) + 0.7152 * (L5 <= 0.03928 ? L5 / 12.92 : Math.pow((L5 + 0.055) / 1.055, 2.4)) + 0.0722 * (y5 <= 0.03928 ? y5 / 12.92 : Math.pow((y5 + 0.055) / 1.055, 2.4));
        }
        c3.relativeLuminance = function(m6) {
          return v5(m6 >> 16 & 255, m6 >> 8 & 255, 255 & m6);
        }, c3.relativeLuminance2 = v5;
      }(s2 || (r.rgb = s2 = {})), function(c3) {
        function v5(h5, g4, b5) {
          let L5 = h5 >> 24 & 255, y5 = h5 >> 16 & 255, k4 = h5 >> 8 & 255, x5 = g4 >> 24 & 255, T6 = g4 >> 16 & 255, O6 = g4 >> 8 & 255, M5 = o3(s2.relativeLuminance2(x5, T6, O6), s2.relativeLuminance2(L5, y5, k4));
          for (; M5 < b5 && (x5 > 0 || T6 > 0 || O6 > 0); )
            x5 -= Math.max(0, Math.ceil(0.1 * x5)), T6 -= Math.max(0, Math.ceil(0.1 * T6)), O6 -= Math.max(0, Math.ceil(0.1 * O6)), M5 = o3(s2.relativeLuminance2(x5, T6, O6), s2.relativeLuminance2(L5, y5, k4));
          return (x5 << 24 | T6 << 16 | O6 << 8 | 255) >>> 0;
        }
        function m6(h5, g4, b5) {
          let L5 = h5 >> 24 & 255, y5 = h5 >> 16 & 255, k4 = h5 >> 8 & 255, x5 = g4 >> 24 & 255, T6 = g4 >> 16 & 255, O6 = g4 >> 8 & 255, M5 = o3(s2.relativeLuminance2(x5, T6, O6), s2.relativeLuminance2(L5, y5, k4));
          for (; M5 < b5 && (x5 < 255 || T6 < 255 || O6 < 255); )
            x5 = Math.min(255, x5 + Math.ceil(0.1 * (255 - x5))), T6 = Math.min(255, T6 + Math.ceil(0.1 * (255 - T6))), O6 = Math.min(255, O6 + Math.ceil(0.1 * (255 - O6))), M5 = o3(s2.relativeLuminance2(x5, T6, O6), s2.relativeLuminance2(L5, y5, k4));
          return (x5 << 24 | T6 << 16 | O6 << 8 | 255) >>> 0;
        }
        c3.ensureContrastRatio = function(h5, g4, b5) {
          let L5 = s2.relativeLuminance(h5 >> 8), y5 = s2.relativeLuminance(g4 >> 8);
          if (o3(L5, y5) < b5) {
            if (y5 < L5) {
              let T6 = v5(h5, g4, b5), O6 = o3(L5, s2.relativeLuminance(T6 >> 8));
              if (O6 < b5) {
                let M5 = m6(h5, g4, b5);
                return O6 > o3(L5, s2.relativeLuminance(M5 >> 8)) ? T6 : M5;
              }
              return T6;
            }
            let k4 = m6(h5, g4, b5), x5 = o3(L5, s2.relativeLuminance(k4 >> 8));
            if (x5 < b5) {
              let T6 = v5(h5, g4, b5);
              return x5 > o3(L5, s2.relativeLuminance(T6 >> 8)) ? k4 : T6;
            }
            return k4;
          }
        }, c3.reduceLuminance = v5, c3.increaseLuminance = m6, c3.toChannels = function(h5) {
          return [h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, 255 & h5];
        }, c3.toColor = function(h5, g4, b5, L5) {
          return { css: p6.toCss(h5, g4, b5, L5), rgba: p6.toRgba(h5, g4, b5, L5) };
        };
      }(t || (r.rgba = t = {})), r.toPaddedHex = i4, r.contrastRatio = o3;
    }, 8969: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.CoreTerminal = void 0;
      let l4 = a2(844), u3 = a2(2585), n3 = a2(4348), d5 = a2(7866), f4 = a2(744), p6 = a2(7302), _5 = a2(6975), e = a2(8460), s2 = a2(1753), t = a2(1480), i4 = a2(7994), o3 = a2(9282), c3 = a2(5435), v5 = a2(5981), m6 = a2(2660), h5 = false;
      class g4 extends l4.Disposable {
        get onScroll() {
          return this._onScrollApi || (this._onScrollApi = this.register(new e.EventEmitter()), this._onScroll.event((L5) => {
            var y5;
            (y5 = this._onScrollApi) === null || y5 === void 0 || y5.fire(L5.position);
          })), this._onScrollApi.event;
        }
        get cols() {
          return this._bufferService.cols;
        }
        get rows() {
          return this._bufferService.rows;
        }
        get buffers() {
          return this._bufferService.buffers;
        }
        get options() {
          return this.optionsService.options;
        }
        set options(L5) {
          for (let y5 in L5)
            this.optionsService.options[y5] = L5[y5];
        }
        constructor(L5) {
          super(), this._windowsWrappingHeuristics = this.register(new l4.MutableDisposable()), this._onBinary = this.register(new e.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new e.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new e.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new e.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new e.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new e.EventEmitter()), this._instantiationService = new n3.InstantiationService(), this.optionsService = this.register(new p6.OptionsService(L5)), this._instantiationService.setService(u3.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(f4.BufferService)), this._instantiationService.setService(u3.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(d5.LogService)), this._instantiationService.setService(u3.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(_5.CoreService)), this._instantiationService.setService(u3.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(s2.CoreMouseService)), this._instantiationService.setService(u3.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(t.UnicodeService)), this._instantiationService.setService(u3.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(i4.CharsetService), this._instantiationService.setService(u3.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(m6.OscLinkService), this._instantiationService.setService(u3.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new c3.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, e.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, e.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, e.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, e.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((y5) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this.register(this._inputHandler.onScroll((y5) => {
            this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
          })), this._writeBuffer = this.register(new v5.WriteBuffer((y5, k4) => this._inputHandler.parse(y5, k4))), this.register((0, e.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
        }
        write(L5, y5) {
          this._writeBuffer.write(L5, y5);
        }
        writeSync(L5, y5) {
          this._logService.logLevel <= u3.LogLevelEnum.WARN && !h5 && (this._logService.warn("writeSync is unreliable and will be removed soon."), h5 = true), this._writeBuffer.writeSync(L5, y5);
        }
        resize(L5, y5) {
          isNaN(L5) || isNaN(y5) || (L5 = Math.max(L5, f4.MINIMUM_COLS), y5 = Math.max(y5, f4.MINIMUM_ROWS), this._bufferService.resize(L5, y5));
        }
        scroll(L5, y5 = false) {
          this._bufferService.scroll(L5, y5);
        }
        scrollLines(L5, y5, k4) {
          this._bufferService.scrollLines(L5, y5, k4);
        }
        scrollPages(L5) {
          this.scrollLines(L5 * (this.rows - 1));
        }
        scrollToTop() {
          this.scrollLines(-this._bufferService.buffer.ydisp);
        }
        scrollToBottom() {
          this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
        }
        scrollToLine(L5) {
          let y5 = L5 - this._bufferService.buffer.ydisp;
          y5 !== 0 && this.scrollLines(y5);
        }
        registerEscHandler(L5, y5) {
          return this._inputHandler.registerEscHandler(L5, y5);
        }
        registerDcsHandler(L5, y5) {
          return this._inputHandler.registerDcsHandler(L5, y5);
        }
        registerCsiHandler(L5, y5) {
          return this._inputHandler.registerCsiHandler(L5, y5);
        }
        registerOscHandler(L5, y5) {
          return this._inputHandler.registerOscHandler(L5, y5);
        }
        _setup() {
          this._handleWindowsPtyOptionChange();
        }
        reset() {
          this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
        }
        _handleWindowsPtyOptionChange() {
          let L5 = false, y5 = this.optionsService.rawOptions.windowsPty;
          y5 && y5.buildNumber !== void 0 && y5.buildNumber !== void 0 ? L5 = y5.backend === "conpty" && y5.buildNumber < 21376 : this.optionsService.rawOptions.windowsMode && (L5 = true), L5 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
        }
        _enableWindowsWrappingHeuristics() {
          if (!this._windowsWrappingHeuristics.value) {
            let L5 = [];
            L5.push(this.onLineFeed(o3.updateWindowsModeWrappedState.bind(null, this._bufferService))), L5.push(this.registerCsiHandler({ final: "H" }, () => ((0, o3.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, l4.toDisposable)(() => {
              for (let y5 of L5)
                y5.dispose();
            });
          }
        }
      }
      r.CoreTerminal = g4;
    }, 8460: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.forwardEvent = r.EventEmitter = void 0, r.EventEmitter = class {
        constructor() {
          this._listeners = [], this._disposed = false;
        }
        get event() {
          return this._event || (this._event = (a2) => (this._listeners.push(a2), { dispose: () => {
            if (!this._disposed) {
              for (let l4 = 0; l4 < this._listeners.length; l4++)
                if (this._listeners[l4] === a2)
                  return void this._listeners.splice(l4, 1);
            }
          } })), this._event;
        }
        fire(a2, l4) {
          let u3 = [];
          for (let n3 = 0; n3 < this._listeners.length; n3++)
            u3.push(this._listeners[n3]);
          for (let n3 = 0; n3 < u3.length; n3++)
            u3[n3].call(void 0, a2, l4);
        }
        dispose() {
          this.clearListeners(), this._disposed = true;
        }
        clearListeners() {
          this._listeners && (this._listeners.length = 0);
        }
      }, r.forwardEvent = function(a2, l4) {
        return a2((u3) => l4.fire(u3));
      };
    }, 5435: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(M5, C5, w4, E5) {
        var D5, I7 = arguments.length, H4 = I7 < 3 ? C5 : E5 === null ? E5 = Object.getOwnPropertyDescriptor(C5, w4) : E5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          H4 = Reflect.decorate(M5, C5, w4, E5);
        else
          for (var U4 = M5.length - 1; U4 >= 0; U4--)
            (D5 = M5[U4]) && (H4 = (I7 < 3 ? D5(H4) : I7 > 3 ? D5(C5, w4, H4) : D5(C5, w4)) || H4);
        return I7 > 3 && H4 && Object.defineProperty(C5, w4, H4), H4;
      }, u3 = this && this.__param || function(M5, C5) {
        return function(w4, E5) {
          C5(w4, E5, M5);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.InputHandler = r.WindowsOptionsReportType = void 0;
      let n3 = a2(2584), d5 = a2(7116), f4 = a2(2015), p6 = a2(844), _5 = a2(482), e = a2(8437), s2 = a2(8460), t = a2(643), i4 = a2(511), o3 = a2(3734), c3 = a2(2585), v5 = a2(6242), m6 = a2(6351), h5 = a2(5941), g4 = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, b5 = 131072;
      function L5(M5, C5) {
        if (M5 > 24)
          return C5.setWinLines || false;
        switch (M5) {
          case 1:
            return !!C5.restoreWin;
          case 2:
            return !!C5.minimizeWin;
          case 3:
            return !!C5.setWinPosition;
          case 4:
            return !!C5.setWinSizePixels;
          case 5:
            return !!C5.raiseWin;
          case 6:
            return !!C5.lowerWin;
          case 7:
            return !!C5.refreshWin;
          case 8:
            return !!C5.setWinSizeChars;
          case 9:
            return !!C5.maximizeWin;
          case 10:
            return !!C5.fullscreenWin;
          case 11:
            return !!C5.getWinState;
          case 13:
            return !!C5.getWinPosition;
          case 14:
            return !!C5.getWinSizePixels;
          case 15:
            return !!C5.getScreenSizePixels;
          case 16:
            return !!C5.getCellSizePixels;
          case 18:
            return !!C5.getWinSizeChars;
          case 19:
            return !!C5.getScreenSizeChars;
          case 20:
            return !!C5.getIconTitle;
          case 21:
            return !!C5.getWinTitle;
          case 22:
            return !!C5.pushTitle;
          case 23:
            return !!C5.popTitle;
          case 24:
            return !!C5.setWinLines;
        }
        return false;
      }
      var y5;
      (function(M5) {
        M5[M5.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", M5[M5.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
      })(y5 || (r.WindowsOptionsReportType = y5 = {}));
      let k4 = 0;
      class x5 extends p6.Disposable {
        getAttrData() {
          return this._curAttrData;
        }
        constructor(C5, w4, E5, D5, I7, H4, U4, W5, q6 = new f4.EscapeSequenceParser()) {
          super(), this._bufferService = C5, this._charsetService = w4, this._coreService = E5, this._logService = D5, this._optionsService = I7, this._oscLinkService = H4, this._coreMouseService = U4, this._unicodeService = W5, this._parser = q6, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new _5.StringToUtf32(), this._utf8Decoder = new _5.Utf8ToUtf32(), this._workCell = new i4.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new s2.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new s2.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new s2.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new s2.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new s2.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new s2.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new s2.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new s2.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new s2.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new s2.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new s2.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new s2.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new s2.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new T6(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((S6) => this._activeBuffer = S6.activeBuffer)), this._parser.setCsiHandlerFallback((S6, R4) => {
            this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(S6), params: R4.toArray() });
          }), this._parser.setEscHandlerFallback((S6) => {
            this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(S6) });
          }), this._parser.setExecuteHandlerFallback((S6) => {
            this._logService.debug("Unknown EXECUTE code: ", { code: S6 });
          }), this._parser.setOscHandlerFallback((S6, R4, B4) => {
            this._logService.debug("Unknown OSC code: ", { identifier: S6, action: R4, data: B4 });
          }), this._parser.setDcsHandlerFallback((S6, R4, B4) => {
            R4 === "HOOK" && (B4 = B4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(S6), action: R4, payload: B4 });
          }), this._parser.setPrintHandler((S6, R4, B4) => this.print(S6, R4, B4)), this._parser.registerCsiHandler({ final: "@" }, (S6) => this.insertChars(S6)), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, (S6) => this.scrollLeft(S6)), this._parser.registerCsiHandler({ final: "A" }, (S6) => this.cursorUp(S6)), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, (S6) => this.scrollRight(S6)), this._parser.registerCsiHandler({ final: "B" }, (S6) => this.cursorDown(S6)), this._parser.registerCsiHandler({ final: "C" }, (S6) => this.cursorForward(S6)), this._parser.registerCsiHandler({ final: "D" }, (S6) => this.cursorBackward(S6)), this._parser.registerCsiHandler({ final: "E" }, (S6) => this.cursorNextLine(S6)), this._parser.registerCsiHandler({ final: "F" }, (S6) => this.cursorPrecedingLine(S6)), this._parser.registerCsiHandler({ final: "G" }, (S6) => this.cursorCharAbsolute(S6)), this._parser.registerCsiHandler({ final: "H" }, (S6) => this.cursorPosition(S6)), this._parser.registerCsiHandler({ final: "I" }, (S6) => this.cursorForwardTab(S6)), this._parser.registerCsiHandler({ final: "J" }, (S6) => this.eraseInDisplay(S6, false)), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, (S6) => this.eraseInDisplay(S6, true)), this._parser.registerCsiHandler({ final: "K" }, (S6) => this.eraseInLine(S6, false)), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, (S6) => this.eraseInLine(S6, true)), this._parser.registerCsiHandler({ final: "L" }, (S6) => this.insertLines(S6)), this._parser.registerCsiHandler({ final: "M" }, (S6) => this.deleteLines(S6)), this._parser.registerCsiHandler({ final: "P" }, (S6) => this.deleteChars(S6)), this._parser.registerCsiHandler({ final: "S" }, (S6) => this.scrollUp(S6)), this._parser.registerCsiHandler({ final: "T" }, (S6) => this.scrollDown(S6)), this._parser.registerCsiHandler({ final: "X" }, (S6) => this.eraseChars(S6)), this._parser.registerCsiHandler({ final: "Z" }, (S6) => this.cursorBackwardTab(S6)), this._parser.registerCsiHandler({ final: "`" }, (S6) => this.charPosAbsolute(S6)), this._parser.registerCsiHandler({ final: "a" }, (S6) => this.hPositionRelative(S6)), this._parser.registerCsiHandler({ final: "b" }, (S6) => this.repeatPrecedingCharacter(S6)), this._parser.registerCsiHandler({ final: "c" }, (S6) => this.sendDeviceAttributesPrimary(S6)), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, (S6) => this.sendDeviceAttributesSecondary(S6)), this._parser.registerCsiHandler({ final: "d" }, (S6) => this.linePosAbsolute(S6)), this._parser.registerCsiHandler({ final: "e" }, (S6) => this.vPositionRelative(S6)), this._parser.registerCsiHandler({ final: "f" }, (S6) => this.hVPosition(S6)), this._parser.registerCsiHandler({ final: "g" }, (S6) => this.tabClear(S6)), this._parser.registerCsiHandler({ final: "h" }, (S6) => this.setMode(S6)), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, (S6) => this.setModePrivate(S6)), this._parser.registerCsiHandler({ final: "l" }, (S6) => this.resetMode(S6)), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, (S6) => this.resetModePrivate(S6)), this._parser.registerCsiHandler({ final: "m" }, (S6) => this.charAttributes(S6)), this._parser.registerCsiHandler({ final: "n" }, (S6) => this.deviceStatus(S6)), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, (S6) => this.deviceStatusPrivate(S6)), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, (S6) => this.softReset(S6)), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, (S6) => this.setCursorStyle(S6)), this._parser.registerCsiHandler({ final: "r" }, (S6) => this.setScrollRegion(S6)), this._parser.registerCsiHandler({ final: "s" }, (S6) => this.saveCursor(S6)), this._parser.registerCsiHandler({ final: "t" }, (S6) => this.windowOptions(S6)), this._parser.registerCsiHandler({ final: "u" }, (S6) => this.restoreCursor(S6)), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, (S6) => this.insertColumns(S6)), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, (S6) => this.deleteColumns(S6)), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, (S6) => this.selectProtected(S6)), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, (S6) => this.requestMode(S6, true)), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, (S6) => this.requestMode(S6, false)), this._parser.setExecuteHandler(n3.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n3.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n3.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n3.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n3.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n3.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n3.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n3.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n3.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n3.C1.IND, () => this.index()), this._parser.setExecuteHandler(n3.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n3.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new v5.OscHandler((S6) => (this.setTitle(S6), this.setIconName(S6), true))), this._parser.registerOscHandler(1, new v5.OscHandler((S6) => this.setIconName(S6))), this._parser.registerOscHandler(2, new v5.OscHandler((S6) => this.setTitle(S6))), this._parser.registerOscHandler(4, new v5.OscHandler((S6) => this.setOrReportIndexedColor(S6))), this._parser.registerOscHandler(8, new v5.OscHandler((S6) => this.setHyperlink(S6))), this._parser.registerOscHandler(10, new v5.OscHandler((S6) => this.setOrReportFgColor(S6))), this._parser.registerOscHandler(11, new v5.OscHandler((S6) => this.setOrReportBgColor(S6))), this._parser.registerOscHandler(12, new v5.OscHandler((S6) => this.setOrReportCursorColor(S6))), this._parser.registerOscHandler(104, new v5.OscHandler((S6) => this.restoreIndexedColor(S6))), this._parser.registerOscHandler(110, new v5.OscHandler((S6) => this.restoreFgColor(S6))), this._parser.registerOscHandler(111, new v5.OscHandler((S6) => this.restoreBgColor(S6))), this._parser.registerOscHandler(112, new v5.OscHandler((S6) => this.restoreCursorColor(S6))), this._parser.registerEscHandler({ final: "7" }, () => this.saveCursor()), this._parser.registerEscHandler({ final: "8" }, () => this.restoreCursor()), this._parser.registerEscHandler({ final: "D" }, () => this.index()), this._parser.registerEscHandler({ final: "E" }, () => this.nextLine()), this._parser.registerEscHandler({ final: "H" }, () => this.tabSet()), this._parser.registerEscHandler({ final: "M" }, () => this.reverseIndex()), this._parser.registerEscHandler({ final: "=" }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({ final: ">" }, () => this.keypadNumericMode()), this._parser.registerEscHandler({ final: "c" }, () => this.fullReset()), this._parser.registerEscHandler({ final: "n" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "o" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "|" }, () => this.setgLevel(3)), this._parser.registerEscHandler({ final: "}" }, () => this.setgLevel(2)), this._parser.registerEscHandler({ final: "~" }, () => this.setgLevel(1)), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, () => this.selectDefaultCharset());
          for (let S6 in d5.CHARSETS)
            this._parser.registerEscHandler({ intermediates: "(", final: S6 }, () => this.selectCharset("(" + S6)), this._parser.registerEscHandler({ intermediates: ")", final: S6 }, () => this.selectCharset(")" + S6)), this._parser.registerEscHandler({ intermediates: "*", final: S6 }, () => this.selectCharset("*" + S6)), this._parser.registerEscHandler({ intermediates: "+", final: S6 }, () => this.selectCharset("+" + S6)), this._parser.registerEscHandler({ intermediates: "-", final: S6 }, () => this.selectCharset("-" + S6)), this._parser.registerEscHandler({ intermediates: ".", final: S6 }, () => this.selectCharset("." + S6)), this._parser.registerEscHandler({ intermediates: "/", final: S6 }, () => this.selectCharset("/" + S6));
          this._parser.registerEscHandler({ intermediates: "#", final: "8" }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((S6) => (this._logService.error("Parsing error: ", S6), S6)), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new m6.DcsHandler((S6, R4) => this.requestStatusString(S6, R4)));
        }
        _preserveStack(C5, w4, E5, D5) {
          this._parseStack.paused = true, this._parseStack.cursorStartX = C5, this._parseStack.cursorStartY = w4, this._parseStack.decodedLength = E5, this._parseStack.position = D5;
        }
        _logSlowResolvingAsync(C5) {
          this._logService.logLevel <= c3.LogLevelEnum.WARN && Promise.race([C5, new Promise((w4, E5) => setTimeout(() => E5("#SLOW_TIMEOUT"), 5e3))]).catch((w4) => {
            if (w4 !== "#SLOW_TIMEOUT")
              throw w4;
            console.warn("async parser handler taking longer than 5000 ms");
          });
        }
        _getCurrentLinkId() {
          return this._curAttrData.extended.urlId;
        }
        parse(C5, w4) {
          let E5, D5 = this._activeBuffer.x, I7 = this._activeBuffer.y, H4 = 0, U4 = this._parseStack.paused;
          if (U4) {
            if (E5 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, w4))
              return this._logSlowResolvingAsync(E5), E5;
            D5 = this._parseStack.cursorStartX, I7 = this._parseStack.cursorStartY, this._parseStack.paused = false, C5.length > b5 && (H4 = this._parseStack.position + b5);
          }
          if (this._logService.logLevel <= c3.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + (typeof C5 == "string" ? ` "${C5}"` : ` "${Array.prototype.map.call(C5, (W5) => String.fromCharCode(W5)).join("")}"`), typeof C5 == "string" ? C5.split("").map((W5) => W5.charCodeAt(0)) : C5), this._parseBuffer.length < C5.length && this._parseBuffer.length < b5 && (this._parseBuffer = new Uint32Array(Math.min(C5.length, b5))), U4 || this._dirtyRowTracker.clearRange(), C5.length > b5)
            for (let W5 = H4; W5 < C5.length; W5 += b5) {
              let q6 = W5 + b5 < C5.length ? W5 + b5 : C5.length, S6 = typeof C5 == "string" ? this._stringDecoder.decode(C5.substring(W5, q6), this._parseBuffer) : this._utf8Decoder.decode(C5.subarray(W5, q6), this._parseBuffer);
              if (E5 = this._parser.parse(this._parseBuffer, S6))
                return this._preserveStack(D5, I7, S6, W5), this._logSlowResolvingAsync(E5), E5;
            }
          else if (!U4) {
            let W5 = typeof C5 == "string" ? this._stringDecoder.decode(C5, this._parseBuffer) : this._utf8Decoder.decode(C5, this._parseBuffer);
            if (E5 = this._parser.parse(this._parseBuffer, W5))
              return this._preserveStack(D5, I7, W5, 0), this._logSlowResolvingAsync(E5), E5;
          }
          this._activeBuffer.x === D5 && this._activeBuffer.y === I7 || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowTracker.start, this._dirtyRowTracker.end);
        }
        print(C5, w4, E5) {
          let D5, I7, H4 = this._charsetService.charset, U4 = this._optionsService.rawOptions.screenReaderMode, W5 = this._bufferService.cols, q6 = this._coreService.decPrivateModes.wraparound, S6 = this._coreService.modes.insertMode, R4 = this._curAttrData, B4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && E5 - w4 > 0 && B4.getWidth(this._activeBuffer.x - 1) === 2 && B4.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, R4.fg, R4.bg, R4.extended);
          for (let A5 = w4; A5 < E5; ++A5) {
            if (D5 = C5[A5], I7 = this._unicodeService.wcwidth(D5), D5 < 127 && H4) {
              let N6 = H4[String.fromCharCode(D5)];
              N6 && (D5 = N6.charCodeAt(0));
            }
            if (U4 && this._onA11yChar.fire((0, _5.stringFromCodePoint)(D5)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), I7 || !this._activeBuffer.x) {
              if (this._activeBuffer.x + I7 - 1 >= W5) {
                if (q6) {
                  for (; this._activeBuffer.x < W5; )
                    B4.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, R4.fg, R4.bg, R4.extended);
                  this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), B4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                } else if (this._activeBuffer.x = W5 - 1, I7 === 2)
                  continue;
              }
              if (S6 && (B4.insertCells(this._activeBuffer.x, I7, this._activeBuffer.getNullCell(R4), R4), B4.getWidth(W5 - 1) === 2 && B4.setCellFromCodePoint(W5 - 1, t.NULL_CELL_CODE, t.NULL_CELL_WIDTH, R4.fg, R4.bg, R4.extended)), B4.setCellFromCodePoint(this._activeBuffer.x++, D5, I7, R4.fg, R4.bg, R4.extended), I7 > 0)
                for (; --I7; )
                  B4.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, R4.fg, R4.bg, R4.extended);
            } else
              B4.getWidth(this._activeBuffer.x - 1) ? B4.addCodepointToCell(this._activeBuffer.x - 1, D5) : B4.addCodepointToCell(this._activeBuffer.x - 2, D5);
          }
          E5 - w4 > 0 && (B4.loadCell(this._activeBuffer.x - 1, this._workCell), this._workCell.getWidth() === 2 || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < W5 && E5 - w4 > 0 && B4.getWidth(this._activeBuffer.x) === 0 && !B4.hasContent(this._activeBuffer.x) && B4.setCellFromCodePoint(this._activeBuffer.x, 0, 1, R4.fg, R4.bg, R4.extended), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        registerCsiHandler(C5, w4) {
          return C5.final !== "t" || C5.prefix || C5.intermediates ? this._parser.registerCsiHandler(C5, w4) : this._parser.registerCsiHandler(C5, (E5) => !L5(E5.params[0], this._optionsService.rawOptions.windowOptions) || w4(E5));
        }
        registerDcsHandler(C5, w4) {
          return this._parser.registerDcsHandler(C5, new m6.DcsHandler(w4));
        }
        registerEscHandler(C5, w4) {
          return this._parser.registerEscHandler(C5, w4);
        }
        registerOscHandler(C5, w4) {
          return this._parser.registerOscHandler(C5, new v5.OscHandler(w4));
        }
        bell() {
          return this._onRequestBell.fire(), true;
        }
        lineFeed() {
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
        }
        carriageReturn() {
          return this._activeBuffer.x = 0, true;
        }
        backspace() {
          var C5;
          if (!this._coreService.decPrivateModes.reverseWraparound)
            return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
          if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0)
            this._activeBuffer.x--;
          else if (this._activeBuffer.x === 0 && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (!((C5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) === null || C5 === void 0) && C5.isWrapped)) {
            this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
            let w4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            w4.hasWidth(this._activeBuffer.x) && !w4.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
          }
          return this._restrictCursor(), true;
        }
        tab() {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          let C5 = this._activeBuffer.x;
          return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - C5), true;
        }
        shiftOut() {
          return this._charsetService.setgLevel(1), true;
        }
        shiftIn() {
          return this._charsetService.setgLevel(0), true;
        }
        _restrictCursor(C5 = this._bufferService.cols - 1) {
          this._activeBuffer.x = Math.min(C5, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _setCursor(C5, w4) {
          this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = C5, this._activeBuffer.y = this._activeBuffer.scrollTop + w4) : (this._activeBuffer.x = C5, this._activeBuffer.y = w4), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
        }
        _moveCursor(C5, w4) {
          this._restrictCursor(), this._setCursor(this._activeBuffer.x + C5, this._activeBuffer.y + w4);
        }
        cursorUp(C5) {
          let w4 = this._activeBuffer.y - this._activeBuffer.scrollTop;
          return w4 >= 0 ? this._moveCursor(0, -Math.min(w4, C5.params[0] || 1)) : this._moveCursor(0, -(C5.params[0] || 1)), true;
        }
        cursorDown(C5) {
          let w4 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
          return w4 >= 0 ? this._moveCursor(0, Math.min(w4, C5.params[0] || 1)) : this._moveCursor(0, C5.params[0] || 1), true;
        }
        cursorForward(C5) {
          return this._moveCursor(C5.params[0] || 1, 0), true;
        }
        cursorBackward(C5) {
          return this._moveCursor(-(C5.params[0] || 1), 0), true;
        }
        cursorNextLine(C5) {
          return this.cursorDown(C5), this._activeBuffer.x = 0, true;
        }
        cursorPrecedingLine(C5) {
          return this.cursorUp(C5), this._activeBuffer.x = 0, true;
        }
        cursorCharAbsolute(C5) {
          return this._setCursor((C5.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        cursorPosition(C5) {
          return this._setCursor(C5.length >= 2 ? (C5.params[1] || 1) - 1 : 0, (C5.params[0] || 1) - 1), true;
        }
        charPosAbsolute(C5) {
          return this._setCursor((C5.params[0] || 1) - 1, this._activeBuffer.y), true;
        }
        hPositionRelative(C5) {
          return this._moveCursor(C5.params[0] || 1, 0), true;
        }
        linePosAbsolute(C5) {
          return this._setCursor(this._activeBuffer.x, (C5.params[0] || 1) - 1), true;
        }
        vPositionRelative(C5) {
          return this._moveCursor(0, C5.params[0] || 1), true;
        }
        hVPosition(C5) {
          return this.cursorPosition(C5), true;
        }
        tabClear(C5) {
          let w4 = C5.params[0];
          return w4 === 0 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : w4 === 3 && (this._activeBuffer.tabs = {}), true;
        }
        cursorForwardTab(C5) {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          let w4 = C5.params[0] || 1;
          for (; w4--; )
            this._activeBuffer.x = this._activeBuffer.nextStop();
          return true;
        }
        cursorBackwardTab(C5) {
          if (this._activeBuffer.x >= this._bufferService.cols)
            return true;
          let w4 = C5.params[0] || 1;
          for (; w4--; )
            this._activeBuffer.x = this._activeBuffer.prevStop();
          return true;
        }
        selectProtected(C5) {
          let w4 = C5.params[0];
          return w4 === 1 && (this._curAttrData.bg |= 536870912), w4 !== 2 && w4 !== 0 || (this._curAttrData.bg &= -536870913), true;
        }
        _eraseInBufferLine(C5, w4, E5, D5 = false, I7 = false) {
          let H4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + C5);
          H4.replaceCells(w4, E5, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), I7), D5 && (H4.isWrapped = false);
        }
        _resetBufferLine(C5, w4 = false) {
          let E5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + C5);
          E5 && (E5.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), w4), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + C5), E5.isWrapped = false);
        }
        eraseInDisplay(C5, w4 = false) {
          let E5;
          switch (this._restrictCursor(this._bufferService.cols), C5.params[0]) {
            case 0:
              for (E5 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(E5), this._eraseInBufferLine(E5++, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, w4); E5 < this._bufferService.rows; E5++)
                this._resetBufferLine(E5, w4);
              this._dirtyRowTracker.markDirty(E5);
              break;
            case 1:
              for (E5 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(E5), this._eraseInBufferLine(E5, 0, this._activeBuffer.x + 1, true, w4), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(E5 + 1).isWrapped = false); E5--; )
                this._resetBufferLine(E5, w4);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 2:
              for (E5 = this._bufferService.rows, this._dirtyRowTracker.markDirty(E5 - 1); E5--; )
                this._resetBufferLine(E5, w4);
              this._dirtyRowTracker.markDirty(0);
              break;
            case 3:
              let D5 = this._activeBuffer.lines.length - this._bufferService.rows;
              D5 > 0 && (this._activeBuffer.lines.trimStart(D5), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - D5, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - D5, 0), this._onScroll.fire(0));
          }
          return true;
        }
        eraseInLine(C5, w4 = false) {
          switch (this._restrictCursor(this._bufferService.cols), C5.params[0]) {
            case 0:
              this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, this._activeBuffer.x === 0, w4);
              break;
            case 1:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, w4);
              break;
            case 2:
              this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, w4);
          }
          return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
        }
        insertLines(C5) {
          this._restrictCursor();
          let w4 = C5.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let E5 = this._activeBuffer.ybase + this._activeBuffer.y, D5 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, I7 = this._bufferService.rows - 1 + this._activeBuffer.ybase - D5 + 1;
          for (; w4--; )
            this._activeBuffer.lines.splice(I7 - 1, 1), this._activeBuffer.lines.splice(E5, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        deleteLines(C5) {
          this._restrictCursor();
          let w4 = C5.params[0] || 1;
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let E5 = this._activeBuffer.ybase + this._activeBuffer.y, D5;
          for (D5 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, D5 = this._bufferService.rows - 1 + this._activeBuffer.ybase - D5; w4--; )
            this._activeBuffer.lines.splice(E5, 1), this._activeBuffer.lines.splice(D5, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
        }
        insertChars(C5) {
          this._restrictCursor();
          let w4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return w4 && (w4.insertCells(this._activeBuffer.x, C5.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        deleteChars(C5) {
          this._restrictCursor();
          let w4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return w4 && (w4.deleteCells(this._activeBuffer.x, C5.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        scrollUp(C5) {
          let w4 = C5.params[0] || 1;
          for (; w4--; )
            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollDown(C5) {
          let w4 = C5.params[0] || 1;
          for (; w4--; )
            this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(e.DEFAULT_ATTR_DATA));
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollLeft(C5) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let w4 = C5.params[0] || 1;
          for (let E5 = this._activeBuffer.scrollTop; E5 <= this._activeBuffer.scrollBottom; ++E5) {
            let D5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + E5);
            D5.deleteCells(0, w4, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D5.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        scrollRight(C5) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let w4 = C5.params[0] || 1;
          for (let E5 = this._activeBuffer.scrollTop; E5 <= this._activeBuffer.scrollBottom; ++E5) {
            let D5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + E5);
            D5.insertCells(0, w4, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D5.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        insertColumns(C5) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let w4 = C5.params[0] || 1;
          for (let E5 = this._activeBuffer.scrollTop; E5 <= this._activeBuffer.scrollBottom; ++E5) {
            let D5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + E5);
            D5.insertCells(this._activeBuffer.x, w4, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D5.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        deleteColumns(C5) {
          if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop)
            return true;
          let w4 = C5.params[0] || 1;
          for (let E5 = this._activeBuffer.scrollTop; E5 <= this._activeBuffer.scrollBottom; ++E5) {
            let D5 = this._activeBuffer.lines.get(this._activeBuffer.ybase + E5);
            D5.deleteCells(this._activeBuffer.x, w4, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), D5.isWrapped = false;
          }
          return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
        }
        eraseChars(C5) {
          this._restrictCursor();
          let w4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
          return w4 && (w4.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (C5.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
        }
        repeatPrecedingCharacter(C5) {
          if (!this._parser.precedingCodepoint)
            return true;
          let w4 = C5.params[0] || 1, E5 = new Uint32Array(w4);
          for (let D5 = 0; D5 < w4; ++D5)
            E5[D5] = this._parser.precedingCodepoint;
          return this.print(E5, 0, E5.length), true;
        }
        sendDeviceAttributesPrimary(C5) {
          return C5.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n3.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n3.C0.ESC + "[?6c")), true;
        }
        sendDeviceAttributesSecondary(C5) {
          return C5.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n3.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n3.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(C5.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n3.C0.ESC + "[>83;40003;0c")), true;
        }
        _is(C5) {
          return (this._optionsService.rawOptions.termName + "").indexOf(C5) === 0;
        }
        setMode(C5) {
          for (let w4 = 0; w4 < C5.length; w4++)
            switch (C5.params[w4]) {
              case 4:
                this._coreService.modes.insertMode = true;
                break;
              case 20:
                this._optionsService.options.convertEol = true;
            }
          return true;
        }
        setModePrivate(C5) {
          for (let w4 = 0; w4 < C5.length; w4++)
            switch (C5.params[w4]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = true;
                break;
              case 2:
                this._charsetService.setgCharset(0, d5.DEFAULT_CHARSET), this._charsetService.setgCharset(1, d5.DEFAULT_CHARSET), this._charsetService.setgCharset(2, d5.DEFAULT_CHARSET), this._charsetService.setgCharset(3, d5.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = true;
                break;
              case 12:
                this._optionsService.options.cursorBlink = true;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = true;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = false;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = true;
            }
          return true;
        }
        resetMode(C5) {
          for (let w4 = 0; w4 < C5.length; w4++)
            switch (C5.params[w4]) {
              case 4:
                this._coreService.modes.insertMode = false;
                break;
              case 20:
                this._optionsService.options.convertEol = false;
            }
          return true;
        }
        resetModePrivate(C5) {
          for (let w4 = 0; w4 < C5.length; w4++)
            switch (C5.params[w4]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = false;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = false;
                break;
              case 12:
                this._optionsService.options.cursorBlink = false;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = false;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = false;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = true;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), C5.params[w4] === 1049 && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = false;
            }
          return true;
        }
        requestMode(C5, w4) {
          let E5 = this._coreService.decPrivateModes, { activeProtocol: D5, activeEncoding: I7 } = this._coreMouseService, H4 = this._coreService, { buffers: U4, cols: W5 } = this._bufferService, { active: q6, alt: S6 } = U4, R4 = this._optionsService.rawOptions, B4 = (j7) => j7 ? 1 : 2, A5 = C5.params[0];
          return N6 = A5, F7 = w4 ? A5 === 2 ? 4 : A5 === 4 ? B4(H4.modes.insertMode) : A5 === 12 ? 3 : A5 === 20 ? B4(R4.convertEol) : 0 : A5 === 1 ? B4(E5.applicationCursorKeys) : A5 === 3 ? R4.windowOptions.setWinLines ? W5 === 80 ? 2 : W5 === 132 ? 1 : 0 : 0 : A5 === 6 ? B4(E5.origin) : A5 === 7 ? B4(E5.wraparound) : A5 === 8 ? 3 : A5 === 9 ? B4(D5 === "X10") : A5 === 12 ? B4(R4.cursorBlink) : A5 === 25 ? B4(!H4.isCursorHidden) : A5 === 45 ? B4(E5.reverseWraparound) : A5 === 66 ? B4(E5.applicationKeypad) : A5 === 67 ? 4 : A5 === 1e3 ? B4(D5 === "VT200") : A5 === 1002 ? B4(D5 === "DRAG") : A5 === 1003 ? B4(D5 === "ANY") : A5 === 1004 ? B4(E5.sendFocus) : A5 === 1005 ? 4 : A5 === 1006 ? B4(I7 === "SGR") : A5 === 1015 ? 4 : A5 === 1016 ? B4(I7 === "SGR_PIXELS") : A5 === 1048 ? 1 : A5 === 47 || A5 === 1047 || A5 === 1049 ? B4(q6 === S6) : A5 === 2004 ? B4(E5.bracketedPasteMode) : 0, H4.triggerDataEvent(`${n3.C0.ESC}[${w4 ? "" : "?"}${N6};${F7}$y`), true;
          var N6, F7;
        }
        _updateAttrColor(C5, w4, E5, D5, I7) {
          return w4 === 2 ? (C5 |= 50331648, C5 &= -16777216, C5 |= o3.AttributeData.fromColorRGB([E5, D5, I7])) : w4 === 5 && (C5 &= -50331904, C5 |= 33554432 | 255 & E5), C5;
        }
        _extractColor(C5, w4, E5) {
          let D5 = [0, 0, -1, 0, 0, 0], I7 = 0, H4 = 0;
          do {
            if (D5[H4 + I7] = C5.params[w4 + H4], C5.hasSubParams(w4 + H4)) {
              let U4 = C5.getSubParams(w4 + H4), W5 = 0;
              do
                D5[1] === 5 && (I7 = 1), D5[H4 + W5 + 1 + I7] = U4[W5];
              while (++W5 < U4.length && W5 + H4 + 1 + I7 < D5.length);
              break;
            }
            if (D5[1] === 5 && H4 + I7 >= 2 || D5[1] === 2 && H4 + I7 >= 5)
              break;
            D5[1] && (I7 = 1);
          } while (++H4 + w4 < C5.length && H4 + I7 < D5.length);
          for (let U4 = 2; U4 < D5.length; ++U4)
            D5[U4] === -1 && (D5[U4] = 0);
          switch (D5[0]) {
            case 38:
              E5.fg = this._updateAttrColor(E5.fg, D5[1], D5[3], D5[4], D5[5]);
              break;
            case 48:
              E5.bg = this._updateAttrColor(E5.bg, D5[1], D5[3], D5[4], D5[5]);
              break;
            case 58:
              E5.extended = E5.extended.clone(), E5.extended.underlineColor = this._updateAttrColor(E5.extended.underlineColor, D5[1], D5[3], D5[4], D5[5]);
          }
          return H4;
        }
        _processUnderline(C5, w4) {
          w4.extended = w4.extended.clone(), (!~C5 || C5 > 5) && (C5 = 1), w4.extended.underlineStyle = C5, w4.fg |= 268435456, C5 === 0 && (w4.fg &= -268435457), w4.updateExtended();
        }
        _processSGR0(C5) {
          C5.fg = e.DEFAULT_ATTR_DATA.fg, C5.bg = e.DEFAULT_ATTR_DATA.bg, C5.extended = C5.extended.clone(), C5.extended.underlineStyle = 0, C5.extended.underlineColor &= -67108864, C5.updateExtended();
        }
        charAttributes(C5) {
          if (C5.length === 1 && C5.params[0] === 0)
            return this._processSGR0(this._curAttrData), true;
          let w4 = C5.length, E5, D5 = this._curAttrData;
          for (let I7 = 0; I7 < w4; I7++)
            E5 = C5.params[I7], E5 >= 30 && E5 <= 37 ? (D5.fg &= -50331904, D5.fg |= 16777216 | E5 - 30) : E5 >= 40 && E5 <= 47 ? (D5.bg &= -50331904, D5.bg |= 16777216 | E5 - 40) : E5 >= 90 && E5 <= 97 ? (D5.fg &= -50331904, D5.fg |= 16777224 | E5 - 90) : E5 >= 100 && E5 <= 107 ? (D5.bg &= -50331904, D5.bg |= 16777224 | E5 - 100) : E5 === 0 ? this._processSGR0(D5) : E5 === 1 ? D5.fg |= 134217728 : E5 === 3 ? D5.bg |= 67108864 : E5 === 4 ? (D5.fg |= 268435456, this._processUnderline(C5.hasSubParams(I7) ? C5.getSubParams(I7)[0] : 1, D5)) : E5 === 5 ? D5.fg |= 536870912 : E5 === 7 ? D5.fg |= 67108864 : E5 === 8 ? D5.fg |= 1073741824 : E5 === 9 ? D5.fg |= 2147483648 : E5 === 2 ? D5.bg |= 134217728 : E5 === 21 ? this._processUnderline(2, D5) : E5 === 22 ? (D5.fg &= -134217729, D5.bg &= -134217729) : E5 === 23 ? D5.bg &= -67108865 : E5 === 24 ? (D5.fg &= -268435457, this._processUnderline(0, D5)) : E5 === 25 ? D5.fg &= -536870913 : E5 === 27 ? D5.fg &= -67108865 : E5 === 28 ? D5.fg &= -1073741825 : E5 === 29 ? D5.fg &= 2147483647 : E5 === 39 ? (D5.fg &= -67108864, D5.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg) : E5 === 49 ? (D5.bg &= -67108864, D5.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : E5 === 38 || E5 === 48 || E5 === 58 ? I7 += this._extractColor(C5, I7, D5) : E5 === 53 ? D5.bg |= 1073741824 : E5 === 55 ? D5.bg &= -1073741825 : E5 === 59 ? (D5.extended = D5.extended.clone(), D5.extended.underlineColor = -1, D5.updateExtended()) : E5 === 100 ? (D5.fg &= -67108864, D5.fg |= 16777215 & e.DEFAULT_ATTR_DATA.fg, D5.bg &= -67108864, D5.bg |= 16777215 & e.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", E5);
          return true;
        }
        deviceStatus(C5) {
          switch (C5.params[0]) {
            case 5:
              this._coreService.triggerDataEvent(`${n3.C0.ESC}[0n`);
              break;
            case 6:
              let w4 = this._activeBuffer.y + 1, E5 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n3.C0.ESC}[${w4};${E5}R`);
          }
          return true;
        }
        deviceStatusPrivate(C5) {
          if (C5.params[0] === 6) {
            let w4 = this._activeBuffer.y + 1, E5 = this._activeBuffer.x + 1;
            this._coreService.triggerDataEvent(`${n3.C0.ESC}[?${w4};${E5}R`);
          }
          return true;
        }
        softReset(C5) {
          return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
        }
        setCursorStyle(C5) {
          let w4 = C5.params[0] || 1;
          switch (w4) {
            case 1:
            case 2:
              this._optionsService.options.cursorStyle = "block";
              break;
            case 3:
            case 4:
              this._optionsService.options.cursorStyle = "underline";
              break;
            case 5:
            case 6:
              this._optionsService.options.cursorStyle = "bar";
          }
          let E5 = w4 % 2 == 1;
          return this._optionsService.options.cursorBlink = E5, true;
        }
        setScrollRegion(C5) {
          let w4 = C5.params[0] || 1, E5;
          return (C5.length < 2 || (E5 = C5.params[1]) > this._bufferService.rows || E5 === 0) && (E5 = this._bufferService.rows), E5 > w4 && (this._activeBuffer.scrollTop = w4 - 1, this._activeBuffer.scrollBottom = E5 - 1, this._setCursor(0, 0)), true;
        }
        windowOptions(C5) {
          if (!L5(C5.params[0], this._optionsService.rawOptions.windowOptions))
            return true;
          let w4 = C5.length > 1 ? C5.params[1] : 0;
          switch (C5.params[0]) {
            case 14:
              w4 !== 2 && this._onRequestWindowsOptionsReport.fire(y5.GET_WIN_SIZE_PIXELS);
              break;
            case 16:
              this._onRequestWindowsOptionsReport.fire(y5.GET_CELL_SIZE_PIXELS);
              break;
            case 18:
              this._bufferService && this._coreService.triggerDataEvent(`${n3.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
              break;
            case 22:
              w4 !== 0 && w4 !== 2 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), w4 !== 0 && w4 !== 1 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
              break;
            case 23:
              w4 !== 0 && w4 !== 2 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), w4 !== 0 && w4 !== 1 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
          }
          return true;
        }
        saveCursor(C5) {
          return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
        }
        restoreCursor(C5) {
          return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
        }
        setTitle(C5) {
          return this._windowTitle = C5, this._onTitleChange.fire(C5), true;
        }
        setIconName(C5) {
          return this._iconName = C5, true;
        }
        setOrReportIndexedColor(C5) {
          let w4 = [], E5 = C5.split(";");
          for (; E5.length > 1; ) {
            let D5 = E5.shift(), I7 = E5.shift();
            if (/^\d+$/.exec(D5)) {
              let H4 = parseInt(D5);
              if (O6(H4))
                if (I7 === "?")
                  w4.push({ type: 0, index: H4 });
                else {
                  let U4 = (0, h5.parseColor)(I7);
                  U4 && w4.push({ type: 1, index: H4, color: U4 });
                }
            }
          }
          return w4.length && this._onColor.fire(w4), true;
        }
        setHyperlink(C5) {
          let w4 = C5.split(";");
          return !(w4.length < 2) && (w4[1] ? this._createHyperlink(w4[0], w4[1]) : !w4[0] && this._finishHyperlink());
        }
        _createHyperlink(C5, w4) {
          this._getCurrentLinkId() && this._finishHyperlink();
          let E5 = C5.split(":"), D5, I7 = E5.findIndex((H4) => H4.startsWith("id="));
          return I7 !== -1 && (D5 = E5[I7].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: D5, uri: w4 }), this._curAttrData.updateExtended(), true;
        }
        _finishHyperlink() {
          return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
        }
        _setOrReportSpecialColor(C5, w4) {
          let E5 = C5.split(";");
          for (let D5 = 0; D5 < E5.length && !(w4 >= this._specialColors.length); ++D5, ++w4)
            if (E5[D5] === "?")
              this._onColor.fire([{ type: 0, index: this._specialColors[w4] }]);
            else {
              let I7 = (0, h5.parseColor)(E5[D5]);
              I7 && this._onColor.fire([{ type: 1, index: this._specialColors[w4], color: I7 }]);
            }
          return true;
        }
        setOrReportFgColor(C5) {
          return this._setOrReportSpecialColor(C5, 0);
        }
        setOrReportBgColor(C5) {
          return this._setOrReportSpecialColor(C5, 1);
        }
        setOrReportCursorColor(C5) {
          return this._setOrReportSpecialColor(C5, 2);
        }
        restoreIndexedColor(C5) {
          if (!C5)
            return this._onColor.fire([{ type: 2 }]), true;
          let w4 = [], E5 = C5.split(";");
          for (let D5 = 0; D5 < E5.length; ++D5)
            if (/^\d+$/.exec(E5[D5])) {
              let I7 = parseInt(E5[D5]);
              O6(I7) && w4.push({ type: 2, index: I7 });
            }
          return w4.length && this._onColor.fire(w4), true;
        }
        restoreFgColor(C5) {
          return this._onColor.fire([{ type: 2, index: 256 }]), true;
        }
        restoreBgColor(C5) {
          return this._onColor.fire([{ type: 2, index: 257 }]), true;
        }
        restoreCursorColor(C5) {
          return this._onColor.fire([{ type: 2, index: 258 }]), true;
        }
        nextLine() {
          return this._activeBuffer.x = 0, this.index(), true;
        }
        keypadApplicationMode() {
          return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
        }
        keypadNumericMode() {
          return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
        }
        selectDefaultCharset() {
          return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, d5.DEFAULT_CHARSET), true;
        }
        selectCharset(C5) {
          return C5.length !== 2 ? (this.selectDefaultCharset(), true) : (C5[0] === "/" || this._charsetService.setgCharset(g4[C5[0]], d5.CHARSETS[C5[1]] || d5.DEFAULT_CHARSET), true);
        }
        index() {
          return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
        }
        tabSet() {
          return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
        }
        reverseIndex() {
          if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
            let C5 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
            this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, C5, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
          } else
            this._activeBuffer.y--, this._restrictCursor();
          return true;
        }
        fullReset() {
          return this._parser.reset(), this._onRequestReset.fire(), true;
        }
        reset() {
          this._curAttrData = e.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = e.DEFAULT_ATTR_DATA.clone();
        }
        _eraseAttrData() {
          return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
        }
        setgLevel(C5) {
          return this._charsetService.setgLevel(C5), true;
        }
        screenAlignmentPattern() {
          let C5 = new i4.CellData();
          C5.content = 4194373, C5.fg = this._curAttrData.fg, C5.bg = this._curAttrData.bg, this._setCursor(0, 0);
          for (let w4 = 0; w4 < this._bufferService.rows; ++w4) {
            let E5 = this._activeBuffer.ybase + this._activeBuffer.y + w4, D5 = this._activeBuffer.lines.get(E5);
            D5 && (D5.fill(C5), D5.isWrapped = false);
          }
          return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
        }
        requestStatusString(C5, w4) {
          let E5 = this._bufferService.buffer, D5 = this._optionsService.rawOptions;
          return ((I7) => (this._coreService.triggerDataEvent(`${n3.C0.ESC}${I7}${n3.C0.ESC}\\`), true))(C5 === '"q' ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : C5 === '"p' ? 'P1$r61;1"p' : C5 === "r" ? `P1$r${E5.scrollTop + 1};${E5.scrollBottom + 1}r` : C5 === "m" ? "P1$r0m" : C5 === " q" ? `P1$r${{ block: 2, underline: 4, bar: 6 }[D5.cursorStyle] - (D5.cursorBlink ? 1 : 0)} q` : "P0$r");
        }
        markRangeDirty(C5, w4) {
          this._dirtyRowTracker.markRangeDirty(C5, w4);
        }
      }
      r.InputHandler = x5;
      let T6 = class {
        constructor(M5) {
          this._bufferService = M5, this.clearRange();
        }
        clearRange() {
          this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
        }
        markDirty(M5) {
          M5 < this.start ? this.start = M5 : M5 > this.end && (this.end = M5);
        }
        markRangeDirty(M5, C5) {
          M5 > C5 && (k4 = M5, M5 = C5, C5 = k4), M5 < this.start && (this.start = M5), C5 > this.end && (this.end = C5);
        }
        markAllDirty() {
          this.markRangeDirty(0, this._bufferService.rows - 1);
        }
      };
      function O6(M5) {
        return 0 <= M5 && M5 < 256;
      }
      T6 = l4([u3(0, c3.IBufferService)], T6);
    }, 844: (P7, r) => {
      function a2(l4) {
        for (let u3 of l4)
          u3.dispose();
        l4.length = 0;
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.getDisposeArrayDisposable = r.disposeArray = r.toDisposable = r.MutableDisposable = r.Disposable = void 0, r.Disposable = class {
        constructor() {
          this._disposables = [], this._isDisposed = false;
        }
        dispose() {
          this._isDisposed = true;
          for (let l4 of this._disposables)
            l4.dispose();
          this._disposables.length = 0;
        }
        register(l4) {
          return this._disposables.push(l4), l4;
        }
        unregister(l4) {
          let u3 = this._disposables.indexOf(l4);
          u3 !== -1 && this._disposables.splice(u3, 1);
        }
      }, r.MutableDisposable = class {
        constructor() {
          this._isDisposed = false;
        }
        get value() {
          return this._isDisposed ? void 0 : this._value;
        }
        set value(l4) {
          var u3;
          this._isDisposed || l4 === this._value || ((u3 = this._value) === null || u3 === void 0 || u3.dispose(), this._value = l4);
        }
        clear() {
          this.value = void 0;
        }
        dispose() {
          var l4;
          this._isDisposed = true, (l4 = this._value) === null || l4 === void 0 || l4.dispose(), this._value = void 0;
        }
      }, r.toDisposable = function(l4) {
        return { dispose: l4 };
      }, r.disposeArray = a2, r.getDisposeArrayDisposable = function(l4) {
        return { dispose: () => a2(l4) };
      };
    }, 1505: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.FourKeyMap = r.TwoKeyMap = void 0;
      class a2 {
        constructor() {
          this._data = {};
        }
        set(u3, n3, d5) {
          this._data[u3] || (this._data[u3] = {}), this._data[u3][n3] = d5;
        }
        get(u3, n3) {
          return this._data[u3] ? this._data[u3][n3] : void 0;
        }
        clear() {
          this._data = {};
        }
      }
      r.TwoKeyMap = a2, r.FourKeyMap = class {
        constructor() {
          this._data = new a2();
        }
        set(l4, u3, n3, d5, f4) {
          this._data.get(l4, u3) || this._data.set(l4, u3, new a2()), this._data.get(l4, u3).set(n3, d5, f4);
        }
        get(l4, u3, n3, d5) {
          var f4;
          return (f4 = this._data.get(l4, u3)) === null || f4 === void 0 ? void 0 : f4.get(n3, d5);
        }
        clear() {
          this._data.clear();
        }
      };
    }, 6114: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.isChromeOS = r.isLinux = r.isWindows = r.isIphone = r.isIpad = r.isMac = r.getSafariVersion = r.isSafari = r.isLegacyEdge = r.isFirefox = r.isNode = void 0, r.isNode = typeof navigator > "u";
      let a2 = r.isNode ? "node" : navigator.userAgent, l4 = r.isNode ? "node" : navigator.platform;
      r.isFirefox = a2.includes("Firefox"), r.isLegacyEdge = a2.includes("Edge"), r.isSafari = /^((?!chrome|android).)*safari/i.test(a2), r.getSafariVersion = function() {
        if (!r.isSafari)
          return 0;
        let u3 = a2.match(/Version\/(\d+)/);
        return u3 === null || u3.length < 2 ? 0 : parseInt(u3[1]);
      }, r.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(l4), r.isIpad = l4 === "iPad", r.isIphone = l4 === "iPhone", r.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(l4), r.isLinux = l4.indexOf("Linux") >= 0, r.isChromeOS = /\bCrOS\b/.test(a2);
    }, 6106: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.SortedList = void 0;
      let a2 = 0;
      r.SortedList = class {
        constructor(l4) {
          this._getKey = l4, this._array = [];
        }
        clear() {
          this._array.length = 0;
        }
        insert(l4) {
          this._array.length !== 0 ? (a2 = this._search(this._getKey(l4)), this._array.splice(a2, 0, l4)) : this._array.push(l4);
        }
        delete(l4) {
          if (this._array.length === 0)
            return false;
          let u3 = this._getKey(l4);
          if (u3 === void 0 || (a2 = this._search(u3), a2 === -1) || this._getKey(this._array[a2]) !== u3)
            return false;
          do
            if (this._array[a2] === l4)
              return this._array.splice(a2, 1), true;
          while (++a2 < this._array.length && this._getKey(this._array[a2]) === u3);
          return false;
        }
        *getKeyIterator(l4) {
          if (this._array.length !== 0 && (a2 = this._search(l4), !(a2 < 0 || a2 >= this._array.length) && this._getKey(this._array[a2]) === l4))
            do
              yield this._array[a2];
            while (++a2 < this._array.length && this._getKey(this._array[a2]) === l4);
        }
        forEachByKey(l4, u3) {
          if (this._array.length !== 0 && (a2 = this._search(l4), !(a2 < 0 || a2 >= this._array.length) && this._getKey(this._array[a2]) === l4))
            do
              u3(this._array[a2]);
            while (++a2 < this._array.length && this._getKey(this._array[a2]) === l4);
        }
        values() {
          return [...this._array].values();
        }
        _search(l4) {
          let u3 = 0, n3 = this._array.length - 1;
          for (; n3 >= u3; ) {
            let d5 = u3 + n3 >> 1, f4 = this._getKey(this._array[d5]);
            if (f4 > l4)
              n3 = d5 - 1;
            else {
              if (!(f4 < l4)) {
                for (; d5 > 0 && this._getKey(this._array[d5 - 1]) === l4; )
                  d5--;
                return d5;
              }
              u3 = d5 + 1;
            }
          }
          return u3;
        }
      };
    }, 7226: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.DebouncedIdleTask = r.IdleTaskQueue = r.PriorityTaskQueue = void 0;
      let l4 = a2(6114);
      class u3 {
        constructor() {
          this._tasks = [], this._i = 0;
        }
        enqueue(f4) {
          this._tasks.push(f4), this._start();
        }
        flush() {
          for (; this._i < this._tasks.length; )
            this._tasks[this._i]() || this._i++;
          this.clear();
        }
        clear() {
          this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
        }
        _start() {
          this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
        }
        _process(f4) {
          this._idleCallback = void 0;
          let p6 = 0, _5 = 0, e = f4.timeRemaining(), s2 = 0;
          for (; this._i < this._tasks.length; ) {
            if (p6 = Date.now(), this._tasks[this._i]() || this._i++, p6 = Math.max(1, Date.now() - p6), _5 = Math.max(p6, _5), s2 = f4.timeRemaining(), 1.5 * _5 > s2)
              return e - p6 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(e - p6))}ms`), void this._start();
            e = s2;
          }
          this.clear();
        }
      }
      class n3 extends u3 {
        _requestCallback(f4) {
          return setTimeout(() => f4(this._createDeadline(16)));
        }
        _cancelCallback(f4) {
          clearTimeout(f4);
        }
        _createDeadline(f4) {
          let p6 = Date.now() + f4;
          return { timeRemaining: () => Math.max(0, p6 - Date.now()) };
        }
      }
      r.PriorityTaskQueue = n3, r.IdleTaskQueue = !l4.isNode && "requestIdleCallback" in window ? class extends u3 {
        _requestCallback(d5) {
          return requestIdleCallback(d5);
        }
        _cancelCallback(d5) {
          cancelIdleCallback(d5);
        }
      } : n3, r.DebouncedIdleTask = class {
        constructor() {
          this._queue = new r.IdleTaskQueue();
        }
        set(d5) {
          this._queue.clear(), this._queue.enqueue(d5);
        }
        flush() {
          this._queue.flush();
        }
      };
    }, 9282: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.updateWindowsModeWrappedState = void 0;
      let l4 = a2(643);
      r.updateWindowsModeWrappedState = function(u3) {
        let n3 = u3.buffer.lines.get(u3.buffer.ybase + u3.buffer.y - 1), d5 = n3?.get(u3.cols - 1), f4 = u3.buffer.lines.get(u3.buffer.ybase + u3.buffer.y);
        f4 && d5 && (f4.isWrapped = d5[l4.CHAR_DATA_CODE_INDEX] !== l4.NULL_CELL_CODE && d5[l4.CHAR_DATA_CODE_INDEX] !== l4.WHITESPACE_CELL_CODE);
      };
    }, 3734: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.ExtendedAttrs = r.AttributeData = void 0;
      class a2 {
        constructor() {
          this.fg = 0, this.bg = 0, this.extended = new l4();
        }
        static toColorRGB(n3) {
          return [n3 >>> 16 & 255, n3 >>> 8 & 255, 255 & n3];
        }
        static fromColorRGB(n3) {
          return (255 & n3[0]) << 16 | (255 & n3[1]) << 8 | 255 & n3[2];
        }
        clone() {
          let n3 = new a2();
          return n3.fg = this.fg, n3.bg = this.bg, n3.extended = this.extended.clone(), n3;
        }
        isInverse() {
          return 67108864 & this.fg;
        }
        isBold() {
          return 134217728 & this.fg;
        }
        isUnderline() {
          return this.hasExtendedAttrs() && this.extended.underlineStyle !== 0 ? 1 : 268435456 & this.fg;
        }
        isBlink() {
          return 536870912 & this.fg;
        }
        isInvisible() {
          return 1073741824 & this.fg;
        }
        isItalic() {
          return 67108864 & this.bg;
        }
        isDim() {
          return 134217728 & this.bg;
        }
        isStrikethrough() {
          return 2147483648 & this.fg;
        }
        isProtected() {
          return 536870912 & this.bg;
        }
        isOverline() {
          return 1073741824 & this.bg;
        }
        getFgColorMode() {
          return 50331648 & this.fg;
        }
        getBgColorMode() {
          return 50331648 & this.bg;
        }
        isFgRGB() {
          return (50331648 & this.fg) == 50331648;
        }
        isBgRGB() {
          return (50331648 & this.bg) == 50331648;
        }
        isFgPalette() {
          return (50331648 & this.fg) == 16777216 || (50331648 & this.fg) == 33554432;
        }
        isBgPalette() {
          return (50331648 & this.bg) == 16777216 || (50331648 & this.bg) == 33554432;
        }
        isFgDefault() {
          return (50331648 & this.fg) == 0;
        }
        isBgDefault() {
          return (50331648 & this.bg) == 0;
        }
        isAttributeDefault() {
          return this.fg === 0 && this.bg === 0;
        }
        getFgColor() {
          switch (50331648 & this.fg) {
            case 16777216:
            case 33554432:
              return 255 & this.fg;
            case 50331648:
              return 16777215 & this.fg;
            default:
              return -1;
          }
        }
        getBgColor() {
          switch (50331648 & this.bg) {
            case 16777216:
            case 33554432:
              return 255 & this.bg;
            case 50331648:
              return 16777215 & this.bg;
            default:
              return -1;
          }
        }
        hasExtendedAttrs() {
          return 268435456 & this.bg;
        }
        updateExtended() {
          this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
        }
        getUnderlineColor() {
          if (268435456 & this.bg && ~this.extended.underlineColor)
            switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
          return this.getFgColor();
        }
        getUnderlineColorMode() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
        }
        isUnderlineColorRGB() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 50331648 : this.isFgRGB();
        }
        isUnderlineColorPalette() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 16777216 || (50331648 & this.extended.underlineColor) == 33554432 : this.isFgPalette();
        }
        isUnderlineColorDefault() {
          return 268435456 & this.bg && ~this.extended.underlineColor ? (50331648 & this.extended.underlineColor) == 0 : this.isFgDefault();
        }
        getUnderlineStyle() {
          return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
        }
      }
      r.AttributeData = a2;
      class l4 {
        get ext() {
          return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
        }
        set ext(n3) {
          this._ext = n3;
        }
        get underlineStyle() {
          return this._urlId ? 5 : (469762048 & this._ext) >> 26;
        }
        set underlineStyle(n3) {
          this._ext &= -469762049, this._ext |= n3 << 26 & 469762048;
        }
        get underlineColor() {
          return 67108863 & this._ext;
        }
        set underlineColor(n3) {
          this._ext &= -67108864, this._ext |= 67108863 & n3;
        }
        get urlId() {
          return this._urlId;
        }
        set urlId(n3) {
          this._urlId = n3;
        }
        constructor(n3 = 0, d5 = 0) {
          this._ext = 0, this._urlId = 0, this._ext = n3, this._urlId = d5;
        }
        clone() {
          return new l4(this._ext, this._urlId);
        }
        isEmpty() {
          return this.underlineStyle === 0 && this._urlId === 0;
        }
      }
      r.ExtendedAttrs = l4;
    }, 9092: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.Buffer = r.MAX_BUFFER_SIZE = void 0;
      let l4 = a2(6349), u3 = a2(7226), n3 = a2(3734), d5 = a2(8437), f4 = a2(4634), p6 = a2(511), _5 = a2(643), e = a2(4863), s2 = a2(7116);
      r.MAX_BUFFER_SIZE = 4294967295, r.Buffer = class {
        constructor(t, i4, o3) {
          this._hasScrollback = t, this._optionsService = i4, this._bufferService = o3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = d5.DEFAULT_ATTR_DATA.clone(), this.savedCharset = s2.DEFAULT_CHARSET, this.markers = [], this._nullCell = p6.CellData.fromCharData([0, _5.NULL_CELL_CHAR, _5.NULL_CELL_WIDTH, _5.NULL_CELL_CODE]), this._whitespaceCell = p6.CellData.fromCharData([0, _5.WHITESPACE_CELL_CHAR, _5.WHITESPACE_CELL_WIDTH, _5.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new u3.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new l4.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        getNullCell(t) {
          return t ? (this._nullCell.fg = t.fg, this._nullCell.bg = t.bg, this._nullCell.extended = t.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n3.ExtendedAttrs()), this._nullCell;
        }
        getWhitespaceCell(t) {
          return t ? (this._whitespaceCell.fg = t.fg, this._whitespaceCell.bg = t.bg, this._whitespaceCell.extended = t.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n3.ExtendedAttrs()), this._whitespaceCell;
        }
        getBlankLine(t, i4) {
          return new d5.BufferLine(this._bufferService.cols, this.getNullCell(t), i4);
        }
        get hasScrollback() {
          return this._hasScrollback && this.lines.maxLength > this._rows;
        }
        get isCursorInViewport() {
          let t = this.ybase + this.y - this.ydisp;
          return t >= 0 && t < this._rows;
        }
        _getCorrectBufferLength(t) {
          if (!this._hasScrollback)
            return t;
          let i4 = t + this._optionsService.rawOptions.scrollback;
          return i4 > r.MAX_BUFFER_SIZE ? r.MAX_BUFFER_SIZE : i4;
        }
        fillViewportRows(t) {
          if (this.lines.length === 0) {
            t === void 0 && (t = d5.DEFAULT_ATTR_DATA);
            let i4 = this._rows;
            for (; i4--; )
              this.lines.push(this.getBlankLine(t));
          }
        }
        clear() {
          this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new l4.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
        }
        resize(t, i4) {
          let o3 = this.getNullCell(d5.DEFAULT_ATTR_DATA), c3 = 0, v5 = this._getCorrectBufferLength(i4);
          if (v5 > this.lines.maxLength && (this.lines.maxLength = v5), this.lines.length > 0) {
            if (this._cols < t)
              for (let h5 = 0; h5 < this.lines.length; h5++)
                c3 += +this.lines.get(h5).resize(t, o3);
            let m6 = 0;
            if (this._rows < i4)
              for (let h5 = this._rows; h5 < i4; h5++)
                this.lines.length < i4 + this.ybase && (this._optionsService.rawOptions.windowsMode || this._optionsService.rawOptions.windowsPty.backend !== void 0 || this._optionsService.rawOptions.windowsPty.buildNumber !== void 0 ? this.lines.push(new d5.BufferLine(t, o3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + m6 + 1 ? (this.ybase--, m6++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new d5.BufferLine(t, o3)));
            else
              for (let h5 = this._rows; h5 > i4; h5--)
                this.lines.length > i4 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
            if (v5 < this.lines.maxLength) {
              let h5 = this.lines.length - v5;
              h5 > 0 && (this.lines.trimStart(h5), this.ybase = Math.max(this.ybase - h5, 0), this.ydisp = Math.max(this.ydisp - h5, 0), this.savedY = Math.max(this.savedY - h5, 0)), this.lines.maxLength = v5;
            }
            this.x = Math.min(this.x, t - 1), this.y = Math.min(this.y, i4 - 1), m6 && (this.y += m6), this.savedX = Math.min(this.savedX, t - 1), this.scrollTop = 0;
          }
          if (this.scrollBottom = i4 - 1, this._isReflowEnabled && (this._reflow(t, i4), this._cols > t))
            for (let m6 = 0; m6 < this.lines.length; m6++)
              c3 += +this.lines.get(m6).resize(t, o3);
          this._cols = t, this._rows = i4, this._memoryCleanupQueue.clear(), c3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
        }
        _batchedMemoryCleanup() {
          let t = true;
          this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, t = false);
          let i4 = 0;
          for (; this._memoryCleanupPosition < this.lines.length; )
            if (i4 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), i4 > 100)
              return true;
          return t;
        }
        get _isReflowEnabled() {
          let t = this._optionsService.rawOptions.windowsPty;
          return t && t.buildNumber ? this._hasScrollback && t.backend === "conpty" && t.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
        }
        _reflow(t, i4) {
          this._cols !== t && (t > this._cols ? this._reflowLarger(t, i4) : this._reflowSmaller(t, i4));
        }
        _reflowLarger(t, i4) {
          let o3 = (0, f4.reflowLargerGetLinesToRemove)(this.lines, this._cols, t, this.ybase + this.y, this.getNullCell(d5.DEFAULT_ATTR_DATA));
          if (o3.length > 0) {
            let c3 = (0, f4.reflowLargerCreateNewLayout)(this.lines, o3);
            (0, f4.reflowLargerApplyNewLayout)(this.lines, c3.layout), this._reflowLargerAdjustViewport(t, i4, c3.countRemoved);
          }
        }
        _reflowLargerAdjustViewport(t, i4, o3) {
          let c3 = this.getNullCell(d5.DEFAULT_ATTR_DATA), v5 = o3;
          for (; v5-- > 0; )
            this.ybase === 0 ? (this.y > 0 && this.y--, this.lines.length < i4 && this.lines.push(new d5.BufferLine(t, c3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
          this.savedY = Math.max(this.savedY - o3, 0);
        }
        _reflowSmaller(t, i4) {
          let o3 = this.getNullCell(d5.DEFAULT_ATTR_DATA), c3 = [], v5 = 0;
          for (let m6 = this.lines.length - 1; m6 >= 0; m6--) {
            let h5 = this.lines.get(m6);
            if (!h5 || !h5.isWrapped && h5.getTrimmedLength() <= t)
              continue;
            let g4 = [h5];
            for (; h5.isWrapped && m6 > 0; )
              h5 = this.lines.get(--m6), g4.unshift(h5);
            let b5 = this.ybase + this.y;
            if (b5 >= m6 && b5 < m6 + g4.length)
              continue;
            let L5 = g4[g4.length - 1].getTrimmedLength(), y5 = (0, f4.reflowSmallerGetNewLineLengths)(g4, this._cols, t), k4 = y5.length - g4.length, x5;
            x5 = this.ybase === 0 && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + k4) : Math.max(0, this.lines.length - this.lines.maxLength + k4);
            let T6 = [];
            for (let D5 = 0; D5 < k4; D5++) {
              let I7 = this.getBlankLine(d5.DEFAULT_ATTR_DATA, true);
              T6.push(I7);
            }
            T6.length > 0 && (c3.push({ start: m6 + g4.length + v5, newLines: T6 }), v5 += T6.length), g4.push(...T6);
            let O6 = y5.length - 1, M5 = y5[O6];
            M5 === 0 && (O6--, M5 = y5[O6]);
            let C5 = g4.length - k4 - 1, w4 = L5;
            for (; C5 >= 0; ) {
              let D5 = Math.min(w4, M5);
              if (g4[O6] === void 0)
                break;
              if (g4[O6].copyCellsFrom(g4[C5], w4 - D5, M5 - D5, D5, true), M5 -= D5, M5 === 0 && (O6--, M5 = y5[O6]), w4 -= D5, w4 === 0) {
                C5--;
                let I7 = Math.max(C5, 0);
                w4 = (0, f4.getWrappedLineTrimmedLength)(g4, I7, this._cols);
              }
            }
            for (let D5 = 0; D5 < g4.length; D5++)
              y5[D5] < t && g4[D5].setCell(y5[D5], o3);
            let E5 = k4 - x5;
            for (; E5-- > 0; )
              this.ybase === 0 ? this.y < i4 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + v5) - i4 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
            this.savedY = Math.min(this.savedY + k4, this.ybase + i4 - 1);
          }
          if (c3.length > 0) {
            let m6 = [], h5 = [];
            for (let O6 = 0; O6 < this.lines.length; O6++)
              h5.push(this.lines.get(O6));
            let g4 = this.lines.length, b5 = g4 - 1, L5 = 0, y5 = c3[L5];
            this.lines.length = Math.min(this.lines.maxLength, this.lines.length + v5);
            let k4 = 0;
            for (let O6 = Math.min(this.lines.maxLength - 1, g4 + v5 - 1); O6 >= 0; O6--)
              if (y5 && y5.start > b5 + k4) {
                for (let M5 = y5.newLines.length - 1; M5 >= 0; M5--)
                  this.lines.set(O6--, y5.newLines[M5]);
                O6++, m6.push({ index: b5 + 1, amount: y5.newLines.length }), k4 += y5.newLines.length, y5 = c3[++L5];
              } else
                this.lines.set(O6, h5[b5--]);
            let x5 = 0;
            for (let O6 = m6.length - 1; O6 >= 0; O6--)
              m6[O6].index += x5, this.lines.onInsertEmitter.fire(m6[O6]), x5 += m6[O6].amount;
            let T6 = Math.max(0, g4 + v5 - this.lines.maxLength);
            T6 > 0 && this.lines.onTrimEmitter.fire(T6);
          }
        }
        translateBufferLineToString(t, i4, o3 = 0, c3) {
          let v5 = this.lines.get(t);
          return v5 ? v5.translateToString(i4, o3, c3) : "";
        }
        getWrappedRangeForLine(t) {
          let i4 = t, o3 = t;
          for (; i4 > 0 && this.lines.get(i4).isWrapped; )
            i4--;
          for (; o3 + 1 < this.lines.length && this.lines.get(o3 + 1).isWrapped; )
            o3++;
          return { first: i4, last: o3 };
        }
        setupTabStops(t) {
          for (t != null ? this.tabs[t] || (t = this.prevStop(t)) : (this.tabs = {}, t = 0); t < this._cols; t += this._optionsService.rawOptions.tabStopWidth)
            this.tabs[t] = true;
        }
        prevStop(t) {
          for (t == null && (t = this.x); !this.tabs[--t] && t > 0; )
            ;
          return t >= this._cols ? this._cols - 1 : t < 0 ? 0 : t;
        }
        nextStop(t) {
          for (t == null && (t = this.x); !this.tabs[++t] && t < this._cols; )
            ;
          return t >= this._cols ? this._cols - 1 : t < 0 ? 0 : t;
        }
        clearMarkers(t) {
          this._isClearing = true;
          for (let i4 = 0; i4 < this.markers.length; i4++)
            this.markers[i4].line === t && (this.markers[i4].dispose(), this.markers.splice(i4--, 1));
          this._isClearing = false;
        }
        clearAllMarkers() {
          this._isClearing = true;
          for (let t = 0; t < this.markers.length; t++)
            this.markers[t].dispose(), this.markers.splice(t--, 1);
          this._isClearing = false;
        }
        addMarker(t) {
          let i4 = new e.Marker(t);
          return this.markers.push(i4), i4.register(this.lines.onTrim((o3) => {
            i4.line -= o3, i4.line < 0 && i4.dispose();
          })), i4.register(this.lines.onInsert((o3) => {
            i4.line >= o3.index && (i4.line += o3.amount);
          })), i4.register(this.lines.onDelete((o3) => {
            i4.line >= o3.index && i4.line < o3.index + o3.amount && i4.dispose(), i4.line > o3.index && (i4.line -= o3.amount);
          })), i4.register(i4.onDispose(() => this._removeMarker(i4))), i4;
        }
        _removeMarker(t) {
          this._isClearing || this.markers.splice(this.markers.indexOf(t), 1);
        }
      };
    }, 8437: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferLine = r.DEFAULT_ATTR_DATA = void 0;
      let l4 = a2(3734), u3 = a2(511), n3 = a2(643), d5 = a2(482);
      r.DEFAULT_ATTR_DATA = Object.freeze(new l4.AttributeData());
      let f4 = 0;
      class p6 {
        constructor(e, s2, t = false) {
          this.isWrapped = t, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e);
          let i4 = s2 || u3.CellData.fromCharData([0, n3.NULL_CELL_CHAR, n3.NULL_CELL_WIDTH, n3.NULL_CELL_CODE]);
          for (let o3 = 0; o3 < e; ++o3)
            this.setCell(o3, i4);
          this.length = e;
        }
        get(e) {
          let s2 = this._data[3 * e + 0], t = 2097151 & s2;
          return [this._data[3 * e + 1], 2097152 & s2 ? this._combined[e] : t ? (0, d5.stringFromCodePoint)(t) : "", s2 >> 22, 2097152 & s2 ? this._combined[e].charCodeAt(this._combined[e].length - 1) : t];
        }
        set(e, s2) {
          this._data[3 * e + 1] = s2[n3.CHAR_DATA_ATTR_INDEX], s2[n3.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e] = s2[1], this._data[3 * e + 0] = 2097152 | e | s2[n3.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e + 0] = s2[n3.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | s2[n3.CHAR_DATA_WIDTH_INDEX] << 22;
        }
        getWidth(e) {
          return this._data[3 * e + 0] >> 22;
        }
        hasWidth(e) {
          return 12582912 & this._data[3 * e + 0];
        }
        getFg(e) {
          return this._data[3 * e + 1];
        }
        getBg(e) {
          return this._data[3 * e + 2];
        }
        hasContent(e) {
          return 4194303 & this._data[3 * e + 0];
        }
        getCodePoint(e) {
          let s2 = this._data[3 * e + 0];
          return 2097152 & s2 ? this._combined[e].charCodeAt(this._combined[e].length - 1) : 2097151 & s2;
        }
        isCombined(e) {
          return 2097152 & this._data[3 * e + 0];
        }
        getString(e) {
          let s2 = this._data[3 * e + 0];
          return 2097152 & s2 ? this._combined[e] : 2097151 & s2 ? (0, d5.stringFromCodePoint)(2097151 & s2) : "";
        }
        isProtected(e) {
          return 536870912 & this._data[3 * e + 2];
        }
        loadCell(e, s2) {
          return f4 = 3 * e, s2.content = this._data[f4 + 0], s2.fg = this._data[f4 + 1], s2.bg = this._data[f4 + 2], 2097152 & s2.content && (s2.combinedData = this._combined[e]), 268435456 & s2.bg && (s2.extended = this._extendedAttrs[e]), s2;
        }
        setCell(e, s2) {
          2097152 & s2.content && (this._combined[e] = s2.combinedData), 268435456 & s2.bg && (this._extendedAttrs[e] = s2.extended), this._data[3 * e + 0] = s2.content, this._data[3 * e + 1] = s2.fg, this._data[3 * e + 2] = s2.bg;
        }
        setCellFromCodePoint(e, s2, t, i4, o3, c3) {
          268435456 & o3 && (this._extendedAttrs[e] = c3), this._data[3 * e + 0] = s2 | t << 22, this._data[3 * e + 1] = i4, this._data[3 * e + 2] = o3;
        }
        addCodepointToCell(e, s2) {
          let t = this._data[3 * e + 0];
          2097152 & t ? this._combined[e] += (0, d5.stringFromCodePoint)(s2) : (2097151 & t ? (this._combined[e] = (0, d5.stringFromCodePoint)(2097151 & t) + (0, d5.stringFromCodePoint)(s2), t &= -2097152, t |= 2097152) : t = s2 | 4194304, this._data[3 * e + 0] = t);
        }
        insertCells(e, s2, t, i4) {
          if ((e %= this.length) && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()), s2 < this.length - e) {
            let o3 = new u3.CellData();
            for (let c3 = this.length - e - s2 - 1; c3 >= 0; --c3)
              this.setCell(e + s2 + c3, this.loadCell(e + c3, o3));
            for (let c3 = 0; c3 < s2; ++c3)
              this.setCell(e + c3, t);
          } else
            for (let o3 = e; o3 < this.length; ++o3)
              this.setCell(o3, t);
          this.getWidth(this.length - 1) === 2 && this.setCellFromCodePoint(this.length - 1, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs());
        }
        deleteCells(e, s2, t, i4) {
          if (e %= this.length, s2 < this.length - e) {
            let o3 = new u3.CellData();
            for (let c3 = 0; c3 < this.length - e - s2; ++c3)
              this.setCell(e + c3, this.loadCell(e + s2 + c3, o3));
            for (let c3 = this.length - s2; c3 < this.length; ++c3)
              this.setCell(c3, t);
          } else
            for (let o3 = e; o3 < this.length; ++o3)
              this.setCell(o3, t);
          e && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()), this.getWidth(e) !== 0 || this.hasContent(e) || this.setCellFromCodePoint(e, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs());
        }
        replaceCells(e, s2, t, i4, o3 = false) {
          if (o3)
            for (e && this.getWidth(e - 1) === 2 && !this.isProtected(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()), s2 < this.length && this.getWidth(s2 - 1) === 2 && !this.isProtected(s2) && this.setCellFromCodePoint(s2, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()); e < s2 && e < this.length; )
              this.isProtected(e) || this.setCell(e, t), e++;
          else
            for (e && this.getWidth(e - 1) === 2 && this.setCellFromCodePoint(e - 1, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()), s2 < this.length && this.getWidth(s2 - 1) === 2 && this.setCellFromCodePoint(s2, 0, 1, i4?.fg || 0, i4?.bg || 0, i4?.extended || new l4.ExtendedAttrs()); e < s2 && e < this.length; )
              this.setCell(e++, t);
        }
        resize(e, s2) {
          if (e === this.length)
            return 4 * this._data.length * 2 < this._data.buffer.byteLength;
          let t = 3 * e;
          if (e > this.length) {
            if (this._data.buffer.byteLength >= 4 * t)
              this._data = new Uint32Array(this._data.buffer, 0, t);
            else {
              let i4 = new Uint32Array(t);
              i4.set(this._data), this._data = i4;
            }
            for (let i4 = this.length; i4 < e; ++i4)
              this.setCell(i4, s2);
          } else {
            this._data = this._data.subarray(0, t);
            let i4 = Object.keys(this._combined);
            for (let c3 = 0; c3 < i4.length; c3++) {
              let v5 = parseInt(i4[c3], 10);
              v5 >= e && delete this._combined[v5];
            }
            let o3 = Object.keys(this._extendedAttrs);
            for (let c3 = 0; c3 < o3.length; c3++) {
              let v5 = parseInt(o3[c3], 10);
              v5 >= e && delete this._extendedAttrs[v5];
            }
          }
          return this.length = e, 4 * t * 2 < this._data.buffer.byteLength;
        }
        cleanupMemory() {
          if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
            let e = new Uint32Array(this._data.length);
            return e.set(this._data), this._data = e, 1;
          }
          return 0;
        }
        fill(e, s2 = false) {
          if (s2)
            for (let t = 0; t < this.length; ++t)
              this.isProtected(t) || this.setCell(t, e);
          else {
            this._combined = {}, this._extendedAttrs = {};
            for (let t = 0; t < this.length; ++t)
              this.setCell(t, e);
          }
        }
        copyFrom(e) {
          this.length !== e.length ? this._data = new Uint32Array(e._data) : this._data.set(e._data), this.length = e.length, this._combined = {};
          for (let s2 in e._combined)
            this._combined[s2] = e._combined[s2];
          this._extendedAttrs = {};
          for (let s2 in e._extendedAttrs)
            this._extendedAttrs[s2] = e._extendedAttrs[s2];
          this.isWrapped = e.isWrapped;
        }
        clone() {
          let e = new p6(0);
          e._data = new Uint32Array(this._data), e.length = this.length;
          for (let s2 in this._combined)
            e._combined[s2] = this._combined[s2];
          for (let s2 in this._extendedAttrs)
            e._extendedAttrs[s2] = this._extendedAttrs[s2];
          return e.isWrapped = this.isWrapped, e;
        }
        getTrimmedLength() {
          for (let e = this.length - 1; e >= 0; --e)
            if (4194303 & this._data[3 * e + 0])
              return e + (this._data[3 * e + 0] >> 22);
          return 0;
        }
        getNoBgTrimmedLength() {
          for (let e = this.length - 1; e >= 0; --e)
            if (4194303 & this._data[3 * e + 0] || 50331648 & this._data[3 * e + 2])
              return e + (this._data[3 * e + 0] >> 22);
          return 0;
        }
        copyCellsFrom(e, s2, t, i4, o3) {
          let c3 = e._data;
          if (o3)
            for (let m6 = i4 - 1; m6 >= 0; m6--) {
              for (let h5 = 0; h5 < 3; h5++)
                this._data[3 * (t + m6) + h5] = c3[3 * (s2 + m6) + h5];
              268435456 & c3[3 * (s2 + m6) + 2] && (this._extendedAttrs[t + m6] = e._extendedAttrs[s2 + m6]);
            }
          else
            for (let m6 = 0; m6 < i4; m6++) {
              for (let h5 = 0; h5 < 3; h5++)
                this._data[3 * (t + m6) + h5] = c3[3 * (s2 + m6) + h5];
              268435456 & c3[3 * (s2 + m6) + 2] && (this._extendedAttrs[t + m6] = e._extendedAttrs[s2 + m6]);
            }
          let v5 = Object.keys(e._combined);
          for (let m6 = 0; m6 < v5.length; m6++) {
            let h5 = parseInt(v5[m6], 10);
            h5 >= s2 && (this._combined[h5 - s2 + t] = e._combined[h5]);
          }
        }
        translateToString(e = false, s2 = 0, t = this.length) {
          e && (t = Math.min(t, this.getTrimmedLength()));
          let i4 = "";
          for (; s2 < t; ) {
            let o3 = this._data[3 * s2 + 0], c3 = 2097151 & o3;
            i4 += 2097152 & o3 ? this._combined[s2] : c3 ? (0, d5.stringFromCodePoint)(c3) : n3.WHITESPACE_CELL_CHAR, s2 += o3 >> 22 || 1;
          }
          return i4;
        }
      }
      r.BufferLine = p6;
    }, 4841: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.getRangeLength = void 0, r.getRangeLength = function(a2, l4) {
        if (a2.start.y > a2.end.y)
          throw new Error(`Buffer range end (${a2.end.x}, ${a2.end.y}) cannot be before start (${a2.start.x}, ${a2.start.y})`);
        return l4 * (a2.end.y - a2.start.y) + (a2.end.x - a2.start.x + 1);
      };
    }, 4634: (P7, r) => {
      function a2(l4, u3, n3) {
        if (u3 === l4.length - 1)
          return l4[u3].getTrimmedLength();
        let d5 = !l4[u3].hasContent(n3 - 1) && l4[u3].getWidth(n3 - 1) === 1, f4 = l4[u3 + 1].getWidth(0) === 2;
        return d5 && f4 ? n3 - 1 : n3;
      }
      Object.defineProperty(r, "__esModule", { value: true }), r.getWrappedLineTrimmedLength = r.reflowSmallerGetNewLineLengths = r.reflowLargerApplyNewLayout = r.reflowLargerCreateNewLayout = r.reflowLargerGetLinesToRemove = void 0, r.reflowLargerGetLinesToRemove = function(l4, u3, n3, d5, f4) {
        let p6 = [];
        for (let _5 = 0; _5 < l4.length - 1; _5++) {
          let e = _5, s2 = l4.get(++e);
          if (!s2.isWrapped)
            continue;
          let t = [l4.get(_5)];
          for (; e < l4.length && s2.isWrapped; )
            t.push(s2), s2 = l4.get(++e);
          if (d5 >= _5 && d5 < e) {
            _5 += t.length - 1;
            continue;
          }
          let i4 = 0, o3 = a2(t, i4, u3), c3 = 1, v5 = 0;
          for (; c3 < t.length; ) {
            let h5 = a2(t, c3, u3), g4 = h5 - v5, b5 = n3 - o3, L5 = Math.min(g4, b5);
            t[i4].copyCellsFrom(t[c3], v5, o3, L5, false), o3 += L5, o3 === n3 && (i4++, o3 = 0), v5 += L5, v5 === h5 && (c3++, v5 = 0), o3 === 0 && i4 !== 0 && t[i4 - 1].getWidth(n3 - 1) === 2 && (t[i4].copyCellsFrom(t[i4 - 1], n3 - 1, o3++, 1, false), t[i4 - 1].setCell(n3 - 1, f4));
          }
          t[i4].replaceCells(o3, n3, f4);
          let m6 = 0;
          for (let h5 = t.length - 1; h5 > 0 && (h5 > i4 || t[h5].getTrimmedLength() === 0); h5--)
            m6++;
          m6 > 0 && (p6.push(_5 + t.length - m6), p6.push(m6)), _5 += t.length - 1;
        }
        return p6;
      }, r.reflowLargerCreateNewLayout = function(l4, u3) {
        let n3 = [], d5 = 0, f4 = u3[d5], p6 = 0;
        for (let _5 = 0; _5 < l4.length; _5++)
          if (f4 === _5) {
            let e = u3[++d5];
            l4.onDeleteEmitter.fire({ index: _5 - p6, amount: e }), _5 += e - 1, p6 += e, f4 = u3[++d5];
          } else
            n3.push(_5);
        return { layout: n3, countRemoved: p6 };
      }, r.reflowLargerApplyNewLayout = function(l4, u3) {
        let n3 = [];
        for (let d5 = 0; d5 < u3.length; d5++)
          n3.push(l4.get(u3[d5]));
        for (let d5 = 0; d5 < n3.length; d5++)
          l4.set(d5, n3[d5]);
        l4.length = u3.length;
      }, r.reflowSmallerGetNewLineLengths = function(l4, u3, n3) {
        let d5 = [], f4 = l4.map((s2, t) => a2(l4, t, u3)).reduce((s2, t) => s2 + t), p6 = 0, _5 = 0, e = 0;
        for (; e < f4; ) {
          if (f4 - e < n3) {
            d5.push(f4 - e);
            break;
          }
          p6 += n3;
          let s2 = a2(l4, _5, u3);
          p6 > s2 && (p6 -= s2, _5++);
          let t = l4[_5].getWidth(p6 - 1) === 2;
          t && p6--;
          let i4 = t ? n3 - 1 : n3;
          d5.push(i4), e += i4;
        }
        return d5;
      }, r.getWrappedLineTrimmedLength = a2;
    }, 5295: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferSet = void 0;
      let l4 = a2(8460), u3 = a2(844), n3 = a2(9092);
      class d5 extends u3.Disposable {
        constructor(p6, _5) {
          super(), this._optionsService = p6, this._bufferService = _5, this._onBufferActivate = this.register(new l4.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
        }
        reset() {
          this._normal = new n3.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n3.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
        }
        get alt() {
          return this._alt;
        }
        get active() {
          return this._activeBuffer;
        }
        get normal() {
          return this._normal;
        }
        activateNormalBuffer() {
          this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
        }
        activateAltBuffer(p6) {
          this._activeBuffer !== this._alt && (this._alt.fillViewportRows(p6), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
        }
        resize(p6, _5) {
          this._normal.resize(p6, _5), this._alt.resize(p6, _5), this.setupTabStops(p6);
        }
        setupTabStops(p6) {
          this._normal.setupTabStops(p6), this._alt.setupTabStops(p6);
        }
      }
      r.BufferSet = d5;
    }, 511: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.CellData = void 0;
      let l4 = a2(482), u3 = a2(643), n3 = a2(3734);
      class d5 extends n3.AttributeData {
        constructor() {
          super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n3.ExtendedAttrs(), this.combinedData = "";
        }
        static fromCharData(p6) {
          let _5 = new d5();
          return _5.setFromCharData(p6), _5;
        }
        isCombined() {
          return 2097152 & this.content;
        }
        getWidth() {
          return this.content >> 22;
        }
        getChars() {
          return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, l4.stringFromCodePoint)(2097151 & this.content) : "";
        }
        getCode() {
          return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
        }
        setFromCharData(p6) {
          this.fg = p6[u3.CHAR_DATA_ATTR_INDEX], this.bg = 0;
          let _5 = false;
          if (p6[u3.CHAR_DATA_CHAR_INDEX].length > 2)
            _5 = true;
          else if (p6[u3.CHAR_DATA_CHAR_INDEX].length === 2) {
            let e = p6[u3.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
            if (55296 <= e && e <= 56319) {
              let s2 = p6[u3.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
              56320 <= s2 && s2 <= 57343 ? this.content = 1024 * (e - 55296) + s2 - 56320 + 65536 | p6[u3.CHAR_DATA_WIDTH_INDEX] << 22 : _5 = true;
            } else
              _5 = true;
          } else
            this.content = p6[u3.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | p6[u3.CHAR_DATA_WIDTH_INDEX] << 22;
          _5 && (this.combinedData = p6[u3.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | p6[u3.CHAR_DATA_WIDTH_INDEX] << 22);
        }
        getAsCharData() {
          return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
        }
      }
      r.CellData = d5;
    }, 643: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.WHITESPACE_CELL_CODE = r.WHITESPACE_CELL_WIDTH = r.WHITESPACE_CELL_CHAR = r.NULL_CELL_CODE = r.NULL_CELL_WIDTH = r.NULL_CELL_CHAR = r.CHAR_DATA_CODE_INDEX = r.CHAR_DATA_WIDTH_INDEX = r.CHAR_DATA_CHAR_INDEX = r.CHAR_DATA_ATTR_INDEX = r.DEFAULT_EXT = r.DEFAULT_ATTR = r.DEFAULT_COLOR = void 0, r.DEFAULT_COLOR = 0, r.DEFAULT_ATTR = 256 | r.DEFAULT_COLOR << 9, r.DEFAULT_EXT = 0, r.CHAR_DATA_ATTR_INDEX = 0, r.CHAR_DATA_CHAR_INDEX = 1, r.CHAR_DATA_WIDTH_INDEX = 2, r.CHAR_DATA_CODE_INDEX = 3, r.NULL_CELL_CHAR = "", r.NULL_CELL_WIDTH = 1, r.NULL_CELL_CODE = 0, r.WHITESPACE_CELL_CHAR = " ", r.WHITESPACE_CELL_WIDTH = 1, r.WHITESPACE_CELL_CODE = 32;
    }, 4863: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.Marker = void 0;
      let l4 = a2(8460), u3 = a2(844);
      class n3 {
        get id() {
          return this._id;
        }
        constructor(f4) {
          this.line = f4, this.isDisposed = false, this._disposables = [], this._id = n3._nextId++, this._onDispose = this.register(new l4.EventEmitter()), this.onDispose = this._onDispose.event;
        }
        dispose() {
          this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, u3.disposeArray)(this._disposables), this._disposables.length = 0);
        }
        register(f4) {
          return this._disposables.push(f4), f4;
        }
      }
      r.Marker = n3, n3._nextId = 1;
    }, 7116: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.DEFAULT_CHARSET = r.CHARSETS = void 0, r.CHARSETS = {}, r.DEFAULT_CHARSET = r.CHARSETS.B, r.CHARSETS[0] = { "`": "\u25C6", a: "\u2592", b: "\u2409", c: "\u240C", d: "\u240D", e: "\u240A", f: "\xB0", g: "\xB1", h: "\u2424", i: "\u240B", j: "\u2518", k: "\u2510", l: "\u250C", m: "\u2514", n: "\u253C", o: "\u23BA", p: "\u23BB", q: "\u2500", r: "\u23BC", s: "\u23BD", t: "\u251C", u: "\u2524", v: "\u2534", w: "\u252C", x: "\u2502", y: "\u2264", z: "\u2265", "{": "\u03C0", "|": "\u2260", "}": "\xA3", "~": "\xB7" }, r.CHARSETS.A = { "#": "\xA3" }, r.CHARSETS.B = void 0, r.CHARSETS[4] = { "#": "\xA3", "@": "\xBE", "[": "ij", "\\": "\xBD", "]": "|", "{": "\xA8", "|": "f", "}": "\xBC", "~": "\xB4" }, r.CHARSETS.C = r.CHARSETS[5] = { "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, r.CHARSETS.R = { "#": "\xA3", "@": "\xE0", "[": "\xB0", "\\": "\xE7", "]": "\xA7", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xA8" }, r.CHARSETS.Q = { "@": "\xE0", "[": "\xE2", "\\": "\xE7", "]": "\xEA", "^": "\xEE", "`": "\xF4", "{": "\xE9", "|": "\xF9", "}": "\xE8", "~": "\xFB" }, r.CHARSETS.K = { "@": "\xA7", "[": "\xC4", "\\": "\xD6", "]": "\xDC", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xDF" }, r.CHARSETS.Y = { "#": "\xA3", "@": "\xA7", "[": "\xB0", "\\": "\xE7", "]": "\xE9", "`": "\xF9", "{": "\xE0", "|": "\xF2", "}": "\xE8", "~": "\xEC" }, r.CHARSETS.E = r.CHARSETS[6] = { "@": "\xC4", "[": "\xC6", "\\": "\xD8", "]": "\xC5", "^": "\xDC", "`": "\xE4", "{": "\xE6", "|": "\xF8", "}": "\xE5", "~": "\xFC" }, r.CHARSETS.Z = { "#": "\xA3", "@": "\xA7", "[": "\xA1", "\\": "\xD1", "]": "\xBF", "{": "\xB0", "|": "\xF1", "}": "\xE7" }, r.CHARSETS.H = r.CHARSETS[7] = { "@": "\xC9", "[": "\xC4", "\\": "\xD6", "]": "\xC5", "^": "\xDC", "`": "\xE9", "{": "\xE4", "|": "\xF6", "}": "\xE5", "~": "\xFC" }, r.CHARSETS["="] = { "#": "\xF9", "@": "\xE0", "[": "\xE9", "\\": "\xE7", "]": "\xEA", "^": "\xEE", _: "\xE8", "`": "\xF4", "{": "\xE4", "|": "\xF6", "}": "\xFC", "~": "\xFB" };
    }, 2584: (P7, r) => {
      var a2, l4, u3;
      Object.defineProperty(r, "__esModule", { value: true }), r.C1_ESCAPED = r.C1 = r.C0 = void 0, function(n3) {
        n3.NUL = "\0", n3.SOH = "", n3.STX = "", n3.ETX = "", n3.EOT = "", n3.ENQ = "", n3.ACK = "", n3.BEL = "\x07", n3.BS = "\b", n3.HT = "	", n3.LF = `
`, n3.VT = "\v", n3.FF = "\f", n3.CR = "\r", n3.SO = "", n3.SI = "", n3.DLE = "", n3.DC1 = "", n3.DC2 = "", n3.DC3 = "", n3.DC4 = "", n3.NAK = "", n3.SYN = "", n3.ETB = "", n3.CAN = "", n3.EM = "", n3.SUB = "", n3.ESC = "\x1B", n3.FS = "", n3.GS = "", n3.RS = "", n3.US = "", n3.SP = " ", n3.DEL = "\x7F";
      }(a2 || (r.C0 = a2 = {})), function(n3) {
        n3.PAD = "\x80", n3.HOP = "\x81", n3.BPH = "\x82", n3.NBH = "\x83", n3.IND = "\x84", n3.NEL = "\x85", n3.SSA = "\x86", n3.ESA = "\x87", n3.HTS = "\x88", n3.HTJ = "\x89", n3.VTS = "\x8A", n3.PLD = "\x8B", n3.PLU = "\x8C", n3.RI = "\x8D", n3.SS2 = "\x8E", n3.SS3 = "\x8F", n3.DCS = "\x90", n3.PU1 = "\x91", n3.PU2 = "\x92", n3.STS = "\x93", n3.CCH = "\x94", n3.MW = "\x95", n3.SPA = "\x96", n3.EPA = "\x97", n3.SOS = "\x98", n3.SGCI = "\x99", n3.SCI = "\x9A", n3.CSI = "\x9B", n3.ST = "\x9C", n3.OSC = "\x9D", n3.PM = "\x9E", n3.APC = "\x9F";
      }(l4 || (r.C1 = l4 = {})), function(n3) {
        n3.ST = `${a2.ESC}\\`;
      }(u3 || (r.C1_ESCAPED = u3 = {}));
    }, 7399: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.evaluateKeyboardEvent = void 0;
      let l4 = a2(2584), u3 = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
      r.evaluateKeyboardEvent = function(n3, d5, f4, p6) {
        let _5 = { type: 0, cancel: false, key: void 0 }, e = (n3.shiftKey ? 1 : 0) | (n3.altKey ? 2 : 0) | (n3.ctrlKey ? 4 : 0) | (n3.metaKey ? 8 : 0);
        switch (n3.keyCode) {
          case 0:
            n3.key === "UIKeyInputUpArrow" ? _5.key = d5 ? l4.C0.ESC + "OA" : l4.C0.ESC + "[A" : n3.key === "UIKeyInputLeftArrow" ? _5.key = d5 ? l4.C0.ESC + "OD" : l4.C0.ESC + "[D" : n3.key === "UIKeyInputRightArrow" ? _5.key = d5 ? l4.C0.ESC + "OC" : l4.C0.ESC + "[C" : n3.key === "UIKeyInputDownArrow" && (_5.key = d5 ? l4.C0.ESC + "OB" : l4.C0.ESC + "[B");
            break;
          case 8:
            if (n3.altKey) {
              _5.key = l4.C0.ESC + l4.C0.DEL;
              break;
            }
            _5.key = l4.C0.DEL;
            break;
          case 9:
            if (n3.shiftKey) {
              _5.key = l4.C0.ESC + "[Z";
              break;
            }
            _5.key = l4.C0.HT, _5.cancel = true;
            break;
          case 13:
            _5.key = n3.altKey ? l4.C0.ESC + l4.C0.CR : l4.C0.CR, _5.cancel = true;
            break;
          case 27:
            _5.key = l4.C0.ESC, n3.altKey && (_5.key = l4.C0.ESC + l4.C0.ESC), _5.cancel = true;
            break;
          case 37:
            if (n3.metaKey)
              break;
            e ? (_5.key = l4.C0.ESC + "[1;" + (e + 1) + "D", _5.key === l4.C0.ESC + "[1;3D" && (_5.key = l4.C0.ESC + (f4 ? "b" : "[1;5D"))) : _5.key = d5 ? l4.C0.ESC + "OD" : l4.C0.ESC + "[D";
            break;
          case 39:
            if (n3.metaKey)
              break;
            e ? (_5.key = l4.C0.ESC + "[1;" + (e + 1) + "C", _5.key === l4.C0.ESC + "[1;3C" && (_5.key = l4.C0.ESC + (f4 ? "f" : "[1;5C"))) : _5.key = d5 ? l4.C0.ESC + "OC" : l4.C0.ESC + "[C";
            break;
          case 38:
            if (n3.metaKey)
              break;
            e ? (_5.key = l4.C0.ESC + "[1;" + (e + 1) + "A", f4 || _5.key !== l4.C0.ESC + "[1;3A" || (_5.key = l4.C0.ESC + "[1;5A")) : _5.key = d5 ? l4.C0.ESC + "OA" : l4.C0.ESC + "[A";
            break;
          case 40:
            if (n3.metaKey)
              break;
            e ? (_5.key = l4.C0.ESC + "[1;" + (e + 1) + "B", f4 || _5.key !== l4.C0.ESC + "[1;3B" || (_5.key = l4.C0.ESC + "[1;5B")) : _5.key = d5 ? l4.C0.ESC + "OB" : l4.C0.ESC + "[B";
            break;
          case 45:
            n3.shiftKey || n3.ctrlKey || (_5.key = l4.C0.ESC + "[2~");
            break;
          case 46:
            _5.key = e ? l4.C0.ESC + "[3;" + (e + 1) + "~" : l4.C0.ESC + "[3~";
            break;
          case 36:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "H" : d5 ? l4.C0.ESC + "OH" : l4.C0.ESC + "[H";
            break;
          case 35:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "F" : d5 ? l4.C0.ESC + "OF" : l4.C0.ESC + "[F";
            break;
          case 33:
            n3.shiftKey ? _5.type = 2 : n3.ctrlKey ? _5.key = l4.C0.ESC + "[5;" + (e + 1) + "~" : _5.key = l4.C0.ESC + "[5~";
            break;
          case 34:
            n3.shiftKey ? _5.type = 3 : n3.ctrlKey ? _5.key = l4.C0.ESC + "[6;" + (e + 1) + "~" : _5.key = l4.C0.ESC + "[6~";
            break;
          case 112:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "P" : l4.C0.ESC + "OP";
            break;
          case 113:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "Q" : l4.C0.ESC + "OQ";
            break;
          case 114:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "R" : l4.C0.ESC + "OR";
            break;
          case 115:
            _5.key = e ? l4.C0.ESC + "[1;" + (e + 1) + "S" : l4.C0.ESC + "OS";
            break;
          case 116:
            _5.key = e ? l4.C0.ESC + "[15;" + (e + 1) + "~" : l4.C0.ESC + "[15~";
            break;
          case 117:
            _5.key = e ? l4.C0.ESC + "[17;" + (e + 1) + "~" : l4.C0.ESC + "[17~";
            break;
          case 118:
            _5.key = e ? l4.C0.ESC + "[18;" + (e + 1) + "~" : l4.C0.ESC + "[18~";
            break;
          case 119:
            _5.key = e ? l4.C0.ESC + "[19;" + (e + 1) + "~" : l4.C0.ESC + "[19~";
            break;
          case 120:
            _5.key = e ? l4.C0.ESC + "[20;" + (e + 1) + "~" : l4.C0.ESC + "[20~";
            break;
          case 121:
            _5.key = e ? l4.C0.ESC + "[21;" + (e + 1) + "~" : l4.C0.ESC + "[21~";
            break;
          case 122:
            _5.key = e ? l4.C0.ESC + "[23;" + (e + 1) + "~" : l4.C0.ESC + "[23~";
            break;
          case 123:
            _5.key = e ? l4.C0.ESC + "[24;" + (e + 1) + "~" : l4.C0.ESC + "[24~";
            break;
          default:
            if (!n3.ctrlKey || n3.shiftKey || n3.altKey || n3.metaKey)
              if (f4 && !p6 || !n3.altKey || n3.metaKey)
                !f4 || n3.altKey || n3.ctrlKey || n3.shiftKey || !n3.metaKey ? n3.key && !n3.ctrlKey && !n3.altKey && !n3.metaKey && n3.keyCode >= 48 && n3.key.length === 1 ? _5.key = n3.key : n3.key && n3.ctrlKey && (n3.key === "_" && (_5.key = l4.C0.US), n3.key === "@" && (_5.key = l4.C0.NUL)) : n3.keyCode === 65 && (_5.type = 1);
              else {
                let s2 = u3[n3.keyCode], t = s2?.[n3.shiftKey ? 1 : 0];
                if (t)
                  _5.key = l4.C0.ESC + t;
                else if (n3.keyCode >= 65 && n3.keyCode <= 90) {
                  let i4 = n3.ctrlKey ? n3.keyCode - 64 : n3.keyCode + 32, o3 = String.fromCharCode(i4);
                  n3.shiftKey && (o3 = o3.toUpperCase()), _5.key = l4.C0.ESC + o3;
                } else if (n3.keyCode === 32)
                  _5.key = l4.C0.ESC + (n3.ctrlKey ? l4.C0.NUL : " ");
                else if (n3.key === "Dead" && n3.code.startsWith("Key")) {
                  let i4 = n3.code.slice(3, 4);
                  n3.shiftKey || (i4 = i4.toLowerCase()), _5.key = l4.C0.ESC + i4, _5.cancel = true;
                }
              }
            else
              n3.keyCode >= 65 && n3.keyCode <= 90 ? _5.key = String.fromCharCode(n3.keyCode - 64) : n3.keyCode === 32 ? _5.key = l4.C0.NUL : n3.keyCode >= 51 && n3.keyCode <= 55 ? _5.key = String.fromCharCode(n3.keyCode - 51 + 27) : n3.keyCode === 56 ? _5.key = l4.C0.DEL : n3.keyCode === 219 ? _5.key = l4.C0.ESC : n3.keyCode === 220 ? _5.key = l4.C0.FS : n3.keyCode === 221 && (_5.key = l4.C0.GS);
        }
        return _5;
      };
    }, 482: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.Utf8ToUtf32 = r.StringToUtf32 = r.utf32ToString = r.stringFromCodePoint = void 0, r.stringFromCodePoint = function(a2) {
        return a2 > 65535 ? (a2 -= 65536, String.fromCharCode(55296 + (a2 >> 10)) + String.fromCharCode(a2 % 1024 + 56320)) : String.fromCharCode(a2);
      }, r.utf32ToString = function(a2, l4 = 0, u3 = a2.length) {
        let n3 = "";
        for (let d5 = l4; d5 < u3; ++d5) {
          let f4 = a2[d5];
          f4 > 65535 ? (f4 -= 65536, n3 += String.fromCharCode(55296 + (f4 >> 10)) + String.fromCharCode(f4 % 1024 + 56320)) : n3 += String.fromCharCode(f4);
        }
        return n3;
      }, r.StringToUtf32 = class {
        constructor() {
          this._interim = 0;
        }
        clear() {
          this._interim = 0;
        }
        decode(a2, l4) {
          let u3 = a2.length;
          if (!u3)
            return 0;
          let n3 = 0, d5 = 0;
          if (this._interim) {
            let f4 = a2.charCodeAt(d5++);
            56320 <= f4 && f4 <= 57343 ? l4[n3++] = 1024 * (this._interim - 55296) + f4 - 56320 + 65536 : (l4[n3++] = this._interim, l4[n3++] = f4), this._interim = 0;
          }
          for (let f4 = d5; f4 < u3; ++f4) {
            let p6 = a2.charCodeAt(f4);
            if (55296 <= p6 && p6 <= 56319) {
              if (++f4 >= u3)
                return this._interim = p6, n3;
              let _5 = a2.charCodeAt(f4);
              56320 <= _5 && _5 <= 57343 ? l4[n3++] = 1024 * (p6 - 55296) + _5 - 56320 + 65536 : (l4[n3++] = p6, l4[n3++] = _5);
            } else
              p6 !== 65279 && (l4[n3++] = p6);
          }
          return n3;
        }
      }, r.Utf8ToUtf32 = class {
        constructor() {
          this.interim = new Uint8Array(3);
        }
        clear() {
          this.interim.fill(0);
        }
        decode(a2, l4) {
          let u3 = a2.length;
          if (!u3)
            return 0;
          let n3, d5, f4, p6, _5 = 0, e = 0, s2 = 0;
          if (this.interim[0]) {
            let o3 = false, c3 = this.interim[0];
            c3 &= (224 & c3) == 192 ? 31 : (240 & c3) == 224 ? 15 : 7;
            let v5, m6 = 0;
            for (; (v5 = 63 & this.interim[++m6]) && m6 < 4; )
              c3 <<= 6, c3 |= v5;
            let h5 = (224 & this.interim[0]) == 192 ? 2 : (240 & this.interim[0]) == 224 ? 3 : 4, g4 = h5 - m6;
            for (; s2 < g4; ) {
              if (s2 >= u3)
                return 0;
              if (v5 = a2[s2++], (192 & v5) != 128) {
                s2--, o3 = true;
                break;
              }
              this.interim[m6++] = v5, c3 <<= 6, c3 |= 63 & v5;
            }
            o3 || (h5 === 2 ? c3 < 128 ? s2-- : l4[_5++] = c3 : h5 === 3 ? c3 < 2048 || c3 >= 55296 && c3 <= 57343 || c3 === 65279 || (l4[_5++] = c3) : c3 < 65536 || c3 > 1114111 || (l4[_5++] = c3)), this.interim.fill(0);
          }
          let t = u3 - 4, i4 = s2;
          for (; i4 < u3; ) {
            for (; !(!(i4 < t) || 128 & (n3 = a2[i4]) || 128 & (d5 = a2[i4 + 1]) || 128 & (f4 = a2[i4 + 2]) || 128 & (p6 = a2[i4 + 3])); )
              l4[_5++] = n3, l4[_5++] = d5, l4[_5++] = f4, l4[_5++] = p6, i4 += 4;
            if (n3 = a2[i4++], n3 < 128)
              l4[_5++] = n3;
            else if ((224 & n3) == 192) {
              if (i4 >= u3)
                return this.interim[0] = n3, _5;
              if (d5 = a2[i4++], (192 & d5) != 128) {
                i4--;
                continue;
              }
              if (e = (31 & n3) << 6 | 63 & d5, e < 128) {
                i4--;
                continue;
              }
              l4[_5++] = e;
            } else if ((240 & n3) == 224) {
              if (i4 >= u3)
                return this.interim[0] = n3, _5;
              if (d5 = a2[i4++], (192 & d5) != 128) {
                i4--;
                continue;
              }
              if (i4 >= u3)
                return this.interim[0] = n3, this.interim[1] = d5, _5;
              if (f4 = a2[i4++], (192 & f4) != 128) {
                i4--;
                continue;
              }
              if (e = (15 & n3) << 12 | (63 & d5) << 6 | 63 & f4, e < 2048 || e >= 55296 && e <= 57343 || e === 65279)
                continue;
              l4[_5++] = e;
            } else if ((248 & n3) == 240) {
              if (i4 >= u3)
                return this.interim[0] = n3, _5;
              if (d5 = a2[i4++], (192 & d5) != 128) {
                i4--;
                continue;
              }
              if (i4 >= u3)
                return this.interim[0] = n3, this.interim[1] = d5, _5;
              if (f4 = a2[i4++], (192 & f4) != 128) {
                i4--;
                continue;
              }
              if (i4 >= u3)
                return this.interim[0] = n3, this.interim[1] = d5, this.interim[2] = f4, _5;
              if (p6 = a2[i4++], (192 & p6) != 128) {
                i4--;
                continue;
              }
              if (e = (7 & n3) << 18 | (63 & d5) << 12 | (63 & f4) << 6 | 63 & p6, e < 65536 || e > 1114111)
                continue;
              l4[_5++] = e;
            }
          }
          return _5;
        }
      };
    }, 225: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.UnicodeV6 = void 0;
      let a2 = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], l4 = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]], u3;
      r.UnicodeV6 = class {
        constructor() {
          if (this.version = "6", !u3) {
            u3 = new Uint8Array(65536), u3.fill(1), u3[0] = 0, u3.fill(0, 1, 32), u3.fill(0, 127, 160), u3.fill(2, 4352, 4448), u3[9001] = 2, u3[9002] = 2, u3.fill(2, 11904, 42192), u3[12351] = 1, u3.fill(2, 44032, 55204), u3.fill(2, 63744, 64256), u3.fill(2, 65040, 65050), u3.fill(2, 65072, 65136), u3.fill(2, 65280, 65377), u3.fill(2, 65504, 65511);
            for (let n3 = 0; n3 < a2.length; ++n3)
              u3.fill(0, a2[n3][0], a2[n3][1] + 1);
          }
        }
        wcwidth(n3) {
          return n3 < 32 ? 0 : n3 < 127 ? 1 : n3 < 65536 ? u3[n3] : function(d5, f4) {
            let p6, _5 = 0, e = f4.length - 1;
            if (d5 < f4[0][0] || d5 > f4[e][1])
              return false;
            for (; e >= _5; )
              if (p6 = _5 + e >> 1, d5 > f4[p6][1])
                _5 = p6 + 1;
              else {
                if (!(d5 < f4[p6][0]))
                  return true;
                e = p6 - 1;
              }
            return false;
          }(n3, l4) ? 0 : n3 >= 131072 && n3 <= 196605 || n3 >= 196608 && n3 <= 262141 ? 2 : 1;
        }
      };
    }, 5981: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.WriteBuffer = void 0;
      let l4 = a2(8460), u3 = a2(844);
      class n3 extends u3.Disposable {
        constructor(f4) {
          super(), this._action = f4, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new l4.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
        }
        handleUserInput() {
          this._didUserInput = true;
        }
        writeSync(f4, p6) {
          if (p6 !== void 0 && this._syncCalls > p6)
            return void (this._syncCalls = 0);
          if (this._pendingData += f4.length, this._writeBuffer.push(f4), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting)
            return;
          let _5;
          for (this._isSyncWriting = true; _5 = this._writeBuffer.shift(); ) {
            this._action(_5);
            let e = this._callbacks.shift();
            e && e();
          }
          this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
        }
        write(f4, p6) {
          if (this._pendingData > 5e7)
            throw new Error("write data discarded, use flow control to avoid losing data");
          if (!this._writeBuffer.length) {
            if (this._bufferOffset = 0, this._didUserInput)
              return this._didUserInput = false, this._pendingData += f4.length, this._writeBuffer.push(f4), this._callbacks.push(p6), void this._innerWrite();
            setTimeout(() => this._innerWrite());
          }
          this._pendingData += f4.length, this._writeBuffer.push(f4), this._callbacks.push(p6);
        }
        _innerWrite(f4 = 0, p6 = true) {
          let _5 = f4 || Date.now();
          for (; this._writeBuffer.length > this._bufferOffset; ) {
            let e = this._writeBuffer[this._bufferOffset], s2 = this._action(e, p6);
            if (s2) {
              let i4 = (o3) => Date.now() - _5 >= 12 ? setTimeout(() => this._innerWrite(0, o3)) : this._innerWrite(_5, o3);
              return void s2.catch((o3) => (queueMicrotask(() => {
                throw o3;
              }), Promise.resolve(false))).then(i4);
            }
            let t = this._callbacks[this._bufferOffset];
            if (t && t(), this._bufferOffset++, this._pendingData -= e.length, Date.now() - _5 >= 12)
              break;
          }
          this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
        }
      }
      r.WriteBuffer = n3;
    }, 5941: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.toRgbString = r.parseColor = void 0;
      let a2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, l4 = /^[\da-f]+$/;
      function u3(n3, d5) {
        let f4 = n3.toString(16), p6 = f4.length < 2 ? "0" + f4 : f4;
        switch (d5) {
          case 4:
            return f4[0];
          case 8:
            return p6;
          case 12:
            return (p6 + p6).slice(0, 3);
          default:
            return p6 + p6;
        }
      }
      r.parseColor = function(n3) {
        if (!n3)
          return;
        let d5 = n3.toLowerCase();
        if (d5.indexOf("rgb:") === 0) {
          d5 = d5.slice(4);
          let f4 = a2.exec(d5);
          if (f4) {
            let p6 = f4[1] ? 15 : f4[4] ? 255 : f4[7] ? 4095 : 65535;
            return [Math.round(parseInt(f4[1] || f4[4] || f4[7] || f4[10], 16) / p6 * 255), Math.round(parseInt(f4[2] || f4[5] || f4[8] || f4[11], 16) / p6 * 255), Math.round(parseInt(f4[3] || f4[6] || f4[9] || f4[12], 16) / p6 * 255)];
          }
        } else if (d5.indexOf("#") === 0 && (d5 = d5.slice(1), l4.exec(d5) && [3, 6, 9, 12].includes(d5.length))) {
          let f4 = d5.length / 3, p6 = [0, 0, 0];
          for (let _5 = 0; _5 < 3; ++_5) {
            let e = parseInt(d5.slice(f4 * _5, f4 * _5 + f4), 16);
            p6[_5] = f4 === 1 ? e << 4 : f4 === 2 ? e : f4 === 3 ? e >> 4 : e >> 8;
          }
          return p6;
        }
      }, r.toRgbString = function(n3, d5 = 16) {
        let [f4, p6, _5] = n3;
        return `rgb:${u3(f4, d5)}/${u3(p6, d5)}/${u3(_5, d5)}`;
      };
    }, 5770: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.PAYLOAD_LIMIT = void 0, r.PAYLOAD_LIMIT = 1e7;
    }, 6351: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.DcsHandler = r.DcsParser = void 0;
      let l4 = a2(482), u3 = a2(8742), n3 = a2(5770), d5 = [];
      r.DcsParser = class {
        constructor() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._active = d5, this._ident = 0, this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = d5;
        }
        registerHandler(p6, _5) {
          this._handlers[p6] === void 0 && (this._handlers[p6] = []);
          let e = this._handlers[p6];
          return e.push(_5), { dispose: () => {
            let s2 = e.indexOf(_5);
            s2 !== -1 && e.splice(s2, 1);
          } };
        }
        clearHandler(p6) {
          this._handlers[p6] && delete this._handlers[p6];
        }
        setHandlerFallback(p6) {
          this._handlerFb = p6;
        }
        reset() {
          if (this._active.length)
            for (let p6 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; p6 >= 0; --p6)
              this._active[p6].unhook(false);
          this._stack.paused = false, this._active = d5, this._ident = 0;
        }
        hook(p6, _5) {
          if (this.reset(), this._ident = p6, this._active = this._handlers[p6] || d5, this._active.length)
            for (let e = this._active.length - 1; e >= 0; e--)
              this._active[e].hook(_5);
          else
            this._handlerFb(this._ident, "HOOK", _5);
        }
        put(p6, _5, e) {
          if (this._active.length)
            for (let s2 = this._active.length - 1; s2 >= 0; s2--)
              this._active[s2].put(p6, _5, e);
          else
            this._handlerFb(this._ident, "PUT", (0, l4.utf32ToString)(p6, _5, e));
        }
        unhook(p6, _5 = true) {
          if (this._active.length) {
            let e = false, s2 = this._active.length - 1, t = false;
            if (this._stack.paused && (s2 = this._stack.loopPosition - 1, e = _5, t = this._stack.fallThrough, this._stack.paused = false), !t && e === false) {
              for (; s2 >= 0 && (e = this._active[s2].unhook(p6), e !== true); s2--)
                if (e instanceof Promise)
                  return this._stack.paused = true, this._stack.loopPosition = s2, this._stack.fallThrough = false, e;
              s2--;
            }
            for (; s2 >= 0; s2--)
              if (e = this._active[s2].unhook(false), e instanceof Promise)
                return this._stack.paused = true, this._stack.loopPosition = s2, this._stack.fallThrough = true, e;
          } else
            this._handlerFb(this._ident, "UNHOOK", p6);
          this._active = d5, this._ident = 0;
        }
      };
      let f4 = new u3.Params();
      f4.addParam(0), r.DcsHandler = class {
        constructor(p6) {
          this._handler = p6, this._data = "", this._params = f4, this._hitLimit = false;
        }
        hook(p6) {
          this._params = p6.length > 1 || p6.params[0] ? p6.clone() : f4, this._data = "", this._hitLimit = false;
        }
        put(p6, _5, e) {
          this._hitLimit || (this._data += (0, l4.utf32ToString)(p6, _5, e), this._data.length > n3.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        unhook(p6) {
          let _5 = false;
          if (this._hitLimit)
            _5 = false;
          else if (p6 && (_5 = this._handler(this._data, this._params), _5 instanceof Promise))
            return _5.then((e) => (this._params = f4, this._data = "", this._hitLimit = false, e));
          return this._params = f4, this._data = "", this._hitLimit = false, _5;
        }
      };
    }, 2015: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.EscapeSequenceParser = r.VT500_TRANSITION_TABLE = r.TransitionTable = void 0;
      let l4 = a2(844), u3 = a2(8742), n3 = a2(6242), d5 = a2(6351);
      class f4 {
        constructor(s2) {
          this.table = new Uint8Array(s2);
        }
        setDefault(s2, t) {
          this.table.fill(s2 << 4 | t);
        }
        add(s2, t, i4, o3) {
          this.table[t << 8 | s2] = i4 << 4 | o3;
        }
        addMany(s2, t, i4, o3) {
          for (let c3 = 0; c3 < s2.length; c3++)
            this.table[t << 8 | s2[c3]] = i4 << 4 | o3;
        }
      }
      r.TransitionTable = f4;
      let p6 = 160;
      r.VT500_TRANSITION_TABLE = function() {
        let e = new f4(4095), s2 = Array.apply(null, Array(256)).map((m6, h5) => h5), t = (m6, h5) => s2.slice(m6, h5), i4 = t(32, 127), o3 = t(0, 24);
        o3.push(25), o3.push.apply(o3, t(28, 32));
        let c3 = t(0, 14), v5;
        for (v5 in e.setDefault(1, 0), e.addMany(i4, 0, 2, 0), c3)
          e.addMany([24, 26, 153, 154], v5, 3, 0), e.addMany(t(128, 144), v5, 3, 0), e.addMany(t(144, 152), v5, 3, 0), e.add(156, v5, 0, 0), e.add(27, v5, 11, 1), e.add(157, v5, 4, 8), e.addMany([152, 158, 159], v5, 0, 7), e.add(155, v5, 11, 3), e.add(144, v5, 11, 9);
        return e.addMany(o3, 0, 3, 0), e.addMany(o3, 1, 3, 1), e.add(127, 1, 0, 1), e.addMany(o3, 8, 0, 8), e.addMany(o3, 3, 3, 3), e.add(127, 3, 0, 3), e.addMany(o3, 4, 3, 4), e.add(127, 4, 0, 4), e.addMany(o3, 6, 3, 6), e.addMany(o3, 5, 3, 5), e.add(127, 5, 0, 5), e.addMany(o3, 2, 3, 2), e.add(127, 2, 0, 2), e.add(93, 1, 4, 8), e.addMany(i4, 8, 5, 8), e.add(127, 8, 5, 8), e.addMany([156, 27, 24, 26, 7], 8, 6, 0), e.addMany(t(28, 32), 8, 0, 8), e.addMany([88, 94, 95], 1, 0, 7), e.addMany(i4, 7, 0, 7), e.addMany(o3, 7, 0, 7), e.add(156, 7, 0, 0), e.add(127, 7, 0, 7), e.add(91, 1, 11, 3), e.addMany(t(64, 127), 3, 7, 0), e.addMany(t(48, 60), 3, 8, 4), e.addMany([60, 61, 62, 63], 3, 9, 4), e.addMany(t(48, 60), 4, 8, 4), e.addMany(t(64, 127), 4, 7, 0), e.addMany([60, 61, 62, 63], 4, 0, 6), e.addMany(t(32, 64), 6, 0, 6), e.add(127, 6, 0, 6), e.addMany(t(64, 127), 6, 0, 0), e.addMany(t(32, 48), 3, 9, 5), e.addMany(t(32, 48), 5, 9, 5), e.addMany(t(48, 64), 5, 0, 6), e.addMany(t(64, 127), 5, 7, 0), e.addMany(t(32, 48), 4, 9, 5), e.addMany(t(32, 48), 1, 9, 2), e.addMany(t(32, 48), 2, 9, 2), e.addMany(t(48, 127), 2, 10, 0), e.addMany(t(48, 80), 1, 10, 0), e.addMany(t(81, 88), 1, 10, 0), e.addMany([89, 90, 92], 1, 10, 0), e.addMany(t(96, 127), 1, 10, 0), e.add(80, 1, 11, 9), e.addMany(o3, 9, 0, 9), e.add(127, 9, 0, 9), e.addMany(t(28, 32), 9, 0, 9), e.addMany(t(32, 48), 9, 9, 12), e.addMany(t(48, 60), 9, 8, 10), e.addMany([60, 61, 62, 63], 9, 9, 10), e.addMany(o3, 11, 0, 11), e.addMany(t(32, 128), 11, 0, 11), e.addMany(t(28, 32), 11, 0, 11), e.addMany(o3, 10, 0, 10), e.add(127, 10, 0, 10), e.addMany(t(28, 32), 10, 0, 10), e.addMany(t(48, 60), 10, 8, 10), e.addMany([60, 61, 62, 63], 10, 0, 11), e.addMany(t(32, 48), 10, 9, 12), e.addMany(o3, 12, 0, 12), e.add(127, 12, 0, 12), e.addMany(t(28, 32), 12, 0, 12), e.addMany(t(32, 48), 12, 9, 12), e.addMany(t(48, 64), 12, 0, 11), e.addMany(t(64, 127), 12, 12, 13), e.addMany(t(64, 127), 10, 12, 13), e.addMany(t(64, 127), 9, 12, 13), e.addMany(o3, 13, 13, 13), e.addMany(i4, 13, 13, 13), e.add(127, 13, 0, 13), e.addMany([27, 156, 24, 26], 13, 14, 0), e.add(p6, 0, 2, 0), e.add(p6, 8, 5, 8), e.add(p6, 6, 0, 6), e.add(p6, 11, 0, 11), e.add(p6, 13, 13, 13), e;
      }();
      class _5 extends l4.Disposable {
        constructor(s2 = r.VT500_TRANSITION_TABLE) {
          super(), this._transitions = s2, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new u3.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (t, i4, o3) => {
          }, this._executeHandlerFb = (t) => {
          }, this._csiHandlerFb = (t, i4) => {
          }, this._escHandlerFb = (t) => {
          }, this._errorHandlerFb = (t) => t, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, l4.toDisposable)(() => {
            this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
          })), this._oscParser = this.register(new n3.OscParser()), this._dcsParser = this.register(new d5.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, () => true);
        }
        _identifier(s2, t = [64, 126]) {
          let i4 = 0;
          if (s2.prefix) {
            if (s2.prefix.length > 1)
              throw new Error("only one byte as prefix supported");
            if (i4 = s2.prefix.charCodeAt(0), i4 && 60 > i4 || i4 > 63)
              throw new Error("prefix must be in range 0x3c .. 0x3f");
          }
          if (s2.intermediates) {
            if (s2.intermediates.length > 2)
              throw new Error("only two bytes as intermediates are supported");
            for (let c3 = 0; c3 < s2.intermediates.length; ++c3) {
              let v5 = s2.intermediates.charCodeAt(c3);
              if (32 > v5 || v5 > 47)
                throw new Error("intermediate must be in range 0x20 .. 0x2f");
              i4 <<= 8, i4 |= v5;
            }
          }
          if (s2.final.length !== 1)
            throw new Error("final must be a single byte");
          let o3 = s2.final.charCodeAt(0);
          if (t[0] > o3 || o3 > t[1])
            throw new Error(`final must be in range ${t[0]} .. ${t[1]}`);
          return i4 <<= 8, i4 |= o3, i4;
        }
        identToString(s2) {
          let t = [];
          for (; s2; )
            t.push(String.fromCharCode(255 & s2)), s2 >>= 8;
          return t.reverse().join("");
        }
        setPrintHandler(s2) {
          this._printHandler = s2;
        }
        clearPrintHandler() {
          this._printHandler = this._printHandlerFb;
        }
        registerEscHandler(s2, t) {
          let i4 = this._identifier(s2, [48, 126]);
          this._escHandlers[i4] === void 0 && (this._escHandlers[i4] = []);
          let o3 = this._escHandlers[i4];
          return o3.push(t), { dispose: () => {
            let c3 = o3.indexOf(t);
            c3 !== -1 && o3.splice(c3, 1);
          } };
        }
        clearEscHandler(s2) {
          this._escHandlers[this._identifier(s2, [48, 126])] && delete this._escHandlers[this._identifier(s2, [48, 126])];
        }
        setEscHandlerFallback(s2) {
          this._escHandlerFb = s2;
        }
        setExecuteHandler(s2, t) {
          this._executeHandlers[s2.charCodeAt(0)] = t;
        }
        clearExecuteHandler(s2) {
          this._executeHandlers[s2.charCodeAt(0)] && delete this._executeHandlers[s2.charCodeAt(0)];
        }
        setExecuteHandlerFallback(s2) {
          this._executeHandlerFb = s2;
        }
        registerCsiHandler(s2, t) {
          let i4 = this._identifier(s2);
          this._csiHandlers[i4] === void 0 && (this._csiHandlers[i4] = []);
          let o3 = this._csiHandlers[i4];
          return o3.push(t), { dispose: () => {
            let c3 = o3.indexOf(t);
            c3 !== -1 && o3.splice(c3, 1);
          } };
        }
        clearCsiHandler(s2) {
          this._csiHandlers[this._identifier(s2)] && delete this._csiHandlers[this._identifier(s2)];
        }
        setCsiHandlerFallback(s2) {
          this._csiHandlerFb = s2;
        }
        registerDcsHandler(s2, t) {
          return this._dcsParser.registerHandler(this._identifier(s2), t);
        }
        clearDcsHandler(s2) {
          this._dcsParser.clearHandler(this._identifier(s2));
        }
        setDcsHandlerFallback(s2) {
          this._dcsParser.setHandlerFallback(s2);
        }
        registerOscHandler(s2, t) {
          return this._oscParser.registerHandler(s2, t);
        }
        clearOscHandler(s2) {
          this._oscParser.clearHandler(s2);
        }
        setOscHandlerFallback(s2) {
          this._oscParser.setHandlerFallback(s2);
        }
        setErrorHandler(s2) {
          this._errorHandler = s2;
        }
        clearErrorHandler() {
          this._errorHandler = this._errorHandlerFb;
        }
        reset() {
          this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._parseStack.state !== 0 && (this._parseStack.state = 2, this._parseStack.handlers = []);
        }
        _preserveStack(s2, t, i4, o3, c3) {
          this._parseStack.state = s2, this._parseStack.handlers = t, this._parseStack.handlerPos = i4, this._parseStack.transition = o3, this._parseStack.chunkPos = c3;
        }
        parse(s2, t, i4) {
          let o3, c3 = 0, v5 = 0, m6 = 0;
          if (this._parseStack.state)
            if (this._parseStack.state === 2)
              this._parseStack.state = 0, m6 = this._parseStack.chunkPos + 1;
            else {
              if (i4 === void 0 || this._parseStack.state === 1)
                throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              let h5 = this._parseStack.handlers, g4 = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (i4 === false && g4 > -1) {
                    for (; g4 >= 0 && (o3 = h5[g4](this._params), o3 !== true); g4--)
                      if (o3 instanceof Promise)
                        return this._parseStack.handlerPos = g4, o3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (i4 === false && g4 > -1) {
                    for (; g4 >= 0 && (o3 = h5[g4](), o3 !== true); g4--)
                      if (o3 instanceof Promise)
                        return this._parseStack.handlerPos = g4, o3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (c3 = s2[this._parseStack.chunkPos], o3 = this._dcsParser.unhook(c3 !== 24 && c3 !== 26, i4), o3)
                    return o3;
                  c3 === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (c3 = s2[this._parseStack.chunkPos], o3 = this._oscParser.end(c3 !== 24 && c3 !== 26, i4), o3)
                    return o3;
                  c3 === 27 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, m6 = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;
            }
          for (let h5 = m6; h5 < t; ++h5) {
            switch (c3 = s2[h5], v5 = this._transitions.table[this.currentState << 8 | (c3 < 160 ? c3 : p6)], v5 >> 4) {
              case 2:
                for (let k4 = h5 + 1; ; ++k4) {
                  if (k4 >= t || (c3 = s2[k4]) < 32 || c3 > 126 && c3 < p6) {
                    this._printHandler(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                  if (++k4 >= t || (c3 = s2[k4]) < 32 || c3 > 126 && c3 < p6) {
                    this._printHandler(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                  if (++k4 >= t || (c3 = s2[k4]) < 32 || c3 > 126 && c3 < p6) {
                    this._printHandler(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                  if (++k4 >= t || (c3 = s2[k4]) < 32 || c3 > 126 && c3 < p6) {
                    this._printHandler(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                }
                break;
              case 3:
                this._executeHandlers[c3] ? this._executeHandlers[c3]() : this._executeHandlerFb(c3), this.precedingCodepoint = 0;
                break;
              case 0:
                break;
              case 1:
                if (this._errorHandler({ position: h5, code: c3, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort)
                  return;
                break;
              case 7:
                let g4 = this._csiHandlers[this._collect << 8 | c3], b5 = g4 ? g4.length - 1 : -1;
                for (; b5 >= 0 && (o3 = g4[b5](this._params), o3 !== true); b5--)
                  if (o3 instanceof Promise)
                    return this._preserveStack(3, g4, b5, v5, h5), o3;
                b5 < 0 && this._csiHandlerFb(this._collect << 8 | c3, this._params), this.precedingCodepoint = 0;
                break;
              case 8:
                do
                  switch (c3) {
                    case 59:
                      this._params.addParam(0);
                      break;
                    case 58:
                      this._params.addSubParam(-1);
                      break;
                    default:
                      this._params.addDigit(c3 - 48);
                  }
                while (++h5 < t && (c3 = s2[h5]) > 47 && c3 < 60);
                h5--;
                break;
              case 9:
                this._collect <<= 8, this._collect |= c3;
                break;
              case 10:
                let L5 = this._escHandlers[this._collect << 8 | c3], y5 = L5 ? L5.length - 1 : -1;
                for (; y5 >= 0 && (o3 = L5[y5](), o3 !== true); y5--)
                  if (o3 instanceof Promise)
                    return this._preserveStack(4, L5, y5, v5, h5), o3;
                y5 < 0 && this._escHandlerFb(this._collect << 8 | c3), this.precedingCodepoint = 0;
                break;
              case 11:
                this._params.reset(), this._params.addParam(0), this._collect = 0;
                break;
              case 12:
                this._dcsParser.hook(this._collect << 8 | c3, this._params);
                break;
              case 13:
                for (let k4 = h5 + 1; ; ++k4)
                  if (k4 >= t || (c3 = s2[k4]) === 24 || c3 === 26 || c3 === 27 || c3 > 127 && c3 < p6) {
                    this._dcsParser.put(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                break;
              case 14:
                if (o3 = this._dcsParser.unhook(c3 !== 24 && c3 !== 26), o3)
                  return this._preserveStack(6, [], 0, v5, h5), o3;
                c3 === 27 && (v5 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
                break;
              case 4:
                this._oscParser.start();
                break;
              case 5:
                for (let k4 = h5 + 1; ; k4++)
                  if (k4 >= t || (c3 = s2[k4]) < 32 || c3 > 127 && c3 < p6) {
                    this._oscParser.put(s2, h5, k4), h5 = k4 - 1;
                    break;
                  }
                break;
              case 6:
                if (o3 = this._oscParser.end(c3 !== 24 && c3 !== 26), o3)
                  return this._preserveStack(5, [], 0, v5, h5), o3;
                c3 === 27 && (v5 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;
            }
            this.currentState = 15 & v5;
          }
        }
      }
      r.EscapeSequenceParser = _5;
    }, 6242: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.OscHandler = r.OscParser = void 0;
      let l4 = a2(5770), u3 = a2(482), n3 = [];
      r.OscParser = class {
        constructor() {
          this._state = 0, this._active = n3, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
        }
        registerHandler(d5, f4) {
          this._handlers[d5] === void 0 && (this._handlers[d5] = []);
          let p6 = this._handlers[d5];
          return p6.push(f4), { dispose: () => {
            let _5 = p6.indexOf(f4);
            _5 !== -1 && p6.splice(_5, 1);
          } };
        }
        clearHandler(d5) {
          this._handlers[d5] && delete this._handlers[d5];
        }
        setHandlerFallback(d5) {
          this._handlerFb = d5;
        }
        dispose() {
          this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
          }, this._active = n3;
        }
        reset() {
          if (this._state === 2)
            for (let d5 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; d5 >= 0; --d5)
              this._active[d5].end(false);
          this._stack.paused = false, this._active = n3, this._id = -1, this._state = 0;
        }
        _start() {
          if (this._active = this._handlers[this._id] || n3, this._active.length)
            for (let d5 = this._active.length - 1; d5 >= 0; d5--)
              this._active[d5].start();
          else
            this._handlerFb(this._id, "START");
        }
        _put(d5, f4, p6) {
          if (this._active.length)
            for (let _5 = this._active.length - 1; _5 >= 0; _5--)
              this._active[_5].put(d5, f4, p6);
          else
            this._handlerFb(this._id, "PUT", (0, u3.utf32ToString)(d5, f4, p6));
        }
        start() {
          this.reset(), this._state = 1;
        }
        put(d5, f4, p6) {
          if (this._state !== 3) {
            if (this._state === 1)
              for (; f4 < p6; ) {
                let _5 = d5[f4++];
                if (_5 === 59) {
                  this._state = 2, this._start();
                  break;
                }
                if (_5 < 48 || 57 < _5)
                  return void (this._state = 3);
                this._id === -1 && (this._id = 0), this._id = 10 * this._id + _5 - 48;
              }
            this._state === 2 && p6 - f4 > 0 && this._put(d5, f4, p6);
          }
        }
        end(d5, f4 = true) {
          if (this._state !== 0) {
            if (this._state !== 3)
              if (this._state === 1 && this._start(), this._active.length) {
                let p6 = false, _5 = this._active.length - 1, e = false;
                if (this._stack.paused && (_5 = this._stack.loopPosition - 1, p6 = f4, e = this._stack.fallThrough, this._stack.paused = false), !e && p6 === false) {
                  for (; _5 >= 0 && (p6 = this._active[_5].end(d5), p6 !== true); _5--)
                    if (p6 instanceof Promise)
                      return this._stack.paused = true, this._stack.loopPosition = _5, this._stack.fallThrough = false, p6;
                  _5--;
                }
                for (; _5 >= 0; _5--)
                  if (p6 = this._active[_5].end(false), p6 instanceof Promise)
                    return this._stack.paused = true, this._stack.loopPosition = _5, this._stack.fallThrough = true, p6;
              } else
                this._handlerFb(this._id, "END", d5);
            this._active = n3, this._id = -1, this._state = 0;
          }
        }
      }, r.OscHandler = class {
        constructor(d5) {
          this._handler = d5, this._data = "", this._hitLimit = false;
        }
        start() {
          this._data = "", this._hitLimit = false;
        }
        put(d5, f4, p6) {
          this._hitLimit || (this._data += (0, u3.utf32ToString)(d5, f4, p6), this._data.length > l4.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
        }
        end(d5) {
          let f4 = false;
          if (this._hitLimit)
            f4 = false;
          else if (d5 && (f4 = this._handler(this._data), f4 instanceof Promise))
            return f4.then((p6) => (this._data = "", this._hitLimit = false, p6));
          return this._data = "", this._hitLimit = false, f4;
        }
      };
    }, 8742: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.Params = void 0;
      let a2 = 2147483647;
      class l4 {
        static fromArray(n3) {
          let d5 = new l4();
          if (!n3.length)
            return d5;
          for (let f4 = Array.isArray(n3[0]) ? 1 : 0; f4 < n3.length; ++f4) {
            let p6 = n3[f4];
            if (Array.isArray(p6))
              for (let _5 = 0; _5 < p6.length; ++_5)
                d5.addSubParam(p6[_5]);
            else
              d5.addParam(p6);
          }
          return d5;
        }
        constructor(n3 = 32, d5 = 32) {
          if (this.maxLength = n3, this.maxSubParamsLength = d5, d5 > 256)
            throw new Error("maxSubParamsLength must not be greater than 256");
          this.params = new Int32Array(n3), this.length = 0, this._subParams = new Int32Array(d5), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(n3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        clone() {
          let n3 = new l4(this.maxLength, this.maxSubParamsLength);
          return n3.params.set(this.params), n3.length = this.length, n3._subParams.set(this._subParams), n3._subParamsLength = this._subParamsLength, n3._subParamsIdx.set(this._subParamsIdx), n3._rejectDigits = this._rejectDigits, n3._rejectSubDigits = this._rejectSubDigits, n3._digitIsSub = this._digitIsSub, n3;
        }
        toArray() {
          let n3 = [];
          for (let d5 = 0; d5 < this.length; ++d5) {
            n3.push(this.params[d5]);
            let f4 = this._subParamsIdx[d5] >> 8, p6 = 255 & this._subParamsIdx[d5];
            p6 - f4 > 0 && n3.push(Array.prototype.slice.call(this._subParams, f4, p6));
          }
          return n3;
        }
        reset() {
          this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
        }
        addParam(n3) {
          if (this._digitIsSub = false, this.length >= this.maxLength)
            this._rejectDigits = true;
          else {
            if (n3 < -1)
              throw new Error("values lesser than -1 are not allowed");
            this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = n3 > a2 ? a2 : n3;
          }
        }
        addSubParam(n3) {
          if (this._digitIsSub = true, this.length)
            if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength)
              this._rejectSubDigits = true;
            else {
              if (n3 < -1)
                throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = n3 > a2 ? a2 : n3, this._subParamsIdx[this.length - 1]++;
            }
        }
        hasSubParams(n3) {
          return (255 & this._subParamsIdx[n3]) - (this._subParamsIdx[n3] >> 8) > 0;
        }
        getSubParams(n3) {
          let d5 = this._subParamsIdx[n3] >> 8, f4 = 255 & this._subParamsIdx[n3];
          return f4 - d5 > 0 ? this._subParams.subarray(d5, f4) : null;
        }
        getSubParamsAll() {
          let n3 = {};
          for (let d5 = 0; d5 < this.length; ++d5) {
            let f4 = this._subParamsIdx[d5] >> 8, p6 = 255 & this._subParamsIdx[d5];
            p6 - f4 > 0 && (n3[d5] = this._subParams.slice(f4, p6));
          }
          return n3;
        }
        addDigit(n3) {
          let d5;
          if (this._rejectDigits || !(d5 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits)
            return;
          let f4 = this._digitIsSub ? this._subParams : this.params, p6 = f4[d5 - 1];
          f4[d5 - 1] = ~p6 ? Math.min(10 * p6 + n3, a2) : n3;
        }
      }
      r.Params = l4;
    }, 5741: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.AddonManager = void 0, r.AddonManager = class {
        constructor() {
          this._addons = [];
        }
        dispose() {
          for (let a2 = this._addons.length - 1; a2 >= 0; a2--)
            this._addons[a2].instance.dispose();
        }
        loadAddon(a2, l4) {
          let u3 = { instance: l4, dispose: l4.dispose, isDisposed: false };
          this._addons.push(u3), l4.dispose = () => this._wrappedAddonDispose(u3), l4.activate(a2);
        }
        _wrappedAddonDispose(a2) {
          if (a2.isDisposed)
            return;
          let l4 = -1;
          for (let u3 = 0; u3 < this._addons.length; u3++)
            if (this._addons[u3] === a2) {
              l4 = u3;
              break;
            }
          if (l4 === -1)
            throw new Error("Could not dispose an addon that has not been loaded");
          a2.isDisposed = true, a2.dispose.apply(a2.instance), this._addons.splice(l4, 1);
        }
      };
    }, 8771: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferApiView = void 0;
      let l4 = a2(3785), u3 = a2(511);
      r.BufferApiView = class {
        constructor(n3, d5) {
          this._buffer = n3, this.type = d5;
        }
        init(n3) {
          return this._buffer = n3, this;
        }
        get cursorY() {
          return this._buffer.y;
        }
        get cursorX() {
          return this._buffer.x;
        }
        get viewportY() {
          return this._buffer.ydisp;
        }
        get baseY() {
          return this._buffer.ybase;
        }
        get length() {
          return this._buffer.lines.length;
        }
        getLine(n3) {
          let d5 = this._buffer.lines.get(n3);
          if (d5)
            return new l4.BufferLineApiView(d5);
        }
        getNullCell() {
          return new u3.CellData();
        }
      };
    }, 3785: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferLineApiView = void 0;
      let l4 = a2(511);
      r.BufferLineApiView = class {
        constructor(u3) {
          this._line = u3;
        }
        get isWrapped() {
          return this._line.isWrapped;
        }
        get length() {
          return this._line.length;
        }
        getCell(u3, n3) {
          if (!(u3 < 0 || u3 >= this._line.length))
            return n3 ? (this._line.loadCell(u3, n3), n3) : this._line.loadCell(u3, new l4.CellData());
        }
        translateToString(u3, n3, d5) {
          return this._line.translateToString(u3, n3, d5);
        }
      };
    }, 8285: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferNamespaceApi = void 0;
      let l4 = a2(8771), u3 = a2(8460), n3 = a2(844);
      class d5 extends n3.Disposable {
        constructor(p6) {
          super(), this._core = p6, this._onBufferChange = this.register(new u3.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new l4.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new l4.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
        }
        get active() {
          if (this._core.buffers.active === this._core.buffers.normal)
            return this.normal;
          if (this._core.buffers.active === this._core.buffers.alt)
            return this.alternate;
          throw new Error("Active buffer is neither normal nor alternate");
        }
        get normal() {
          return this._normal.init(this._core.buffers.normal);
        }
        get alternate() {
          return this._alternate.init(this._core.buffers.alt);
        }
      }
      r.BufferNamespaceApi = d5;
    }, 7975: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.ParserApi = void 0, r.ParserApi = class {
        constructor(a2) {
          this._core = a2;
        }
        registerCsiHandler(a2, l4) {
          return this._core.registerCsiHandler(a2, (u3) => l4(u3.toArray()));
        }
        addCsiHandler(a2, l4) {
          return this.registerCsiHandler(a2, l4);
        }
        registerDcsHandler(a2, l4) {
          return this._core.registerDcsHandler(a2, (u3, n3) => l4(u3, n3.toArray()));
        }
        addDcsHandler(a2, l4) {
          return this.registerDcsHandler(a2, l4);
        }
        registerEscHandler(a2, l4) {
          return this._core.registerEscHandler(a2, l4);
        }
        addEscHandler(a2, l4) {
          return this.registerEscHandler(a2, l4);
        }
        registerOscHandler(a2, l4) {
          return this._core.registerOscHandler(a2, l4);
        }
        addOscHandler(a2, l4) {
          return this.registerOscHandler(a2, l4);
        }
      };
    }, 7090: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.UnicodeApi = void 0, r.UnicodeApi = class {
        constructor(a2) {
          this._core = a2;
        }
        register(a2) {
          this._core.unicodeService.register(a2);
        }
        get versions() {
          return this._core.unicodeService.versions;
        }
        get activeVersion() {
          return this._core.unicodeService.activeVersion;
        }
        set activeVersion(a2) {
          this._core.unicodeService.activeVersion = a2;
        }
      };
    }, 744: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(e, s2, t, i4) {
        var o3, c3 = arguments.length, v5 = c3 < 3 ? s2 : i4 === null ? i4 = Object.getOwnPropertyDescriptor(s2, t) : i4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          v5 = Reflect.decorate(e, s2, t, i4);
        else
          for (var m6 = e.length - 1; m6 >= 0; m6--)
            (o3 = e[m6]) && (v5 = (c3 < 3 ? o3(v5) : c3 > 3 ? o3(s2, t, v5) : o3(s2, t)) || v5);
        return c3 > 3 && v5 && Object.defineProperty(s2, t, v5), v5;
      }, u3 = this && this.__param || function(e, s2) {
        return function(t, i4) {
          s2(t, i4, e);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.BufferService = r.MINIMUM_ROWS = r.MINIMUM_COLS = void 0;
      let n3 = a2(8460), d5 = a2(844), f4 = a2(5295), p6 = a2(2585);
      r.MINIMUM_COLS = 2, r.MINIMUM_ROWS = 1;
      let _5 = r.BufferService = class extends d5.Disposable {
        get buffer() {
          return this.buffers.active;
        }
        constructor(e) {
          super(), this.isUserScrolling = false, this._onResize = this.register(new n3.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n3.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e.rawOptions.cols || 0, r.MINIMUM_COLS), this.rows = Math.max(e.rawOptions.rows || 0, r.MINIMUM_ROWS), this.buffers = this.register(new f4.BufferSet(e, this));
        }
        resize(e, s2) {
          this.cols = e, this.rows = s2, this.buffers.resize(e, s2), this._onResize.fire({ cols: e, rows: s2 });
        }
        reset() {
          this.buffers.reset(), this.isUserScrolling = false;
        }
        scroll(e, s2 = false) {
          let t = this.buffer, i4;
          i4 = this._cachedBlankLine, i4 && i4.length === this.cols && i4.getFg(0) === e.fg && i4.getBg(0) === e.bg || (i4 = t.getBlankLine(e, s2), this._cachedBlankLine = i4), i4.isWrapped = s2;
          let o3 = t.ybase + t.scrollTop, c3 = t.ybase + t.scrollBottom;
          if (t.scrollTop === 0) {
            let v5 = t.lines.isFull;
            c3 === t.lines.length - 1 ? v5 ? t.lines.recycle().copyFrom(i4) : t.lines.push(i4.clone()) : t.lines.splice(c3 + 1, 0, i4.clone()), v5 ? this.isUserScrolling && (t.ydisp = Math.max(t.ydisp - 1, 0)) : (t.ybase++, this.isUserScrolling || t.ydisp++);
          } else {
            let v5 = c3 - o3 + 1;
            t.lines.shiftElements(o3 + 1, v5 - 1, -1), t.lines.set(c3, i4.clone());
          }
          this.isUserScrolling || (t.ydisp = t.ybase), this._onScroll.fire(t.ydisp);
        }
        scrollLines(e, s2, t) {
          let i4 = this.buffer;
          if (e < 0) {
            if (i4.ydisp === 0)
              return;
            this.isUserScrolling = true;
          } else
            e + i4.ydisp >= i4.ybase && (this.isUserScrolling = false);
          let o3 = i4.ydisp;
          i4.ydisp = Math.max(Math.min(i4.ydisp + e, i4.ybase), 0), o3 !== i4.ydisp && (s2 || this._onScroll.fire(i4.ydisp));
        }
      };
      r.BufferService = _5 = l4([u3(0, p6.IOptionsService)], _5);
    }, 7994: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.CharsetService = void 0, r.CharsetService = class {
        constructor() {
          this.glevel = 0, this._charsets = [];
        }
        reset() {
          this.charset = void 0, this._charsets = [], this.glevel = 0;
        }
        setgLevel(a2) {
          this.glevel = a2, this.charset = this._charsets[a2];
        }
        setgCharset(a2, l4) {
          this._charsets[a2] = l4, this.glevel === a2 && (this.charset = l4);
        }
      };
    }, 1753: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(i4, o3, c3, v5) {
        var m6, h5 = arguments.length, g4 = h5 < 3 ? o3 : v5 === null ? v5 = Object.getOwnPropertyDescriptor(o3, c3) : v5;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          g4 = Reflect.decorate(i4, o3, c3, v5);
        else
          for (var b5 = i4.length - 1; b5 >= 0; b5--)
            (m6 = i4[b5]) && (g4 = (h5 < 3 ? m6(g4) : h5 > 3 ? m6(o3, c3, g4) : m6(o3, c3)) || g4);
        return h5 > 3 && g4 && Object.defineProperty(o3, c3, g4), g4;
      }, u3 = this && this.__param || function(i4, o3) {
        return function(c3, v5) {
          o3(c3, v5, i4);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.CoreMouseService = void 0;
      let n3 = a2(2585), d5 = a2(8460), f4 = a2(844), p6 = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (i4) => i4.button !== 4 && i4.action === 1 && (i4.ctrl = false, i4.alt = false, i4.shift = false, true) }, VT200: { events: 19, restrict: (i4) => i4.action !== 32 }, DRAG: { events: 23, restrict: (i4) => i4.action !== 32 || i4.button !== 3 }, ANY: { events: 31, restrict: (i4) => true } };
      function _5(i4, o3) {
        let c3 = (i4.ctrl ? 16 : 0) | (i4.shift ? 4 : 0) | (i4.alt ? 8 : 0);
        return i4.button === 4 ? (c3 |= 64, c3 |= i4.action) : (c3 |= 3 & i4.button, 4 & i4.button && (c3 |= 64), 8 & i4.button && (c3 |= 128), i4.action === 32 ? c3 |= 32 : i4.action !== 0 || o3 || (c3 |= 3)), c3;
      }
      let e = String.fromCharCode, s2 = { DEFAULT: (i4) => {
        let o3 = [_5(i4, false) + 32, i4.col + 32, i4.row + 32];
        return o3[0] > 255 || o3[1] > 255 || o3[2] > 255 ? "" : `\x1B[M${e(o3[0])}${e(o3[1])}${e(o3[2])}`;
      }, SGR: (i4) => {
        let o3 = i4.action === 0 && i4.button !== 4 ? "m" : "M";
        return `\x1B[<${_5(i4, true)};${i4.col};${i4.row}${o3}`;
      }, SGR_PIXELS: (i4) => {
        let o3 = i4.action === 0 && i4.button !== 4 ? "m" : "M";
        return `\x1B[<${_5(i4, true)};${i4.x};${i4.y}${o3}`;
      } }, t = r.CoreMouseService = class extends f4.Disposable {
        constructor(i4, o3) {
          super(), this._bufferService = i4, this._coreService = o3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new d5.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
          for (let c3 of Object.keys(p6))
            this.addProtocol(c3, p6[c3]);
          for (let c3 of Object.keys(s2))
            this.addEncoding(c3, s2[c3]);
          this.reset();
        }
        addProtocol(i4, o3) {
          this._protocols[i4] = o3;
        }
        addEncoding(i4, o3) {
          this._encodings[i4] = o3;
        }
        get activeProtocol() {
          return this._activeProtocol;
        }
        get areMouseEventsActive() {
          return this._protocols[this._activeProtocol].events !== 0;
        }
        set activeProtocol(i4) {
          if (!this._protocols[i4])
            throw new Error(`unknown protocol "${i4}"`);
          this._activeProtocol = i4, this._onProtocolChange.fire(this._protocols[i4].events);
        }
        get activeEncoding() {
          return this._activeEncoding;
        }
        set activeEncoding(i4) {
          if (!this._encodings[i4])
            throw new Error(`unknown encoding "${i4}"`);
          this._activeEncoding = i4;
        }
        reset() {
          this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
        }
        triggerMouseEvent(i4) {
          if (i4.col < 0 || i4.col >= this._bufferService.cols || i4.row < 0 || i4.row >= this._bufferService.rows || i4.button === 4 && i4.action === 32 || i4.button === 3 && i4.action !== 32 || i4.button !== 4 && (i4.action === 2 || i4.action === 3) || (i4.col++, i4.row++, i4.action === 32 && this._lastEvent && this._equalEvents(this._lastEvent, i4, this._activeEncoding === "SGR_PIXELS")) || !this._protocols[this._activeProtocol].restrict(i4))
            return false;
          let o3 = this._encodings[this._activeEncoding](i4);
          return o3 && (this._activeEncoding === "DEFAULT" ? this._coreService.triggerBinaryEvent(o3) : this._coreService.triggerDataEvent(o3, true)), this._lastEvent = i4, true;
        }
        explainEvents(i4) {
          return { down: !!(1 & i4), up: !!(2 & i4), drag: !!(4 & i4), move: !!(8 & i4), wheel: !!(16 & i4) };
        }
        _equalEvents(i4, o3, c3) {
          if (c3) {
            if (i4.x !== o3.x || i4.y !== o3.y)
              return false;
          } else if (i4.col !== o3.col || i4.row !== o3.row)
            return false;
          return i4.button === o3.button && i4.action === o3.action && i4.ctrl === o3.ctrl && i4.alt === o3.alt && i4.shift === o3.shift;
        }
      };
      r.CoreMouseService = t = l4([u3(0, n3.IBufferService), u3(1, n3.ICoreService)], t);
    }, 6975: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(t, i4, o3, c3) {
        var v5, m6 = arguments.length, h5 = m6 < 3 ? i4 : c3 === null ? c3 = Object.getOwnPropertyDescriptor(i4, o3) : c3;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          h5 = Reflect.decorate(t, i4, o3, c3);
        else
          for (var g4 = t.length - 1; g4 >= 0; g4--)
            (v5 = t[g4]) && (h5 = (m6 < 3 ? v5(h5) : m6 > 3 ? v5(i4, o3, h5) : v5(i4, o3)) || h5);
        return m6 > 3 && h5 && Object.defineProperty(i4, o3, h5), h5;
      }, u3 = this && this.__param || function(t, i4) {
        return function(o3, c3) {
          i4(o3, c3, t);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.CoreService = void 0;
      let n3 = a2(1439), d5 = a2(8460), f4 = a2(844), p6 = a2(2585), _5 = Object.freeze({ insertMode: false }), e = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true }), s2 = r.CoreService = class extends f4.Disposable {
        constructor(t, i4, o3) {
          super(), this._bufferService = t, this._logService = i4, this._optionsService = o3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new d5.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new d5.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new d5.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new d5.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n3.clone)(_5), this.decPrivateModes = (0, n3.clone)(e);
        }
        reset() {
          this.modes = (0, n3.clone)(_5), this.decPrivateModes = (0, n3.clone)(e);
        }
        triggerDataEvent(t, i4 = false) {
          if (this._optionsService.rawOptions.disableStdin)
            return;
          let o3 = this._bufferService.buffer;
          i4 && this._optionsService.rawOptions.scrollOnUserInput && o3.ybase !== o3.ydisp && this._onRequestScrollToBottom.fire(), i4 && this._onUserInput.fire(), this._logService.debug(`sending data "${t}"`, () => t.split("").map((c3) => c3.charCodeAt(0))), this._onData.fire(t);
        }
        triggerBinaryEvent(t) {
          this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${t}"`, () => t.split("").map((i4) => i4.charCodeAt(0))), this._onBinary.fire(t));
        }
      };
      r.CoreService = s2 = l4([u3(0, p6.IBufferService), u3(1, p6.ILogService), u3(2, p6.IOptionsService)], s2);
    }, 9074: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.DecorationService = void 0;
      let l4 = a2(8055), u3 = a2(8460), n3 = a2(844), d5 = a2(6106), f4 = 0, p6 = 0;
      class _5 extends n3.Disposable {
        get decorations() {
          return this._decorations.values();
        }
        constructor() {
          super(), this._decorations = new d5.SortedList((t) => t?.marker.line), this._onDecorationRegistered = this.register(new u3.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new u3.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n3.toDisposable)(() => this.reset()));
        }
        registerDecoration(t) {
          if (t.marker.isDisposed)
            return;
          let i4 = new e(t);
          if (i4) {
            let o3 = i4.marker.onDispose(() => i4.dispose());
            i4.onDispose(() => {
              i4 && (this._decorations.delete(i4) && this._onDecorationRemoved.fire(i4), o3.dispose());
            }), this._decorations.insert(i4), this._onDecorationRegistered.fire(i4);
          }
          return i4;
        }
        reset() {
          for (let t of this._decorations.values())
            t.dispose();
          this._decorations.clear();
        }
        *getDecorationsAtCell(t, i4, o3) {
          var c3, v5, m6;
          let h5 = 0, g4 = 0;
          for (let b5 of this._decorations.getKeyIterator(i4))
            h5 = (c3 = b5.options.x) !== null && c3 !== void 0 ? c3 : 0, g4 = h5 + ((v5 = b5.options.width) !== null && v5 !== void 0 ? v5 : 1), t >= h5 && t < g4 && (!o3 || ((m6 = b5.options.layer) !== null && m6 !== void 0 ? m6 : "bottom") === o3) && (yield b5);
        }
        forEachDecorationAtCell(t, i4, o3, c3) {
          this._decorations.forEachByKey(i4, (v5) => {
            var m6, h5, g4;
            f4 = (m6 = v5.options.x) !== null && m6 !== void 0 ? m6 : 0, p6 = f4 + ((h5 = v5.options.width) !== null && h5 !== void 0 ? h5 : 1), t >= f4 && t < p6 && (!o3 || ((g4 = v5.options.layer) !== null && g4 !== void 0 ? g4 : "bottom") === o3) && c3(v5);
          });
        }
      }
      r.DecorationService = _5;
      class e extends n3.Disposable {
        get isDisposed() {
          return this._isDisposed;
        }
        get backgroundColorRGB() {
          return this._cachedBg === null && (this.options.backgroundColor ? this._cachedBg = l4.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
        }
        get foregroundColorRGB() {
          return this._cachedFg === null && (this.options.foregroundColor ? this._cachedFg = l4.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
        }
        constructor(t) {
          super(), this.options = t, this.onRenderEmitter = this.register(new u3.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new u3.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = t.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
        }
        dispose() {
          this._onDispose.fire(), super.dispose();
        }
      }
    }, 4348: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.InstantiationService = r.ServiceCollection = void 0;
      let l4 = a2(2585), u3 = a2(8343);
      class n3 {
        constructor(...f4) {
          this._entries = /* @__PURE__ */ new Map();
          for (let [p6, _5] of f4)
            this.set(p6, _5);
        }
        set(f4, p6) {
          let _5 = this._entries.get(f4);
          return this._entries.set(f4, p6), _5;
        }
        forEach(f4) {
          for (let [p6, _5] of this._entries.entries())
            f4(p6, _5);
        }
        has(f4) {
          return this._entries.has(f4);
        }
        get(f4) {
          return this._entries.get(f4);
        }
      }
      r.ServiceCollection = n3, r.InstantiationService = class {
        constructor() {
          this._services = new n3(), this._services.set(l4.IInstantiationService, this);
        }
        setService(d5, f4) {
          this._services.set(d5, f4);
        }
        getService(d5) {
          return this._services.get(d5);
        }
        createInstance(d5, ...f4) {
          let p6 = (0, u3.getServiceDependencies)(d5).sort((s2, t) => s2.index - t.index), _5 = [];
          for (let s2 of p6) {
            let t = this._services.get(s2.id);
            if (!t)
              throw new Error(`[createInstance] ${d5.name} depends on UNKNOWN service ${s2.id}.`);
            _5.push(t);
          }
          let e = p6.length > 0 ? p6[0].index : f4.length;
          if (f4.length !== e)
            throw new Error(`[createInstance] First service dependency of ${d5.name} at position ${e + 1} conflicts with ${f4.length} static arguments`);
          return new d5(...f4, ..._5);
        }
      };
    }, 7866: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(e, s2, t, i4) {
        var o3, c3 = arguments.length, v5 = c3 < 3 ? s2 : i4 === null ? i4 = Object.getOwnPropertyDescriptor(s2, t) : i4;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          v5 = Reflect.decorate(e, s2, t, i4);
        else
          for (var m6 = e.length - 1; m6 >= 0; m6--)
            (o3 = e[m6]) && (v5 = (c3 < 3 ? o3(v5) : c3 > 3 ? o3(s2, t, v5) : o3(s2, t)) || v5);
        return c3 > 3 && v5 && Object.defineProperty(s2, t, v5), v5;
      }, u3 = this && this.__param || function(e, s2) {
        return function(t, i4) {
          s2(t, i4, e);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.traceCall = r.setTraceLogger = r.LogService = void 0;
      let n3 = a2(844), d5 = a2(2585), f4 = { trace: d5.LogLevelEnum.TRACE, debug: d5.LogLevelEnum.DEBUG, info: d5.LogLevelEnum.INFO, warn: d5.LogLevelEnum.WARN, error: d5.LogLevelEnum.ERROR, off: d5.LogLevelEnum.OFF }, p6, _5 = r.LogService = class extends n3.Disposable {
        get logLevel() {
          return this._logLevel;
        }
        constructor(e) {
          super(), this._optionsService = e, this._logLevel = d5.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), p6 = this;
        }
        _updateLogLevel() {
          this._logLevel = f4[this._optionsService.rawOptions.logLevel];
        }
        _evalLazyOptionalParams(e) {
          for (let s2 = 0; s2 < e.length; s2++)
            typeof e[s2] == "function" && (e[s2] = e[s2]());
        }
        _log(e, s2, t) {
          this._evalLazyOptionalParams(t), e.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + s2, ...t);
        }
        trace(e, ...s2) {
          var t, i4;
          this._logLevel <= d5.LogLevelEnum.TRACE && this._log((i4 = (t = this._optionsService.options.logger) === null || t === void 0 ? void 0 : t.trace.bind(this._optionsService.options.logger)) !== null && i4 !== void 0 ? i4 : console.log, e, s2);
        }
        debug(e, ...s2) {
          var t, i4;
          this._logLevel <= d5.LogLevelEnum.DEBUG && this._log((i4 = (t = this._optionsService.options.logger) === null || t === void 0 ? void 0 : t.debug.bind(this._optionsService.options.logger)) !== null && i4 !== void 0 ? i4 : console.log, e, s2);
        }
        info(e, ...s2) {
          var t, i4;
          this._logLevel <= d5.LogLevelEnum.INFO && this._log((i4 = (t = this._optionsService.options.logger) === null || t === void 0 ? void 0 : t.info.bind(this._optionsService.options.logger)) !== null && i4 !== void 0 ? i4 : console.info, e, s2);
        }
        warn(e, ...s2) {
          var t, i4;
          this._logLevel <= d5.LogLevelEnum.WARN && this._log((i4 = (t = this._optionsService.options.logger) === null || t === void 0 ? void 0 : t.warn.bind(this._optionsService.options.logger)) !== null && i4 !== void 0 ? i4 : console.warn, e, s2);
        }
        error(e, ...s2) {
          var t, i4;
          this._logLevel <= d5.LogLevelEnum.ERROR && this._log((i4 = (t = this._optionsService.options.logger) === null || t === void 0 ? void 0 : t.error.bind(this._optionsService.options.logger)) !== null && i4 !== void 0 ? i4 : console.error, e, s2);
        }
      };
      r.LogService = _5 = l4([u3(0, d5.IOptionsService)], _5), r.setTraceLogger = function(e) {
        p6 = e;
      }, r.traceCall = function(e, s2, t) {
        if (typeof t.value != "function")
          throw new Error("not supported");
        let i4 = t.value;
        t.value = function(...o3) {
          if (p6.logLevel !== d5.LogLevelEnum.TRACE)
            return i4.apply(this, o3);
          p6.trace(`GlyphRenderer#${i4.name}(${o3.map((v5) => JSON.stringify(v5)).join(", ")})`);
          let c3 = i4.apply(this, o3);
          return p6.trace(`GlyphRenderer#${i4.name} return`, c3), c3;
        };
      };
    }, 7302: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.OptionsService = r.DEFAULT_OPTIONS = void 0;
      let l4 = a2(8460), u3 = a2(844), n3 = a2(6114);
      r.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rightClickSelectsWord: n3.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
      let d5 = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
      class f4 extends u3.Disposable {
        constructor(_5) {
          super(), this._onOptionChange = this.register(new l4.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
          let e = Object.assign({}, r.DEFAULT_OPTIONS);
          for (let s2 in _5)
            if (s2 in e)
              try {
                let t = _5[s2];
                e[s2] = this._sanitizeAndValidateOption(s2, t);
              } catch (t) {
                console.error(t);
              }
          this.rawOptions = e, this.options = Object.assign({}, e), this._setupOptions();
        }
        onSpecificOptionChange(_5, e) {
          return this.onOptionChange((s2) => {
            s2 === _5 && e(this.rawOptions[_5]);
          });
        }
        onMultipleOptionChange(_5, e) {
          return this.onOptionChange((s2) => {
            _5.indexOf(s2) !== -1 && e();
          });
        }
        _setupOptions() {
          let _5 = (s2) => {
            if (!(s2 in r.DEFAULT_OPTIONS))
              throw new Error(`No option with key "${s2}"`);
            return this.rawOptions[s2];
          }, e = (s2, t) => {
            if (!(s2 in r.DEFAULT_OPTIONS))
              throw new Error(`No option with key "${s2}"`);
            t = this._sanitizeAndValidateOption(s2, t), this.rawOptions[s2] !== t && (this.rawOptions[s2] = t, this._onOptionChange.fire(s2));
          };
          for (let s2 in this.rawOptions) {
            let t = { get: _5.bind(this, s2), set: e.bind(this, s2) };
            Object.defineProperty(this.options, s2, t);
          }
        }
        _sanitizeAndValidateOption(_5, e) {
          switch (_5) {
            case "cursorStyle":
              if (e || (e = r.DEFAULT_OPTIONS[_5]), !/* @__PURE__ */ function(s2) {
                return s2 === "block" || s2 === "underline" || s2 === "bar";
              }(e))
                throw new Error(`"${e}" is not a valid value for ${_5}`);
              break;
            case "wordSeparator":
              e || (e = r.DEFAULT_OPTIONS[_5]);
              break;
            case "fontWeight":
            case "fontWeightBold":
              if (typeof e == "number" && 1 <= e && e <= 1e3)
                break;
              e = d5.includes(e) ? e : r.DEFAULT_OPTIONS[_5];
              break;
            case "cursorWidth":
              e = Math.floor(e);
            case "lineHeight":
            case "tabStopWidth":
              if (e < 1)
                throw new Error(`${_5} cannot be less than 1, value: ${e}`);
              break;
            case "minimumContrastRatio":
              e = Math.max(1, Math.min(21, Math.round(10 * e) / 10));
              break;
            case "scrollback":
              if ((e = Math.min(e, 4294967295)) < 0)
                throw new Error(`${_5} cannot be less than 0, value: ${e}`);
              break;
            case "fastScrollSensitivity":
            case "scrollSensitivity":
              if (e <= 0)
                throw new Error(`${_5} cannot be less than or equal to 0, value: ${e}`);
              break;
            case "rows":
            case "cols":
              if (!e && e !== 0)
                throw new Error(`${_5} must be numeric, value: ${e}`);
              break;
            case "windowsPty":
              e = e ?? {};
          }
          return e;
        }
      }
      r.OptionsService = f4;
    }, 2660: function(P7, r, a2) {
      var l4 = this && this.__decorate || function(f4, p6, _5, e) {
        var s2, t = arguments.length, i4 = t < 3 ? p6 : e === null ? e = Object.getOwnPropertyDescriptor(p6, _5) : e;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          i4 = Reflect.decorate(f4, p6, _5, e);
        else
          for (var o3 = f4.length - 1; o3 >= 0; o3--)
            (s2 = f4[o3]) && (i4 = (t < 3 ? s2(i4) : t > 3 ? s2(p6, _5, i4) : s2(p6, _5)) || i4);
        return t > 3 && i4 && Object.defineProperty(p6, _5, i4), i4;
      }, u3 = this && this.__param || function(f4, p6) {
        return function(_5, e) {
          p6(_5, e, f4);
        };
      };
      Object.defineProperty(r, "__esModule", { value: true }), r.OscLinkService = void 0;
      let n3 = a2(2585), d5 = r.OscLinkService = class {
        constructor(f4) {
          this._bufferService = f4, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
        }
        registerLink(f4) {
          let p6 = this._bufferService.buffer;
          if (f4.id === void 0) {
            let o3 = p6.addMarker(p6.ybase + p6.y), c3 = { data: f4, id: this._nextId++, lines: [o3] };
            return o3.onDispose(() => this._removeMarkerFromLink(c3, o3)), this._dataByLinkId.set(c3.id, c3), c3.id;
          }
          let _5 = f4, e = this._getEntryIdKey(_5), s2 = this._entriesWithId.get(e);
          if (s2)
            return this.addLineToLink(s2.id, p6.ybase + p6.y), s2.id;
          let t = p6.addMarker(p6.ybase + p6.y), i4 = { id: this._nextId++, key: this._getEntryIdKey(_5), data: _5, lines: [t] };
          return t.onDispose(() => this._removeMarkerFromLink(i4, t)), this._entriesWithId.set(i4.key, i4), this._dataByLinkId.set(i4.id, i4), i4.id;
        }
        addLineToLink(f4, p6) {
          let _5 = this._dataByLinkId.get(f4);
          if (_5 && _5.lines.every((e) => e.line !== p6)) {
            let e = this._bufferService.buffer.addMarker(p6);
            _5.lines.push(e), e.onDispose(() => this._removeMarkerFromLink(_5, e));
          }
        }
        getLinkData(f4) {
          var p6;
          return (p6 = this._dataByLinkId.get(f4)) === null || p6 === void 0 ? void 0 : p6.data;
        }
        _getEntryIdKey(f4) {
          return `${f4.id};;${f4.uri}`;
        }
        _removeMarkerFromLink(f4, p6) {
          let _5 = f4.lines.indexOf(p6);
          _5 !== -1 && (f4.lines.splice(_5, 1), f4.lines.length === 0 && (f4.data.id !== void 0 && this._entriesWithId.delete(f4.key), this._dataByLinkId.delete(f4.id)));
        }
      };
      r.OscLinkService = d5 = l4([u3(0, n3.IBufferService)], d5);
    }, 8343: (P7, r) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.createDecorator = r.getServiceDependencies = r.serviceRegistry = void 0;
      let a2 = "di$target", l4 = "di$dependencies";
      r.serviceRegistry = /* @__PURE__ */ new Map(), r.getServiceDependencies = function(u3) {
        return u3[l4] || [];
      }, r.createDecorator = function(u3) {
        if (r.serviceRegistry.has(u3))
          return r.serviceRegistry.get(u3);
        let n3 = function(d5, f4, p6) {
          if (arguments.length !== 3)
            throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
          (function(_5, e, s2) {
            e[a2] === e ? e[l4].push({ id: _5, index: s2 }) : (e[l4] = [{ id: _5, index: s2 }], e[a2] = e);
          })(n3, d5, p6);
        };
        return n3.toString = () => u3, r.serviceRegistry.set(u3, n3), n3;
      };
    }, 2585: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.IDecorationService = r.IUnicodeService = r.IOscLinkService = r.IOptionsService = r.ILogService = r.LogLevelEnum = r.IInstantiationService = r.ICharsetService = r.ICoreService = r.ICoreMouseService = r.IBufferService = void 0;
      let l4 = a2(8343);
      var u3;
      r.IBufferService = (0, l4.createDecorator)("BufferService"), r.ICoreMouseService = (0, l4.createDecorator)("CoreMouseService"), r.ICoreService = (0, l4.createDecorator)("CoreService"), r.ICharsetService = (0, l4.createDecorator)("CharsetService"), r.IInstantiationService = (0, l4.createDecorator)("InstantiationService"), function(n3) {
        n3[n3.TRACE = 0] = "TRACE", n3[n3.DEBUG = 1] = "DEBUG", n3[n3.INFO = 2] = "INFO", n3[n3.WARN = 3] = "WARN", n3[n3.ERROR = 4] = "ERROR", n3[n3.OFF = 5] = "OFF";
      }(u3 || (r.LogLevelEnum = u3 = {})), r.ILogService = (0, l4.createDecorator)("LogService"), r.IOptionsService = (0, l4.createDecorator)("OptionsService"), r.IOscLinkService = (0, l4.createDecorator)("OscLinkService"), r.IUnicodeService = (0, l4.createDecorator)("UnicodeService"), r.IDecorationService = (0, l4.createDecorator)("DecorationService");
    }, 1480: (P7, r, a2) => {
      Object.defineProperty(r, "__esModule", { value: true }), r.UnicodeService = void 0;
      let l4 = a2(8460), u3 = a2(225);
      r.UnicodeService = class {
        constructor() {
          this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new l4.EventEmitter(), this.onChange = this._onChange.event;
          let n3 = new u3.UnicodeV6();
          this.register(n3), this._active = n3.version, this._activeProvider = n3;
        }
        dispose() {
          this._onChange.dispose();
        }
        get versions() {
          return Object.keys(this._providers);
        }
        get activeVersion() {
          return this._active;
        }
        set activeVersion(n3) {
          if (!this._providers[n3])
            throw new Error(`unknown Unicode version "${n3}"`);
          this._active = n3, this._activeProvider = this._providers[n3], this._onChange.fire(n3);
        }
        register(n3) {
          this._providers[n3.version] = n3;
        }
        wcwidth(n3) {
          return this._activeProvider.wcwidth(n3);
        }
        getStringCellWidth(n3) {
          let d5 = 0, f4 = n3.length;
          for (let p6 = 0; p6 < f4; ++p6) {
            let _5 = n3.charCodeAt(p6);
            if (55296 <= _5 && _5 <= 56319) {
              if (++p6 >= f4)
                return d5 + this.wcwidth(_5);
              let e = n3.charCodeAt(p6);
              56320 <= e && e <= 57343 ? _5 = 1024 * (_5 - 55296) + e - 56320 + 65536 : d5 += this.wcwidth(e);
            }
            d5 += this.wcwidth(_5);
          }
          return d5;
        }
      };
    } }, z4 = {};
    function K3(P7) {
      var r = z4[P7];
      if (r !== void 0)
        return r.exports;
      var a2 = z4[P7] = { exports: {} };
      return G5[P7].call(a2.exports, a2, a2.exports, K3), a2.exports;
    }
    var Q5 = {};
    return (() => {
      var P7 = Q5;
      Object.defineProperty(P7, "__esModule", { value: true }), P7.Terminal = void 0;
      let r = K3(9042), a2 = K3(3236), l4 = K3(844), u3 = K3(5741), n3 = K3(8285), d5 = K3(7975), f4 = K3(7090), p6 = ["cols", "rows"];
      class _5 extends l4.Disposable {
        constructor(s2) {
          super(), this._core = this.register(new a2.Terminal(s2)), this._addonManager = this.register(new u3.AddonManager()), this._publicOptions = Object.assign({}, this._core.options);
          let t = (o3) => this._core.options[o3], i4 = (o3, c3) => {
            this._checkReadonlyOptions(o3), this._core.options[o3] = c3;
          };
          for (let o3 in this._core.options) {
            let c3 = { get: t.bind(this, o3), set: i4.bind(this, o3) };
            Object.defineProperty(this._publicOptions, o3, c3);
          }
        }
        _checkReadonlyOptions(s2) {
          if (p6.includes(s2))
            throw new Error(`Option "${s2}" can only be set in the constructor`);
        }
        _checkProposedApi() {
          if (!this._core.optionsService.rawOptions.allowProposedApi)
            throw new Error("You must set the allowProposedApi option to true to use proposed API");
        }
        get onBell() {
          return this._core.onBell;
        }
        get onBinary() {
          return this._core.onBinary;
        }
        get onCursorMove() {
          return this._core.onCursorMove;
        }
        get onData() {
          return this._core.onData;
        }
        get onKey() {
          return this._core.onKey;
        }
        get onLineFeed() {
          return this._core.onLineFeed;
        }
        get onRender() {
          return this._core.onRender;
        }
        get onResize() {
          return this._core.onResize;
        }
        get onScroll() {
          return this._core.onScroll;
        }
        get onSelectionChange() {
          return this._core.onSelectionChange;
        }
        get onTitleChange() {
          return this._core.onTitleChange;
        }
        get onWriteParsed() {
          return this._core.onWriteParsed;
        }
        get element() {
          return this._core.element;
        }
        get parser() {
          return this._parser || (this._parser = new d5.ParserApi(this._core)), this._parser;
        }
        get unicode() {
          return this._checkProposedApi(), new f4.UnicodeApi(this._core);
        }
        get textarea() {
          return this._core.textarea;
        }
        get rows() {
          return this._core.rows;
        }
        get cols() {
          return this._core.cols;
        }
        get buffer() {
          return this._buffer || (this._buffer = this.register(new n3.BufferNamespaceApi(this._core))), this._buffer;
        }
        get markers() {
          return this._checkProposedApi(), this._core.markers;
        }
        get modes() {
          let s2 = this._core.coreService.decPrivateModes, t = "none";
          switch (this._core.coreMouseService.activeProtocol) {
            case "X10":
              t = "x10";
              break;
            case "VT200":
              t = "vt200";
              break;
            case "DRAG":
              t = "drag";
              break;
            case "ANY":
              t = "any";
          }
          return { applicationCursorKeysMode: s2.applicationCursorKeys, applicationKeypadMode: s2.applicationKeypad, bracketedPasteMode: s2.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t, originMode: s2.origin, reverseWraparoundMode: s2.reverseWraparound, sendFocusMode: s2.sendFocus, wraparoundMode: s2.wraparound };
        }
        get options() {
          return this._publicOptions;
        }
        set options(s2) {
          for (let t in s2)
            this._publicOptions[t] = s2[t];
        }
        blur() {
          this._core.blur();
        }
        focus() {
          this._core.focus();
        }
        resize(s2, t) {
          this._verifyIntegers(s2, t), this._core.resize(s2, t);
        }
        open(s2) {
          this._core.open(s2);
        }
        attachCustomKeyEventHandler(s2) {
          this._core.attachCustomKeyEventHandler(s2);
        }
        registerLinkProvider(s2) {
          return this._core.registerLinkProvider(s2);
        }
        registerCharacterJoiner(s2) {
          return this._checkProposedApi(), this._core.registerCharacterJoiner(s2);
        }
        deregisterCharacterJoiner(s2) {
          this._checkProposedApi(), this._core.deregisterCharacterJoiner(s2);
        }
        registerMarker(s2 = 0) {
          return this._verifyIntegers(s2), this._core.registerMarker(s2);
        }
        registerDecoration(s2) {
          var t, i4, o3;
          return this._checkProposedApi(), this._verifyPositiveIntegers((t = s2.x) !== null && t !== void 0 ? t : 0, (i4 = s2.width) !== null && i4 !== void 0 ? i4 : 0, (o3 = s2.height) !== null && o3 !== void 0 ? o3 : 0), this._core.registerDecoration(s2);
        }
        hasSelection() {
          return this._core.hasSelection();
        }
        select(s2, t, i4) {
          this._verifyIntegers(s2, t, i4), this._core.select(s2, t, i4);
        }
        getSelection() {
          return this._core.getSelection();
        }
        getSelectionPosition() {
          return this._core.getSelectionPosition();
        }
        clearSelection() {
          this._core.clearSelection();
        }
        selectAll() {
          this._core.selectAll();
        }
        selectLines(s2, t) {
          this._verifyIntegers(s2, t), this._core.selectLines(s2, t);
        }
        dispose() {
          super.dispose();
        }
        scrollLines(s2) {
          this._verifyIntegers(s2), this._core.scrollLines(s2);
        }
        scrollPages(s2) {
          this._verifyIntegers(s2), this._core.scrollPages(s2);
        }
        scrollToTop() {
          this._core.scrollToTop();
        }
        scrollToBottom() {
          this._core.scrollToBottom();
        }
        scrollToLine(s2) {
          this._verifyIntegers(s2), this._core.scrollToLine(s2);
        }
        clear() {
          this._core.clear();
        }
        write(s2, t) {
          this._core.write(s2, t);
        }
        writeln(s2, t) {
          this._core.write(s2), this._core.write(`\r
`, t);
        }
        paste(s2) {
          this._core.paste(s2);
        }
        refresh(s2, t) {
          this._verifyIntegers(s2, t), this._core.refresh(s2, t);
        }
        reset() {
          this._core.reset();
        }
        clearTextureAtlas() {
          this._core.clearTextureAtlas();
        }
        loadAddon(s2) {
          this._addonManager.loadAddon(this, s2);
        }
        static get strings() {
          return r;
        }
        _verifyIntegers(...s2) {
          for (let t of s2)
            if (t === 1 / 0 || isNaN(t) || t % 1 != 0)
              throw new Error("This API only accepts integers");
        }
        _verifyPositiveIntegers(...s2) {
          for (let t of s2)
            if (t && (t === 1 / 0 || isNaN(t) || t % 1 != 0 || t < 0))
              throw new Error("This API only accepts positive integers");
        }
      }
      P7.Terminal = _5;
    })(), Q5;
  })());
});
var ie2 = {};
Be3(ie2, { Terminal: () => Me3, __esModule: () => Te3, default: () => Pe3 });
var we3 = Ce2(Se3());
se3(ie2, Ce2(Se3()));
var { __esModule: Te3, Terminal: Me3 } = we3;
var { default: ye3, ...Oe3 } = we3;
var Pe3 = ye3 !== void 0 ? ye3 : Oe3;

// pages/hosting/views/terminal.ts
var TerminalComponent = class extends HTMLElement {
  heap = [];
  connected = asRef(false);
  constructor() {
    super();
  }
  resize;
  terminal;
  connectedCallback() {
    this.terminal = new Me3({
      fontSize: 11,
      disableStdin: true,
      cursorBlink: true,
      convertEol: true
    });
    const fitAddon = new j6();
    const webglAddon = new Oe2();
    this.terminal.open(this);
    this.terminal.loadAddon(fitAddon);
    this.terminal.loadAddon(webglAddon);
    webglAddon.onContextLoss(() => {
      webglAddon.dispose();
    });
    for (const line of this.heap) {
      this.terminal.write(line);
    }
    for (let index = 0; index < 40; index++) {
      fitAddon.fit();
    }
    this.resize = new ResizeObserver(() => {
      for (let index = 0; index < 5; index++) {
        fitAddon.fit();
      }
    });
    this.resize.observe(this);
    this.connected.setValue(true);
  }
  reset() {
    this.terminal.reset();
    this.terminal.write("\x1B[?25l");
  }
  write(data) {
    this.heap.push(data);
    if (this.isConnected) {
      this.terminal.write(data);
    }
  }
  disconnectedCallback() {
    this.innerHTML = "";
    this.resize?.disconnect();
    this.connected.setValue(false);
  }
};
customElements.define("xterm-terminal", TerminalComponent);

// pages/hosting/views/waitingScreen.ts
init_polyfill();
init_bug_reporter();
init_mod();
init_urlpattern_polyfill();
init_main();
init_popover_polyfill();
function DisconnectedScreen() {
  return Grid(
    Grid(
      Label("Connecting to server...", "h1"),
      Label("Waiting for server availability")
    ).setJustifyItems("center")
  ).addClass("disconnected-screen");
}

// pages/hosting/views/ServerDetails.ts
function ServerDetails(server2) {
  const terminal = new TerminalComponent();
  const input = asState({
    cpu: void 0,
    memory: void 0,
    disk: void 0,
    message: ""
  });
  terminal.connected.listen((val) => {
    if (val) {
      sidecarDetailsSource.setValue((data) => {
        if (data.type == "log") {
          if (data.backlog) {
            terminal.reset();
          }
          terminal.write(data.chunk);
        }
        if (data.type == "stats") {
          input.cpu = data.stats.cpu;
          input.memory = data.stats.memory;
          input.disk = data.stats.disk;
        }
      });
    }
  });
  return refMerge({
    connected: isSidecarConnect,
    mobile: isMobile
  }).map(
    ({ connected, mobile }) => (() => {
      const items = Grid(
        ...ServerStaticInfo(mobile, server2, input),
        connected ? Entry(
          Grid(
            Box(Custom(terminal).addClass("terminal-window")).removeFromLayout(),
            Form(
              Grid(
                TextInput("text", "Send a Command").sync(input, "message"),
                Button("Send").setId("submit-button").onClick(() => {
                  messageQueueSidecar.push({
                    request: {
                      type: "command",
                      command: input.message
                    },
                    response: Promise.withResolvers()
                  });
                  input.message = "";
                })
              ).setRawColumns("auto max-content").setGap(".5rem")
            ).activeSubmitTo("#submit-button")
          ).addClass("internal-grid")
        ).addClass("terminal-card") : DisconnectedScreen(),
        Grid(
          Entry({
            title: "Storage",
            subtitle: "Manage your persistence"
          }).onClick(async () => {
            await listFiles("/");
            path.setValue("/");
            hostingMenu.path.setValue(`${hostingMenu.path.getValue()}storage/`);
          }).addClass("small"),
          Entry({
            title: "Audit Trail",
            subtitle: "Keep track of what's going on"
          }).onClick(async () => {
            const audit2 = await API.hosting.serverId(server2._id).audit().then(stupidErrorAlert);
            auditLogs.setValue(auditEntry(audit2));
            hostingMenu.path.setValue(`${hostingMenu.path.getValue()}audit-trail/`);
          }).addClass("small"),
          // Entry({
          //     title: "Sub-User",
          //     subtitle: "Add friends to manage your server",
          // }).onClick(async () => {
          //     const audit = await API.hosting.serverId(server._id).audit().then(stupidErrorAlert);
          //     auditLogs.setValue(auditEntry(audit));
          //     hostingMenu.path.setValue(`${hostingMenu.path.getValue()}audit-trail/`);
          // }).addClass("small"),
          Entry({
            title: "Settings",
            subtitle: "Update your Server"
          }).onClick(() => {
            hostingMenu.path.setValue(`${hostingMenu.path.getValue()}settings/`);
          }).addClass("small")
        ).addClass("split-list").setGap()
      ).setGap();
      if (!mobile) {
        items.setRawColumns("69% auto");
      }
      return items;
    })()
  ).asRefComponent();
}

// pages/hosting/views/menu.ts
var hostingMenu = Navigation({
  title: ref`Hi ${activeUser.$username} `,
  actions: hostingButtons,
  categories: [
    {
      id: "servers",
      title: ref`Servers ${count(state.$servers)}`,
      children: state.$servers.map(
        (servers) => servers.length == 0 ? [placeholder("Oh soo empty!", "You servers will be here when you create some!")] : servers.map(
          (server2) => ({
            id: server2._id,
            title: server2.$name,
            replacement: Grid(
              Box().addClass(server2.$state, "dot"),
              BasicLabel({
                title: server2.$name,
                subtitle: ref`${server2.$type.map((it) => servers_default[it].name)} @ ${server2.$location.map((it) => locations_default[it])}`
              }).addClass(isMobile.map((mobile) => mobile ? "small" : "desktop")).addSuffix(
                server2.$labels.map(
                  (it) => Grid(
                    ...it.map((it2) => BasicLabel({ title: labels[it2] }))
                  ).addClass("tag-node")
                ).asRefComponent()
              )
            ).setRawColumns("max-content auto").setGap("1rem").setAlignItems("center"),
            suffix: server2.labels.includes("maintenance") ? void 0 : ChangeStateButton(server2),
            clickHandler: server2.labels.includes("maintenance") ? void 0 : () => {
              startSidecarConnection(server2._id);
            },
            children: server2.labels.includes("maintenance") ? void 0 : [
              ServerDetails(server2),
              {
                id: "storage",
                hidden: true,
                title: "Storage",
                children: [
                  addonBrowser(server2),
                  FileBrowser()
                ]
              },
              {
                id: "audit-trail",
                hidden: true,
                title: "Audit Trail",
                children: auditLogs
              },
              {
                id: "settings",
                hidden: true,
                title: "Settings",
                children: [
                  {
                    id: "general",
                    title: "General Settings",
                    subtitle: "General Server Settings",
                    clickHandler: async () => editServerDialog(server2, await API.hosting.versions(server2.type).then(stupidErrorAlert)).open()
                  },
                  {
                    id: "core",
                    title: "Server Settings",
                    subtitle: "All your Settings in one place.",
                    suffix: Label("Coming Soon").setTextSize("xl").setFontWeight("medium").setMargin("0 1rem")
                  },
                  {
                    id: "delete",
                    title: "Delete Server",
                    subtitle: "Delete everything. Click once, gone forever.",
                    clickHandler: () => deleteServerDialog(server2._id).open()
                  },
                  {
                    id: "forcerestart",
                    title: "Hard Restart",
                    subtitle: "Fully restarts your Instance. This could lead to data loss.",
                    clickHandler: () => forceRestartDialog(server2._id).open()
                  }
                ]
              }
            ]
          })
        )
      )
    },
    {
      id: "resources",
      title: "Resources",
      children: [
        state.$meta.map((meta2) => meta2 ? profileView() : LoadingSpinner()).asRefComponent()
      ]
    }
  ],
  children: [
    LoadingSpinner()
  ]
}).addClass(
  isMobile.map((mobile) => mobile ? "mobile-navigation" : "navigation"),
  "limited-width"
);
state.$meta.listen(
  () => hostingMenu.path.listen((path2) => {
    if (["servers/", "resources/"].includes(path2)) {
      hostingButtons.setValue(
        [
          Button("Start new Server").setColor(state.$meta.map((meta2) => !meta2 || meta2.used.slots >= meta2.limits.slots ? "disabled" /* Disabled */ : "grayscaled" /* Grayscaled */)).onClick(() => {
            location.href = "/hosting/create";
          })
        ]
      );
      stopSidecarConnection();
    } else {
      hostingButtons.setValue([]);
    }
  })
);
var firstRouteChange = false;
hostingMenu.path.listen((path2) => {
  if (!firstRouteChange)
    return firstRouteChange = true;
  history.pushState(void 0, "", `/hosting?path=${path2}`);
});
var searchBox = asState({
  search: ""
});
searchBox.$search.listen(debounce(() => {
  const search = searchBox.search.trim();
  if (search === "")
    return;
}, 500));
var installedAddons = asRef([]);
function addonBrowser(server2) {
  const supported = ["/minecraft/default/" /* Default */, "/minecraft/modded/fabric/" /* Fabric */, "/minecraft/modded/forge/" /* Forge */].includes(server2.type);
  if (!supported) {
    return {
      id: "assets",
      title: "Add Assets",
      subtitle: "Get new Plugins, Mods, and Datapacks",
      suffix: Label("(Recommended Only)").setTextSize("xl").setFontWeight("medium").setMargin("0 1rem")
    };
  }
  const loader = createCachedLoader(createIndexPaginationLoader({
    limit: 80,
    // We need to split because forge has forge version in version field :(
    loader: (offset, limit) => getRealFiltered([server2.version.split("-")[0]], server2.type, offset, limit)
  }));
  return {
    id: "assets",
    title: "Add Assets",
    subtitle: "Get new Plugins, Mods, and Datapacks",
    clickHandler: async () => {
      loader.reset();
      await loader.next();
    },
    children: [
      Grid(
        TextInput("text", "Search").sync(searchBox, "search")
      ).setJustifyItems("end"),
      Loader(
        loader,
        ({ items, hasMore, loadMore }) => Grid(
          List(
            refMerge({
              items,
              searchString: searchBox.$search
            }).map(({ items: items2, searchString }) => items2.filter((it) => it.title.toLowerCase().includes(searchString.toLowerCase()))),
            (it) => it.slug,
            (addon2) => Entry({
              title: addon2.title,
              subtitle: addon2.description
            }).addPrefix(
              Cache(`${addon2.slug}:${addon2.icon_url}`, void 0, () => Image(addon2.icon_url || template_artwork_default, `Image of ${addon2.title}`).setWidth("100px"))
            ).addSuffix(
              Grid(
                Grid(
                  MIcon("cloud_download"),
                  Label(addon2.downloads.toString())
                ).addClass("addon-stats").setRawColumns("max-content max-content"),
                Cache(addon2.slug, () => addon2.download, (type, val) => {
                  if (type === "cache") {
                    return Button("Loading...").setColor("disabled" /* Disabled */);
                  }
                  if (val === void 0) {
                    return Button("Not Available").setColor("disabled" /* Disabled */);
                  }
                  return installedAddons.map((it) => !it.find((it2) => it2.projectId === addon2.project_id)).map(
                    (installed) => installed ? Button("Add to Server").onPromiseClick(async () => {
                      const downloadList = await collectDownloadList([server2.version], server2.type, val.project_id);
                      await installAddon(downloadList);
                      await delay(1e3);
                      installedAddons.setValue([...installedAddons.getValue(), ...downloadList]);
                    }) : Button("Uninstall").addClass("danger-button").onPromiseClick(async () => {
                      await uninstallAddon(addon2.project_id);
                      await delay(1e3);
                      installedAddons.setValue(installedAddons.getValue().filter((it) => it.projectId !== addon2.project_id));
                    })
                  ).asRefComponent();
                }).removeFromLayout(),
                Grid(
                  MIcon("update"),
                  Label(calculateUptime(new Date(addon2.date_modified)))
                ).addClass(new Date(addon2.date_modified).getTime() > Date.now() - 15 * WEEK2 ? "up-top-date" : "outdated").addClass("addon-stats").setRawColumns("max-content max-content")
              ).addClass("addon-buttons").setMargin("0 0 0 1rem")
            )
          ),
          hasMore.map(
            (it) => it ? Grid(
              Button("Load More").setMargin("var(--gap) 0 0").onPromiseClick(() => loadMore())
            ).setJustifyItems("center") : Empty()
          ).asRefComponent()
        ).setGap()
      )
    ]
  };
}
function auditEntry(audit2) {
  return audit2.map(
    (x5) => Entry(Grid(
      BasicLabel({
        title: `${auditLabels[x5.meta.action].replaceAll("$powerChange", x5.meta.action === "server-power-change" /* ServerPowerChange */ ? x5.meta.power ?? "" : "")}`,
        subtitle: `Executed by ${x5.user.profile.username}`
      }),
      Label(new Date(parseInt((x5._id ?? x5.id).substring(0, 8), 16) * 1e3).toLocaleDateString())
    )).addPrefix(showProfilePicture(x5.user)).addClass("small")
  );
}

// pages/hosting/main.ts
await RegisterAuthRefresh();
var url = new URLSearchParams(location.search);
var urlPath = url.get("path");
WebGen({
  events: {
    themeChanged: changeThemeColor()
  }
});
sheetStack.setDefault(Vertical(
  DynaNavigation("Hosting"),
  state.$loaded.map((loaded) => loaded ? hostingMenu : LoadingSpinner()).asRefComponent()
));
Body(sheetStack);
renewAccessTokenIfNeeded().then(() => refreshState()).then(async () => {
  if (!urlPath) {
    return;
  }
  const [source, serverId, subView] = urlPath.split("/");
  if (source === "servers" && serverId) {
    const server2 = await API.hosting.serverId(serverId).get().then(stupidErrorAlert);
    if (!state.servers.find((s2) => s2._id == serverId)) {
      state.servers.push(asState(server2));
    }
    startSidecarConnection(serverId);
    if (subView === "storage") {
      await listFiles("/");
      path.setValue("/");
    }
  }
  hostingMenu.path.setValue(urlPath);
}).then(() => liveUpdates()).then(() => state.loaded = true);
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)
*/
/*! Bundled license information:

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.2
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   *)
*/
/*! streamsaver. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
